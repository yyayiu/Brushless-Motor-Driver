//2018-07-24
//ie helper
if (window.console === undefined) {
	window.console = {
		"log": function(msg){
			//if (document.location.hostname === 'localhost') alert(msg);
		},
		"error": function(){}
	};
}

if (Array.isArray === undefined) {
	Array.isArray = function(obj){
		return Object.prototype.toString.call(obj) === '[object Array]';
	};
}

if (typeof Array.prototype.forEach !== 'function') {
    Array.prototype.forEach = function(callback){
      for (var i = 0; i < this.length; i++){
        callback.apply(this, [this[i], i, this]);
      }
    };
}

if (typeof Array.prototype.getUnique !== 'function') {
	Array.prototype.getUnique = function(){
	   var u = {}, a = [];
	   for(var i = 0, l = this.length; i < l; ++i){
	      if(u.hasOwnProperty(this[i])) {
	         continue;
	      }
	      a.push(this[i]);
	      u[this[i]] = 1;
	   }
	   return a;
	};
}

if (typeof Array.prototype.sortUnique !== 'function') {
	Array.prototype.sortUnique = function() {
	    this.sort();
	    var last_i;
	    for (var i=0;i<this.length;i++)
	        if ((last_i = this.lastIndexOf(this[i])) !== i)
	            this.splice(i+1, last_i-i);
	    return this;
	};
}

//surprisingly ie11 doesn't have a remove() function
//polyfill for that using removeChild
if (!("remove" in Element.prototype)) {
    Element.prototype.remove = function() {
        if (this.parentNode) {
            this.parentNode.removeChild(this);
        }
    };
}

// String.trim() for < ie9
if(typeof String.prototype.trim !== 'function') {
  String.prototype.trim = function() {
    return this.replace(/^\s+|\s+$/g, '');
  };
}


if(!window.com) com = new Object();
if(!com.TI) com.TI = new Object();

com.TI.util = {
	nsExtend : function (ns, ns_string) {
	    // a convenience function for parsing string namespaces and
	    // automatically generating nested namespaces
	    //From: http://addyosmani.com/blog/essential-js-namespacing/
	    var parts = ns_string.split('.'),
	        parent = ns,
	        pl, i;
	    pl = parts.length;
	    for (i = 0; i < pl; i++) {
	        //create a property if it doesn't exist
	        if (typeof parent[parts[i]] === 'undefined') {
	            parent[parts[i]] = {};
	        }
	        parent = parent[parts[i]];
	    }
	    return parent;
	},

	convertASCII : function(convertthis){
		// convert &#charcode; for immediate use in tag content
		// remember that riot doesnt interpret entity codes when content is passed in through data

		if (typeof(convertthis) !== 'undefined' && convertthis !== null) {

			//doesnt reliably provide ™ (trademark) for 153
			//return convertthis.replace( /&#(\d+);/g, function (match, p1) { return String.fromCharCode(p1); } )

			return convertthis.replace( /&#(\d+);/g, function (match, p1) {
				var retChar = '';
				//using switch in case we get more problem chars
				switch (p1) {
					case '153':
						retChar = '™';
						break;
					default:
						retChar = String.fromCharCode(p1);
						break;
				}
				return retChar;
			} );
		} else {
			return '';
		}
	},

	getParams : function(){
		//get params like filter, family id and family
		//for sake of prototype only need family id
		//return urlParams object
		var i,
			urlParams = {},
			urlQuery = window.location.search.substring(1),
			urlArr = urlQuery.split("&"),
			arrLen = urlArr.length;

		for (i=0;i<arrLen;i++) {
			var tmp = urlArr[i].split("=");
			urlParams[tmp[0].toLowerCase()] = decodeURI(tmp[1]);
		}

		return urlParams;
	},

	loadJSON : function(path, success, error){
		var xhr = new XMLHttpRequest();
		xhr.onreadystatechange = function(){
			if (xhr.readyState === XMLHttpRequest.DONE || xhr.readyState === 4) {
				if (xhr.status === 200) {
					if (success)
						success(JSON.parse(xhr.responseText));
				} else {
					if (error)
						error(xhr);
				}
			}
		};
		xhr.open("GET", path, true);
		xhr.send();
	},

	hasClass : function(e, className) {
		return new RegExp(' ' + className + ' ').test(' ' + e.className + ' ');
	},

	addClass : function(e, className) {
		if (!this.hasClass(e, className)) e.className += ' ' + className;
	},

	removeClass : function(e, className) {
		var tmpClass = ' ' + e.className.replace( /[\t\r\n]/g, ' ') + ' ';
		if (this.hasClass(e, className) && tmpClass.indexOf(' ' + className + ' ') >= 0) {
			tmpClass = tmpClass.replace(' ' + className + ' ', ' ');
		 	e.className = tmpClass.replace(/^\s+|\s+$/g, '');
		}
	},

	toggleClass : function(e, className) {
		if (this.hasClass(e, className)) this.removeClass(e, className);
		else this.addClass(e, className);
	},

	inArray : function(e, array, i) {
	    var len;
	    if ( array ) {
	        if ( array.indexOf ) {
	            return array.indexOf.call( array, e, i );
	        }
	        len = array.length;
	        i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;
	        for ( ; i < len; i++ ) {
	            // Skip accessing in sparse arrays
	            if ( i in array && array[ i ] === e ) {
	                return i;
	            }
	        }
	    }
	    return -1;
	},

	isEmpty : function(obj) {
		if (obj === undefined || obj === null) return true;
		if (obj.length > 0) return false;
		if (obj.length === 0) return true;
		for (var k in obj) {
        	if (Object.prototype.hasOwnProperty.call(obj, k)) return false;
    	}
    	return true;
	},

	sortArrayByProp : function(prop, dir, isSortByV) {
		return function(a,b) {
			var a = a[prop],
				b = b[prop],
				tmpA,
				tmpB;

			if(Array.isArray(a)) {
				if (a.length > 1) {
					a.sort((com.TI.util.sortArrayByProp)('l', dir, isSortByV));
				}
				a = a[0];
				if (a.v !== undefined && isSortByV) {
					a = a.v;
				}else if(a.l != undefined){
					a = a.l;
				}
			}
			if(Array.isArray(b)) {
				if (b.length > 1) {
					b.sort((com.TI.util.sortArrayByProp)('l', dir, isSortByV));
				}
				b = b[0];
				if (b.v !== undefined && isSortByV) {
					b = b.v;
				}else if(b.l !== undefined){
					b = b.l;
				}
			}

			//both are equal, don't move them
			if (a === b) return 0;

			//if you find a space, push it down in up or down
			if (a === "") return 1;
			if (b === "") return -1;

			//cache parseFloats
			tmpA = parseFloat(a);
			tmpB = parseFloat(b);

			// if at least one starts with a number
			if (!isNaN(tmpA) || !isNaN(tmpB)) {
				a = (!isNaN(tmpA) ? tmpA : (dir == 'asc' ? Infinity : -1) ); // string values will always be sorted to the bottom, regardless of direction
				b = (!isNaN(tmpB) ? tmpB : (dir == 'asc' ? Infinity : -1) );
			}
			// else compare strings

			if (a === b) return 0;

			if (dir === undefined || dir === "asc") return (a < b) ? -1 : 1;
			else return (a > b) ? -1 : 1;

		};
	},

	html2sheet : function(htmlStringBody) {
		var url = com.TI.rst.langStore.URLs.SERVER_BASE + com.TI.rst.langStore.URLs.EXPORT_SERVICE,
			target = "_DownloadResults",
			htmlStringHead = '<head><style>.rsttext { mso-number-format:"\@"; }</style></head>',
			htmlStringStart = "<html><meta http-equiv=Content-Type content='text/html; charset=utf-8'>" + htmlStringHead + "<body>",
			htmlStringEnd = "</table></body></html>",
			form,
			hiddenField,
			html;
			//to create temp form and submit to URL

		html = [htmlStringStart, htmlStringBody, htmlStringEnd].join("");

		form = document.createElement("form");
		form.setAttribute("id", "_downloadResults");
		form.setAttribute("method", "post");
		form.setAttribute("action", url);
		form.setAttribute("target", target);
		hiddenField = document.createElement("input");
		hiddenField.setAttribute("type", "hidden");
		hiddenField.setAttribute("name", "downloadContent");
		hiddenField.setAttribute("value", html);

		form.appendChild(hiddenField);
		document.body.appendChild(form);
		form.submit();
	},

	getCookie : function(cName) {
		var cValue = document.cookie;
		var cStart = cValue.indexOf(" " + cName + "=");
		if (cStart === -1){
			cStart = cValue.indexOf(cName + "=");
		}
		if (cStart === -1){
			cValue = null;
		} else {
			cStart = cValue.indexOf("=", cStart) + 1;
			var cEnd = cValue.indexOf(";", cStart);
			if (cEnd === -1) {
				cEnd = cValue.length;
			}
			cValue = unescape(cValue.substring(cStart, cEnd));
		}
		return cValue;
	},

	decimalPlaces : function(){
		function isInt(n){
			return typeof n === "number" && parseFloat(n) === parseInt(n, 10) && !isNaN(n);
		}
		return function(n) {
			var a = Math.abs(n);
			var c = a,
				count = 1;
			while(!isInt(c) && isFinite(c)) {
				c = a * Math.pow(10,count++);
      		}
      		return count-1;
   		};
	}(),

	getColArray : function(multiColArr, col) {
		var ret = [],
			len = multiColArr.length,
			i;
		for (i=0; i<len; i++) ret.push(multiColArr[i][col]);
		return ret;
	}
};




if(!window.com) com = new Object();
if(!com.TI) com.TI = new Object();

com.TI.rst = {
	/**
	 * generateQuery
	 *
	 * Function to generate a query object based on a string of query
	 * parameters and parametric control data for a product family. The
	 * query object is used to control the selection tool.
	 *
	 * @param { string } queryParams A string of parameters e.g. p2954=PDIP&p480=...
	 * @param { Object } controlData Control data from the paramdata service for the product family
	 * @returns { Object } An object containing query data for use by the selection tool
	 * @see com.TI.rst#filterQP
	 */
	generateQuery : function(queryParams, controlData) {
		var q = {},
			qArr = queryParams.split("&"),
			len = qArr.length,
			i, tmpType, tmpCid, tmpVal, tmpArr;

		for (i=0; i<len; i++) {
			tmpArr = qArr[i].split("=");
			if (qArr[i] === undefined || qArr[i] === "" || tmpArr.length !== 2) continue;
			if (tmpArr[0].indexOf("~") === 0) {
				tmpType = "AND";
				tmpCid = tmpArr[0].replace("~","");
			} else if (tmpArr[0].indexOf("!") === 0) {
				tmpType = "NOT";
				tmpCid = tmpArr[0].replace("!","");
			} else {
				tmpType = "OR";
				tmpCid = tmpArr[0];
			}
			if (controlData[tmpCid] === undefined) continue;

			tmpVal = tmpArr[1].split(";")

			if (controlData[tmpCid]["controlType"] === "S") {
				if (tmpCid == "p1192") {
					tmpType = "OPTEMPRANGE";
				}
				else {
					tmpType = "RANGE";
				}
				tmpVal[0] = parseFloat(tmpVal[0]);
				tmpVal[1] = parseFloat(tmpVal[1]);
			}



			// in FF, the values will sometimes come back with URI encoding
			// TODO: not sure if we need to do input cleaning here to avoid xss
			else if (Array.isArray(tmpVal)) {
				for (j=0; j<tmpVal.length; j++) {
					tmpVal[j] = tmpVal[j].replace(new RegExp('%20', 'g'), ' ');
					tmpVal[j] = tmpVal[j].replace(new RegExp('%26', 'g'), '&');
				}
			}
			q[tmpCid] = {
				"type" : tmpType,
				"values" : tmpVal
			}
		}
		return q;
	},

	/**
	 * filterQP
	 *
	 * Function to update the selection tool according to the parameters
	 * by triggering the appropriate RST events. Typically used by the one-click
	 * parameter search links to update the selection tool when the link is clicked.
	 *
	 * @param { Object } queryData An object representing the query
	 * @param { string[] } colUpdates An array of the column names used by the query
	 * @param { string } sortBy Name of the column used for sorting
	 * @param { boolean } sortInverse Flag to indicate a reverse sort order
	 */
	filterQP : function(queryData, colUpdates, sortBy, sortInverse){
		RiotControl.trigger("rst_qs_col_update", colUpdates, queryData);
		RiotControl.trigger("rst_filter", queryData);
		RiotControl.trigger("rst_apply", undefined, undefined, colUpdates, 'quickLink');
		if (sortBy !== undefined) RiotControl.trigger("rst_sort", sortBy, sortInverse);
	},


	q2string: function(q) {
		var ret = "",
			cid,
			qItem;

		for (cid in q) {
			qItem = q[cid];
			if (qItem.type === "AND") ret += "~";
			else if (qItem.type === "NOT") ret += "!";
			ret += cid;
			ret += "=";
			ret += qItem.values.join(";");
			ret += "&";
		}
		ret = ret.substr(0, ret.length-1);
		return ret;
	}
}

/* Riot v2.2.4, @license MIT, (c) 2015 Muut Inc. + contributors */

;(function(window, undefined) {
  'use strict';
var riot = { version: 'v2.2.4', settings: {} },
  //// be aware, internal usage

  // counter to give a unique id to all the Tag instances
  __uid = 0,

  // riot specific prefixes
  RIOT_PREFIX = 'riot-',
  RIOT_TAG = RIOT_PREFIX + 'tag',

  // for typeof == '' comparisons
  T_STRING = 'string',
  T_OBJECT = 'object',
  T_UNDEF  = 'undefined',
  T_FUNCTION = 'function',
  // special native tags that cannot be treated like the others
  SPECIAL_TAGS_REGEX = /^(?:opt(ion|group)|tbody|col|t[rhd])$/,
  RESERVED_WORDS_BLACKLIST = ['_item', '_id', 'update', 'root', 'mount', 'unmount', 'mixin', 'isMounted', 'isLoop', 'tags', 'parent', 'opts', 'trigger', 'on', 'off', 'one'],

  // version# for IE 8-11, 0 for others
  IE_VERSION = (window && window.document || {}).documentMode | 0,

  // Array.isArray for IE8 is in the polyfills
  isArray = Array.isArray

riot.observable = function(el) {

  el = el || {}

  var callbacks = {},
      _id = 0

  el.on = function(events, fn) {
    if (isFunction(fn)) {
      if (typeof fn.id === T_UNDEF) fn._id = _id++

      events.replace(/\S+/g, function(name, pos) {
        (callbacks[name] = callbacks[name] || []).push(fn)
        fn.typed = pos > 0
      })
    }
    return el
  }

  el.off = function(events, fn) {
    if (events == '*') callbacks = {}
    else {
      events.replace(/\S+/g, function(name) {
        if (fn) {
          var arr = callbacks[name]
          for (var i = 0, cb; (cb = arr && arr[i]); ++i) {
            if (cb._id == fn._id) arr.splice(i--, 1)
          }
        } else {
          callbacks[name] = []
        }
      })
    }
    return el
  }

  // only single event supported
  el.one = function(name, fn) {
    function on() {
      el.off(name, on)
      fn.apply(el, arguments)
    }
    return el.on(name, on)
  }

  el.trigger = function(name) {
    var args = [].slice.call(arguments, 1),
        fns = callbacks[name] || []

    for (var i = 0, fn; (fn = fns[i]); ++i) {
      if (!fn.busy) {
        fn.busy = 1
        fn.apply(el, fn.typed ? [name].concat(args) : args)
        if (fns[i] !== fn) { i-- }
        fn.busy = 0
      }
    }

    if (callbacks.all && name != 'all') {
      el.trigger.apply(el, ['all', name].concat(args))
    }

    return el
  }

  return el

}
riot.mixin = (function() {
  var mixins = {}

  return function(name, mixin) {
    if (!mixin) return mixins[name]
    mixins[name] = mixin
  }

})()

;(function(riot, evt, win) {

  // browsers only
  if (!win) return

  var loc = win.location,
      fns = riot.observable(),
      started = false,
      current

  function hash() {
    return loc.href.split('#')[1] || ''   // why not loc.hash.splice(1) ?
  }

  function parser(path) {
    return path.split('/')
  }

  function emit(path) {
    if (path.type) path = hash()

    if (path != current) {
      fns.trigger.apply(null, ['H'].concat(parser(path)))
      current = path
    }
  }

  var r = riot.route = function(arg) {
    // string
    if (arg[0]) {
      loc.hash = arg
      emit(arg)

    // function
    } else {
      fns.on('H', arg)
    }
  }

  r.exec = function(fn) {
    fn.apply(null, parser(hash()))
  }

  r.parser = function(fn) {
    parser = fn
  }

  r.stop = function () {
    if (started) {
      if (win.removeEventListener) win.removeEventListener(evt, emit, false) //@IE8 - the if()
      else win.detachEvent('on' + evt, emit) //@IE8
      fns.off('*')
      started = false
    }
  }

  r.start = function () {
    if (!started) {
      if (win.addEventListener) win.addEventListener(evt, emit, false) //@IE8 - the if()
      else win.attachEvent('on' + evt, emit) //IE8
      started = true
    }
  }

  // autostart the router
  r.start()

})(riot, 'hashchange', window)
/*

//// How it works?


Three ways:

1. Expressions: tmpl('{ value }', data).
   Returns the result of evaluated expression as a raw object.

2. Templates: tmpl('Hi { name } { surname }', data).
   Returns a string with evaluated expressions.

3. Filters: tmpl('{ show: !done, highlight: active }', data).
   Returns a space separated list of trueish keys (mainly
   used for setting html classes), e.g. "show highlight".


// Template examples

tmpl('{ title || "Untitled" }', data)
tmpl('Results are { results ? "ready" : "loading" }', data)
tmpl('Today is { new Date() }', data)
tmpl('{ message.length > 140 && "Message is too long" }', data)
tmpl('This item got { Math.round(rating) } stars', data)
tmpl('<h1>{ title }</h1>{ body }', data)


// Falsy expressions in templates

In templates (as opposed to single expressions) all falsy values
except zero (undefined/null/false) will default to empty string:

tmpl('{ undefined } - { false } - { null } - { 0 }', {})
// will return: " - - - 0"

*/


var brackets = (function(orig) {

  var cachedBrackets,
      r,
      b,
      re = /[{}]/g

  return function(x) {

    // make sure we use the current setting
    var s = riot.settings.brackets || orig

    // recreate cached vars if needed
    if (cachedBrackets !== s) {
      cachedBrackets = s
      b = s.split(' ')
      r = b.map(function (e) { return e.replace(/(?=.)/g, '\\') })
    }

    // if regexp given, rewrite it with current brackets (only if differ from default)
    return x instanceof RegExp ? (
        s === orig ? x :
        new RegExp(x.source.replace(re, function(b) { return r[~~(b === '}')] }), x.global ? 'g' : '')
      ) :
      // else, get specific bracket
      b[x]
  }
})('{ }')


var tmpl = (function() {

  var cache = {},
      OGLOB = '"in d?d:' + (window ? 'window).' : 'global).'),
      reVars =
      /(['"\/])(?:[^\\]*?|\\.|.)*?\1|\.\w*|\w*:|\b(?:(?:new|typeof|in|instanceof) |(?:this|true|false|null|undefined)\b|function\s*\()|([A-Za-z_$]\w*)/g

  // build a template (or get it from cache), render with data
  return function(str, data) {
    return str && (cache[str] || (cache[str] = tmpl(str)))(data)
  }


  // create a template instance

  function tmpl(s, p) {

    if (s.indexOf(brackets(0)) < 0) {
      // return raw text
      s = s.replace(/\n|\r\n?/g, '\n')
      return function () { return s }
    }

    // temporarily convert \{ and \} to a non-character
    s = s
      .replace(brackets(/\\{/g), '\uFFF0')
      .replace(brackets(/\\}/g), '\uFFF1')

    // split string to expression and non-expresion parts
    p = split(s, extract(s, brackets(/{/), brackets(/}/)))

    // is it a single expression or a template? i.e. {x} or <b>{x}</b>
    s = (p.length === 2 && !p[0]) ?

      // if expression, evaluate it
      expr(p[1]) :

      // if template, evaluate all expressions in it
      '[' + p.map(function(s, i) {

        // is it an expression or a string (every second part is an expression)
        return i % 2 ?

          // evaluate the expressions
          expr(s, true) :

          // process string parts of the template:
          '"' + s

            // preserve new lines
            .replace(/\n|\r\n?/g, '\\n')

            // escape quotes
            .replace(/"/g, '\\"') +

          '"'

      }).join(',') + '].join("")'

    return new Function('d', 'return ' + s
      // bring escaped { and } back
      .replace(/\uFFF0/g, brackets(0))
      .replace(/\uFFF1/g, brackets(1)) + ';')

  }


  // parse { ... } expression

  function expr(s, n) {
    s = s

      // convert new lines to spaces
      .replace(/\n|\r\n?/g, ' ')

      // trim whitespace, brackets, strip comments
      .replace(brackets(/^[{ ]+|[ }]+$|\/\*.+?\*\//g), '')

    // is it an object literal? i.e. { key : value }
    return /^\s*[\w- "']+ *:/.test(s) ?

      // if object literal, return trueish keys
      // e.g.: { show: isOpen(), done: item.done } -> "show done"
      '[' +

          // extract key:val pairs, ignoring any nested objects
          extract(s,

              // name part: name:, "name":, 'name':, name :
              /["' ]*[\w- ]+["' ]*:/,

              // expression part: everything upto a comma followed by a name (see above) or end of line
              /,(?=["' ]*[\w- ]+["' ]*:)|}|$/
              ).map(function(pair) {

                // get key, val parts
                return pair.replace(/^[ "']*(.+?)[ "']*: *(.+?),? *$/, function(_, k, v) {

                  // wrap all conditional parts to ignore errors
                  return v.replace(/[^&|=!><]+/g, wrap) + '?"' + k + '":"",'

                })

              }).join('') +

        '].join(" ").trim()' :

      // if js expression, evaluate as javascript
      wrap(s, n)

  }


  // execute js w/o breaking on errors or undefined vars

  function wrap(s, nonull) {
    s = s.trim()
    return !s ? '' : '(function(v){try{v=' +

      // prefix vars (name => data.name)
      s.replace(reVars, function(s, _, v) { return v ? '(("' + v + OGLOB + v + ')' : s }) +

      // default to empty string for falsy values except zero
      '}catch(e){}return ' + (nonull === true ? '!v&&v!==0?"":v' : 'v') + '}).call(d)'
  }


  // split string by an array of substrings

  function split(str, substrings) {
    var parts = []
    substrings.map(function(sub, i) {

      // push matched expression and part before it
      i = str.indexOf(sub)
      parts.push(str.slice(0, i), sub)
      str = str.slice(i + sub.length)
    })
    if (str) parts.push(str)

    // push the remaining part
    return parts
  }


  // match strings between opening and closing regexp, skipping any inner/nested matches

  function extract(str, open, close) {

    var start,
        level = 0,
        matches = [],
        re = new RegExp('(' + open.source + ')|(' + close.source + ')', 'g')

    str.replace(re, function(_, open, close, pos) {

      // if outer inner bracket, mark position
      if (!level && open) start = pos

      // in(de)crease bracket level
      level += open ? 1 : -1

      // if outer closing bracket, grab the match
      if (!level && close != null) matches.push(str.slice(start, pos + close.length))

    })

    return matches
  }

})()

/*
  lib/browser/tag/mkdom.js

  Includes hacks needed for the Internet Explorer version 9 and bellow

*/
// http://kangax.github.io/compat-table/es5/#ie8
// http://codeplanet.io/dropping-ie8/

var mkdom = (function (checkIE) {

  var rootEls = {
        'tr': 'tbody',
        'th': 'tr',
        'td': 'tr',
        'tbody': 'table',
        'col': 'colgroup'
      },
      GENERIC = 'div'

  checkIE = checkIE && checkIE < 10

  // creates any dom element in a div, table, or colgroup container
  function _mkdom(html) {

    var match = html && html.match(/^\s*<([-\w]+)/),
        tagName = match && match[1].toLowerCase(),
        rootTag = rootEls[tagName] || GENERIC,
        el = mkEl(rootTag)

    el.stub = true

    if (checkIE && tagName && (match = tagName.match(SPECIAL_TAGS_REGEX)))
      ie9elem(el, html, tagName, !!match[1])
    else
      el.innerHTML = html

    return el
  }

  // creates tr, th, td, option, optgroup element for IE8-9
  /* istanbul ignore next */
  function ie9elem(el, html, tagName, select) {

    var div = mkEl(GENERIC),
        tag = select ? 'select>' : 'table>',
        child

    div.innerHTML = '<' + tag + html + '</' + tag

    child = div.getElementsByTagName(tagName)[0]
    if (child)
      el.appendChild(child)

  }
  // end ie9elem()

  return _mkdom

})(IE_VERSION)

// { key, i in items} -> { key, i, items }
function loopKeys(expr) {
  var b0 = brackets(0),
      els = expr.trim().slice(b0.length).match(/^\s*(\S+?)\s*(?:,\s*(\S+))?\s+in\s+(.+)$/)
  return els ? { key: els[1], pos: els[2], val: b0 + els[3] } : { val: expr }
}

function mkitem(expr, key, val) {
  var item = {}
  item[expr.key] = key
  if (expr.pos) item[expr.pos] = val
  return item
}


/* Beware: heavy stuff */
function _each(dom, parent, expr) {

  remAttr(dom, 'each')

  var tagName = getTagName(dom),
      template = dom.outerHTML,
      hasImpl = !!tagImpl[tagName],
      impl = tagImpl[tagName] || {
        tmpl: template
      },
      root = dom.parentNode,
      placeholder = document.createComment('riot placeholder'),
      tags = [],
      child = getTag(dom),
      checksum

  root.insertBefore(placeholder, dom)

  expr = loopKeys(expr)

  // clean template code
  parent
    .one('premount', function () {
      if (root.stub) root = parent.root
      // remove the original DOM node
      dom.parentNode.removeChild(dom)
    })
    .on('update', function () {
      var items = tmpl(expr.val, parent)

      // object loop. any changes cause full redraw
      if (!isArray(items)) {

        checksum = items ? JSON.stringify(items) : ''

        items = !items ? [] :
          Object.keys(items).map(function (key) {
            return mkitem(expr, key, items[key])
          })
      }

      var frag = document.createDocumentFragment(),
          i = tags.length,
          j = items.length

      // unmount leftover items
      while (i > j) {
        tags[--i].unmount()
        tags.splice(i, 1)
      }

      for (i = 0; i < j; ++i) {
        var _item = !checksum && !!expr.key ? mkitem(expr, items[i], i) : items[i]

        if (!tags[i]) {
          // mount new
          (tags[i] = new Tag(impl, {
              parent: parent,
              isLoop: true,
              hasImpl: hasImpl,
              root: SPECIAL_TAGS_REGEX.test(tagName) ? root : dom.cloneNode(),
              item: _item
            }, dom.innerHTML)
          ).mount()

          frag.appendChild(tags[i].root)
        } else
          tags[i].update(_item)

        tags[i]._item = _item

      }

      root.insertBefore(frag, placeholder)

      if (child) parent.tags[tagName] = tags

    }).one('updated', function() {
      var keys = Object.keys(parent)// only set new values
      walk(root, function(node) {
        // only set element node and not isLoop
        if (node.nodeType == 1 && !node.isLoop && !node._looped) {
          node._visited = false // reset _visited for loop node
          node._looped = true // avoid set multiple each
          setNamed(node, parent, keys)
        }
      })
    })

}


function parseNamedElements(root, tag, childTags) {

  walk(root, function(dom) {
    if (dom.nodeType == 1) {
      dom.isLoop = dom.isLoop || (dom.parentNode && dom.parentNode.isLoop || dom.getAttribute('each')) ? 1 : 0

      // custom child tag
      var child = getTag(dom)

      if (child && !dom.isLoop) {
        childTags.push(initChildTag(child, dom, tag))
      }

      if (!dom.isLoop)
        setNamed(dom, tag, [])
    }

  })

}

function parseExpressions(root, tag, expressions) {

  function addExpr(dom, val, extra) {
    if (val.indexOf(brackets(0)) >= 0) {
      var expr = { dom: dom, expr: val }
      expressions.push(extend(expr, extra))
    }
  }

  walk(root, function(dom) {
    var type = dom.nodeType

    // text node
    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)
    if (type != 1) return

    /* element */

    // loop
    var attr = dom.getAttribute('each')

    if (attr) { _each(dom, tag, attr); return false }

    // attribute expressions
    each(dom.attributes, function(attr) {
      var name = attr.name,
        bool = name.split('__')[1]

      addExpr(dom, attr.value, { attr: bool || name, bool: bool })
      if (bool) { remAttr(dom, name); return false }

    })

    // skip custom tags
    if (getTag(dom)) return false

  })

}
function Tag(impl, conf, innerHTML) {

  var self = riot.observable(this),
      opts = inherit(conf.opts) || {},
      dom = mkdom(impl.tmpl),
      parent = conf.parent,
      isLoop = conf.isLoop,
      hasImpl = conf.hasImpl,
      item = cleanUpData(conf.item),
      expressions = [],
      childTags = [],
      root = conf.root,
      fn = impl.fn,
      tagName = root.tagName.toLowerCase(),
      attr = {},
      propsInSyncWithParent = []

  if (fn && root._tag) {
    root._tag.unmount(true)
  }

  // not yet mounted
  this.isMounted = false
  root.isLoop = isLoop

  // keep a reference to the tag just created
  // so we will be able to mount this tag multiple times
  root._tag = this

  // create a unique id to this tag
  // it could be handy to use it also to improve the virtual dom rendering speed
  this._id = __uid++

  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)

  // grab attributes
  each(root.attributes, function(el) {
    var val = el.value
    // remember attributes with expressions only
    if (brackets(/{.*}/).test(val)) attr[el.name] = val
  })

  if (dom.innerHTML && !/^(select|optgroup|table|tbody|tr|col(?:group)?)$/.test(tagName))
    // replace all the yield tags with the tag inner html
    dom.innerHTML = replaceYield(dom.innerHTML, innerHTML)

  // options
  function updateOpts() {
    var ctx = hasImpl && isLoop ? self : parent || self

    // update opts from current DOM attributes
    each(root.attributes, function(el) {
      opts[el.name] = tmpl(el.value, ctx)
    })
    // recover those with expressions
    each(Object.keys(attr), function(name) {
      opts[name] = tmpl(attr[name], ctx)
    })
  }

  function normalizeData(data) {
    for (var key in item) {
      if (typeof self[key] !== T_UNDEF)
        self[key] = data[key]
    }
  }

  function inheritFromParent () {
    if (!self.parent || !isLoop) return
    each(Object.keys(self.parent), function(k) {
      // some properties must be always in sync with the parent tag
      var mustSync = !~RESERVED_WORDS_BLACKLIST.indexOf(k) && ~propsInSyncWithParent.indexOf(k)
      if (typeof self[k] === T_UNDEF || mustSync) {
        // track the property to keep in sync
        // so we can keep it updated
        if (!mustSync) propsInSyncWithParent.push(k)
        self[k] = self.parent[k]
      }
    })
  }

  this.update = function(data) {
    // make sure the data passed will not override
    // the component core methods
    data = cleanUpData(data)
    // inherit properties from the parent
    inheritFromParent()
    // normalize the tag properties in case an item object was initially passed
    if (data && typeof item === T_OBJECT) {
      normalizeData(data)
      item = data
    }
    extend(self, data)
    updateOpts()
    self.trigger('update', data)
    update(expressions, self)
    self.trigger('updated')
  }

  this.mixin = function() {
    each(arguments, function(mix) {
      mix = typeof mix === T_STRING ? riot.mixin(mix) : mix
      each(Object.keys(mix), function(key) {
        // bind methods to self
        if (key != 'init')
          self[key] = isFunction(mix[key]) ? mix[key].bind(self) : mix[key]
      })
      // init method will be called automatically
      if (mix.init) mix.init.bind(self)()
    })
  }

  this.mount = function() {

    updateOpts()

    // initialiation
    if (fn) fn.call(self, opts)

    // parse layout after init. fn may calculate args for nested custom tags
    parseExpressions(dom, self, expressions)

    // mount the child tags
    toggle(true)

    // update the root adding custom attributes coming from the compiler
    // it fixes also #1087
    if (impl.attrs || hasImpl) {
      walkAttributes(impl.attrs, function (k, v) { root.setAttribute(k, v) })
      parseExpressions(self.root, self, expressions)
    }

    if (!self.parent || isLoop) self.update(item)

    // internal use only, fixes #403
    self.trigger('premount')

    if (isLoop && !hasImpl) {
      // update the root attribute for the looped elements
      self.root = root = dom.firstChild

    } else {
      while (dom.firstChild) root.appendChild(dom.firstChild)
      if (root.stub) self.root = root = parent.root
    }
    // if it's not a child tag we can trigger its mount event
    if (!self.parent || self.parent.isMounted) {
      self.isMounted = true
      self.trigger('mount')
    }
    // otherwise we need to wait that the parent event gets triggered
    else self.parent.one('mount', function() {
      // avoid to trigger the `mount` event for the tags
      // not visible included in an if statement
      if (!isInStub(self.root)) {
        self.parent.isMounted = self.isMounted = true
        self.trigger('mount')
      }
    })
  }


  this.unmount = function(keepRootTag) {
    var el = root,
        p = el.parentNode,
        ptag

    if (p) {

      if (parent) {
        ptag = getImmediateCustomParentTag(parent)
        // remove this tag from the parent tags object
        // if there are multiple nested tags with same name..
        // remove this element form the array
        if (isArray(ptag.tags[tagName]))
          each(ptag.tags[tagName], function(tag, i) {
            if (tag._id == self._id)
              ptag.tags[tagName].splice(i, 1)
          })
        else
          // otherwise just delete the tag instance
          ptag.tags[tagName] = undefined
      }

      else
        while (el.firstChild) el.removeChild(el.firstChild)

      if (!keepRootTag)
        p.removeChild(el)
      else
        // the riot-tag attribute isn't needed anymore, remove it
        p.removeAttribute('riot-tag')
    }


    self.trigger('unmount')
    toggle()
    self.off('*')
    // somehow ie8 does not like `delete root._tag`
    root._tag = null

  }

  function toggle(isMount) {

    // mount/unmount children
    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })

    // listen/unlisten parent (events flow one way from parent to children)
    if (parent) {
      var evt = isMount ? 'on' : 'off'

      // the loop tags will be always in sync with the parent automatically
      if (isLoop)
        parent[evt]('unmount', self.unmount)
      else
        parent[evt]('update', self.update)[evt]('unmount', self.unmount)
    }
  }

  // named elements available for fn
  parseNamedElements(dom, this, childTags)


}

function setEventHandler(name, handler, dom, tag) {

  dom[name] = function(e) {

    var item = tag._item,
        ptag = tag.parent,
        el

    if (!item)
      while (ptag && !item) {
        item = ptag._item
        ptag = ptag.parent
      }

    // cross browser event fix
    e = e || window.event

    // ignore error on some browsers
    try {
      e.currentTarget = dom
      if (!e.target) e.target = e.srcElement
      if (!e.which) e.which = e.charCode || e.keyCode
    } catch (ignored) { /**/ }

    e.item = item

    // prevent default behaviour (by default)
    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {
      if (e.preventDefault) e.preventDefault()
      e.returnValue = false
    }

    if (!e.preventUpdate) {
      el = item ? getImmediateCustomParentTag(ptag) : tag
      el.update()
    }

  }

}

// used by if- attribute
function insertTo(root, node, before) {
  if (root) {
    root.insertBefore(before, node)
    root.removeChild(node)
  }
}

function update(expressions, tag) {

  each(expressions, function(expr, i) {

    var dom = expr.dom,
        attrName = expr.attr,
        value = tmpl(expr.expr, tag),
        parent = expr.dom.parentNode

    if (expr.bool)
      value = value ? attrName : false
    else if (value == null)
      value = ''

    // leave out riot- prefixes from strings inside textarea
    // fix #815: any value -> string
    if (parent && parent.tagName == 'TEXTAREA') value = ('' + value).replace(/riot-/g, '')

    // no change
    if (expr.value === value) return
    expr.value = value

    // text node
    if (!attrName) {
      dom.nodeValue = '' + value    // #815 related
      return
    }

    // remove original attribute
    remAttr(dom, attrName)
    // event handler
    if (isFunction(value)) {
      setEventHandler(attrName, value, dom, tag)

    // if- conditional
    } else if (attrName == 'if') {
      var stub = expr.stub,
          add = function() { insertTo(stub.parentNode, stub, dom) },
          remove = function() { insertTo(dom.parentNode, dom, stub) }

      // add to DOM
      if (value) {
        if (stub) {
          add()
          dom.inStub = false
          // avoid to trigger the mount event if the tags is not visible yet
          // maybe we can optimize this avoiding to mount the tag at all
          if (!isInStub(dom)) {
            walk(dom, function(el) {
              if (el._tag && !el._tag.isMounted) el._tag.isMounted = !!el._tag.trigger('mount')
            })
          }
        }
      // remove from DOM
      } else {
        stub = expr.stub = stub || document.createTextNode('')
        // if the parentNode is defined we can easily replace the tag
        if (dom.parentNode)
          remove()
        else
        // otherwise we need to wait the updated event
          (tag.parent || tag).one('updated', remove)

        dom.inStub = true
      }
    // show / hide
    } else if (/^(show|hide)$/.test(attrName)) {
      if (attrName == 'hide') value = !value
      dom.style.display = value ? '' : 'none'

    // field value
    } else if (attrName == 'value') {
      dom.value = value

    // <img src="{ expr }">
    } else if (startsWith(attrName, RIOT_PREFIX) && attrName != RIOT_TAG) {
      if (value)
        dom.setAttribute(attrName.slice(RIOT_PREFIX.length), value)

    } else {
      if (expr.bool) {
        dom[attrName] = value
        if (!value) return
      }

      if (typeof value !== T_OBJECT) dom.setAttribute(attrName, value)

    }

  })

}
function each(els, fn) {
  for (var i = 0, len = (els || []).length, el; i < len; i++) {
    el = els[i]
    // return false -> remove current item during loop
    if (el != null && fn(el, i) === false) i--
  }
  return els
}

function isFunction(v) {
  return typeof v === T_FUNCTION || false   // avoid IE problems
}

function remAttr(dom, name) {
  dom.removeAttribute(name)
}

function getTag(dom) {
  return dom.tagName && tagImpl[dom.getAttribute(RIOT_TAG) || dom.tagName.toLowerCase()]
}

function initChildTag(child, dom, parent) {
  var tag = new Tag(child, { root: dom, parent: parent }, dom.innerHTML),
      tagName = getTagName(dom),
      ptag = getImmediateCustomParentTag(parent),
      cachedTag

  // fix for the parent attribute in the looped elements
  tag.parent = ptag

  cachedTag = ptag.tags[tagName]

  // if there are multiple children tags having the same name
  if (cachedTag) {
    // if the parent tags property is not yet an array
    // create it adding the first cached tag
    if (!isArray(cachedTag))
      ptag.tags[tagName] = [cachedTag]
    // add the new nested tag to the array
    if (!~ptag.tags[tagName].indexOf(tag))
      ptag.tags[tagName].push(tag)
  } else {
    ptag.tags[tagName] = tag
  }

  // empty the child node once we got its template
  // to avoid that its children get compiled multiple times
  dom.innerHTML = ''

  return tag
}

function getImmediateCustomParentTag(tag) {
  var ptag = tag
  while (!getTag(ptag.root)) {
    if (!ptag.parent) break
    ptag = ptag.parent
  }
  return ptag
}

function getTagName(dom) {
  var child = getTag(dom),
    namedTag = dom.getAttribute('name'),
    tagName = namedTag && namedTag.indexOf(brackets(0)) < 0 ? namedTag : child ? child.name : dom.tagName.toLowerCase()

  return tagName
}

function extend(src) {
  var obj, args = arguments
  for (var i = 1; i < args.length; ++i) {
    if ((obj = args[i])) {
      for (var key in obj) {      // eslint-disable-line guard-for-in
        src[key] = obj[key]
      }
    }
  }
  return src
}

// with this function we avoid that the current Tag methods get overridden
function cleanUpData(data) {
  if (!(data instanceof Tag) && !(data && typeof data.trigger == T_FUNCTION)) return data

  var o = {}
  for (var key in data) {
    if (!~RESERVED_WORDS_BLACKLIST.indexOf(key))
      o[key] = data[key]
  }
  return o
}

function walk(dom, fn) {
  if (dom) {
    if (fn(dom) === false) return
    else {
      dom = dom.firstChild

      while (dom) {
        walk(dom, fn)
        dom = dom.nextSibling
      }
    }
  }
}

// minimize risk: only zero or one _space_ between attr & value
function walkAttributes(html, fn) {
  var m,
      re = /([-\w]+) ?= ?(?:"([^"]*)|'([^']*)|({[^}]*}))/g

  while ((m = re.exec(html))) {
    fn(m[1].toLowerCase(), m[2] || m[3] || m[4])
  }
}

function isInStub(dom) {
  while (dom) {
    if (dom.inStub) return true
    dom = dom.parentNode
  }
  return false
}

function mkEl(name) {
  return document.createElement(name)
}

function replaceYield(tmpl, innerHTML) {
  return tmpl.replace(/<(yield)\/?>(<\/\1>)?/gi, innerHTML || '')
}

function $$(selector, ctx) {
  return (ctx || document).querySelectorAll(selector)
}

function $(selector, ctx) {
  return (ctx || document).querySelector(selector)
}

function inherit(parent) {
  function Child() {}
  Child.prototype = parent
  return new Child()
}

function setNamed(dom, parent, keys) {
  if (dom._visited) return
  var p,
      v = dom.getAttribute('id') || dom.getAttribute('name')

  if (v) {
    if (keys.indexOf(v) < 0) {
      p = parent[v]
      if (!p)
        parent[v] = dom
      else if (isArray(p))
        p.push(dom)
      else
        parent[v] = [p, dom]
    }
    dom._visited = true
  }
}

// faster String startsWith alternative
function startsWith(src, str) {
  return src.slice(0, str.length) === str
}

/*
 Virtual dom is an array of custom tags on the document.
 Updates and unmounts propagate downwards from parent to children.
*/

var virtualDom = [],
    tagImpl = {},
    styleNode

function injectStyle(css) {

  if (riot.render) return // skip injection on the server

  if (!styleNode) {
    styleNode = mkEl('style')
    styleNode.setAttribute('type', 'text/css')
  }

  var head = document.head || document.getElementsByTagName('head')[0]

  if (styleNode.styleSheet)
    styleNode.styleSheet.cssText += css
  else
    styleNode.innerHTML += css

  if (!styleNode._rendered)
    if (styleNode.styleSheet) {
      document.body.appendChild(styleNode)
    } else {
      var rs = $('style[type=riot]')
      if (rs) {
        rs.parentNode.insertBefore(styleNode, rs)
        rs.parentNode.removeChild(rs)
      } else head.appendChild(styleNode)

    }

  styleNode._rendered = true

}

function mountTo(root, tagName, opts) {
  var tag = tagImpl[tagName],
      // cache the inner HTML to fix #855
      innerHTML = root._innerHTML = root._innerHTML || root.innerHTML

  // clear the inner html
  root.innerHTML = ''

  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)

  if (tag && tag.mount) {
    tag.mount()
    virtualDom.push(tag)
    return tag.on('unmount', function() {
      virtualDom.splice(virtualDom.indexOf(tag), 1)
    })
  }

}

riot.tag = function(name, html, css, attrs, fn) {
  if (isFunction(attrs)) {
    fn = attrs
    if (/^[\w\-]+\s?=/.test(css)) {
      attrs = css
      css = ''
    } else attrs = ''
  }
  if (css) {
    if (isFunction(css)) fn = css
    else injectStyle(css)
  }
  tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }
  return name
}

riot.mount = function(selector, tagName, opts) {

  var els,
      allTags,
      tags = []

  // helper functions

  function addRiotTags(arr) {
    var list = ''
    each(arr, function (e) {
      list += ', *[' + RIOT_TAG + '="' + e.trim() + '"]'
    })
    return list
  }

  function selectAllTags() {
    var keys = Object.keys(tagImpl)
    return keys + addRiotTags(keys)
  }

  function pushTags(root) {
    var last
    if (root.tagName) {
      if (tagName && (!(last = root.getAttribute(RIOT_TAG)) || last != tagName))
        root.setAttribute(RIOT_TAG, tagName)

      var tag = mountTo(root,
        tagName || root.getAttribute(RIOT_TAG) || root.tagName.toLowerCase(), opts)

      if (tag) tags.push(tag)
    }
    else if (root.length) {
      each(root, pushTags)   // assume nodeList
    }
  }

  // ----- mount code -----

  if (typeof tagName === T_OBJECT) {
    opts = tagName
    tagName = 0
  }

  // crawl the DOM to find the tag
  if (typeof selector === T_STRING) {
    if (selector === '*')
      // select all the tags registered
      // and also the tags found with the riot-tag attribute set
      selector = allTags = selectAllTags()
    else
      // or just the ones named like the selector
      selector += addRiotTags(selector.split(','))

    els = $$(selector)
  }
  else
    // probably you have passed already a tag or a NodeList
    els = selector

  // select all the registered and mount them inside their root elements
  if (tagName === '*') {
    // get all custom tags
    tagName = allTags || selectAllTags()
    // if the root els it's just a single tag
    if (els.tagName)
      els = $$(tagName, els)
    else {
      // select all the children for all the different root elements
      var nodeList = []
      each(els, function (_el) {
        nodeList.push($$(tagName, _el))
      })
      els = nodeList
    }
    // get rid of the tagName
    tagName = 0
  }

  if (els.tagName)
    pushTags(els)
  else
    each(els, pushTags)

  return tags
}

// update everything
riot.update = function() {
  return each(virtualDom, function(tag) {
    tag.update()
  })
}

// @deprecated
riot.mountTo = riot.mount

  // share methods for other riot parts, e.g. compiler
  riot.util = { brackets: brackets, tmpl: tmpl }

  // support CommonJS, AMD & browser
  /* istanbul ignore next */
  if (typeof exports === T_OBJECT)
    module.exports = riot
  else if (typeof define === 'function' && define.amd)
    define(function() { return (window.riot = riot) })
  else
    window.riot = riot

})(typeof window != 'undefined' ? window : void 0);

var RiotControl = {
  _stores: [],
  addStore: function(store) {
    this._stores.push(store);
  }
};

['on','one','off','trigger'].forEach(function(api){
  RiotControl[api] = function() {
    var args = [].slice.call(arguments);
    this._stores.forEach(function(el){
      el[api].apply(null, args);
    });
  };
});

if (typeof(module) !== 'undefined') module.exports = RiotControl;

com.TI.util.nsExtend(window, "com.TI.rst");

com.TI.rst.MetricsMixin = function () {
	var self = this;
	//properties and init vars
	var _famId;
	var _time = [],
		_loadTime,
		_renderTime;
	//url to be used to send stuff to metrics server
	var _trackingServer = "http://recorder.ti.com/tim/cap.tsp?",
		_trackingUrl = window.location.href,
		hashChar = _trackingUrl.indexOf('#');
	if (hashChar > -1) _trackingUrl = _trackingUrl.substr(0, hashChar);

	var processFilter = function (filter) {
		var qArray = [];
		var tempStr = '';
		for (var cid in filter) {
			if (filter.hasOwnProperty(cid)) {
				tempStr = cid + "=";
				var items = filter[cid].values;
				for (var i = 0; i < items.length; i++) {
					if (i > 0) tempStr += ';'
					tempStr += items[i];
				}
				qArray.push(tempStr);
			}
		}
		return qArray.join('&');
	};
	//private methods
	function setLoadTime() {
		_loadTime = _time[1] - _time[0];
	}

	function setRenderTime() {
		_renderTime = _time[2] - _time[1];
		initialTracking();
	}

	function loadobj(fileloc) {
		var fileref,
			rID;
		fileref = document.createElement("script");
		fileref.setAttribute("type", "text/javascript");
		fileref.setAttribute("id", "timcap");
		fileloc += "&rst=beta";
		fileloc = _trackingServer + fileloc.replace(/\#/g, "???") + "&rnd=" + Math.random();
		fileref.setAttribute("src", fileloc);
		if (fileref !== "") {
			document.getElementsByTagName("head").item(0).appendChild(fileref);
			rID = document.getElementById("timcap");
			rID.parentNode.removeChild(rID);
		}
	}

	function initialTracking() {
		var trackingVar = _trackingUrl + "#familyId=" + _famId + "&loadTime=" + _loadTime + "&renderTime=" + _renderTime + "&action=loadMetrics" + "&rst";
		loadobj(trackingVar);
	}
	//functions accessible through mixin
	self.setFam = function (famId) {
		if (famId !== undefined) _famId = famId;
	};
	self.pushTime = function (newTime) {
		_time.push(newTime);
		if (_time.length === 2) setLoadTime();
		if (_time.length === 3) setRenderTime();
	};
	self.trackBtn = function (btnType) {
		//button types: download, email, sort, compare, loadMore
		var trackingVar = _trackingUrl + "#familyId=" + _famId + "&action=buttonClick&buttonName=" + btnType;
		loadobj(trackingVar);
	};
	self.trackShowHideCol = function (colOrder) {
		//in old selection tool we track what is being used with the col order
		var trackingVar = _trackingUrl + "#familyId=" + _famId + "&columnOrderString=" + colOrder + "&action=addhideApply";
		loadobj(trackingVar);
	};
	self.trackFilter = function (q, count) {
		var filterString = processFilter(q);
		if (filterString !== "") {
			var trackingVar = _trackingUrl + "#" + filterString + "&action=filter&familyId=" + _famId + "&matchCount=" + count;
			loadobj(trackingVar);
		}
	};
	self.trackBoolChange = function (obj) {
		var trackingVar = _trackingUrl + "#familyId=" + _famId + "&boolType=" + obj.type.toLowerCase() + "&cid=" + obj.cid;
		loadobj(trackingVar);
	};
	self.trackSort = function (cid) {
		var trackingVar = _trackingUrl + "#familyId=" + _famId + "&action=sort&cid=" + cid;
		loadobj(trackingVar);
	};
	self.trackLoadMore = function () {
		var trackingVar = _trackingUrl + "#familyId=" + _famId + "&action=loadMore&familyId=";
		loadobj(trackingVar);
	};
	self.trackFilterToggle = function (obj) {
		//track toggles in side filter
		var trackingVar = _trackingUrl + "#familyId=" + _famId + "&action=" + obj.action + "&cid=" + obj.cid;
		loadobj(trackingVar);
	};
	self.trackPartFilter = function (obj) {
		//track filter by part number
		var trackingVar = _trackingUrl + "#familyId=" + _famId + "&action=" + obj.action + "&term=" + obj.term;
		loadobj(trackingVar);
	};
	// tracks 'Apply', 'Reset', quick search, quick links
	self.trackApply = function (action, count, q) {
		var linkId = '';
		var searchType = '';
		var filterString = processFilter(q);
		var trackingVar = _trackingUrl + "#" + (filterString === "" ? "" : filterString + "&") + "action=" + action + "&familyId=" + _famId + "&matchCount=" + count;
		loadobj(trackingVar);
		switch (action) {
			case 'apply':
				searchType = 'main';
				linkId = 'st_main_apply';
				break;
			case 'autoQuickSearch':
				searchType = 'aqs';
				linkId = 'st_aqs_apply';
				break;
			case 'quickLink':
				searchType = 'ocs';
				linkId = 'st_ocs_link';
				break;
			case 'quickSearch':
				searchType = 'cqs';
				linkId = 'st_cqs_apply';
				break;
			case 'reset':
				searchType = 'main';
				linkId = 'st_main_reset';
				break;
		}
		if (searchType !== '') {
			var params = {};
			if (action === 'reset') {
				params = {
					clickType: 'reset',
					errorMsg: 'GA _tiAT reset track error',
					familyId: _famId,
					linkId: linkId,
					trackType: "selection tool link click"
				};
			} else {
				params = {
					errorMsg: 'GA _tiAT filter track error',
					familyId: _famId,
					linkId: linkId,
					searchType: searchType,
					trackType: "selection tool search"
				};
			}
			self.tiATrack(params);
		}
	};
	self.tiATrack = function (params) {
		var defaultParams = {
			errorMsg: 'GA _tiAT track error',
			familyId: _famId,
			linkId: 'n/a',
			searchType: 'main',
			trackType: "selection tool search"
		};
		params = (typeof (params) !== 'undefined' ? params : defaultParams);
		if (params) {
			try {
				if (params.trackType === 'selection tool link click') {
					_tiAnalyticsTrack(params.trackType, params.clickType, params.linkId);
				} else {
					_tiAnalyticsTrack(params.trackType, params.familyId, params.searchType, params.linkId);
				}
			} catch (e) {
				//console.log(params.errorMsg);
			}
		}
	};
	self.trackOpenDrawer = function (obj) {
		//track only on expand?
		var trackingVar = _trackingUrl + "#familyId=" + _famId + "&partNumber=" + obj.partNumber + "&action=openDrawer";
		loadobj(trackingVar);
		//trackGoogle(obj);
	};
	self.trackDrawerLinks = function (obj) {
		//partNumber, linkType
		var trackingVar = _trackingUrl + "#familyId=" + _famId + "&partNumber=" + obj.partNumber + "&linkType=" + obj.linkType + "&action=drawerLink";
		loadobj(trackingVar);
		//trackGoogle(obj);

		//cookie stuff for hirel
		if (obj.linkType !== "diag") {
			sessionStorage.setItem("BCrumb", _famId + "-" + obj.partNumber);
		}
	};
};

com.TI.util.nsExtend(window,"com.TI.rst.storeDef");

com.TI.rst.storeDef.FilterStore = function(){
	var self = this;
	riot.observable(self);
	var utils = com.TI.util;
	var _colData = [],
		_colDataLen,
		_metrics,
		_colOrder = [];
	var filterPrefix = "ti_filters_",
		quickFilterPrefix = "ti_quick_search_";

	function createOptions(cid, props){
		var tmpVals, sliderType = "";
		tmpVals = (props.values !== undefined ? props.values : ["yes"]);
		if (props.top && props.bottom) sliderType = 'dual';
		else if (props.top) sliderType = 'top';
		else if (props.bottom) sliderType = 'bot';
		return {
			values : tmpVals.slice(), //make sure array is a copy
			sliderType : sliderType
		};
	}

	function getOrder(colIndex) {
		var cid,
			tmpArr = [],
			tmpOrder;
		for (cid in colIndex) {
			if (colIndex[cid].type !== "O" || cid === "o7") {
				tmpArr.push([parseInt(colIndex[cid].order), cid]);
			}
		}
		if (colIndex["o4"] !== undefined && utils.inArray("o4", tmpArr) === -1) tmpArr.push([colIndex["o4"].order, "o4"]);
		tmpOrder = utils.getColArray(tmpArr, 1);
		return tmpOrder;
	}

	function makeObjFromStr(vals){
		var i,
			len = vals.length,
			tmpVal;
		for (i=0; i< len; i++) {
			tmpVal = vals[i];
			vals[i] = {
				l: tmpVal.replace("[pf]","").replace("[/pf]",""),
				v: tmpVal
			};
		}
	}

	function initColOrder(colIndex, cols2Expand, cols2Check, userLevel, initialFilters){
		var cid,
			order = [],
			tmpCol,
			collapsed,
			checked,
			options,
			expandedCols = 0,
			checkedCols = 0,
			i,
			len,
			tmpVals,
			tmpApplied,
			tmpBool,
			isBeingUsed;
		cols2Check--; //minus o1
		_colOrder = getOrder(colIndex);
		len = _colOrder.length;
		for (i=0; i<len; i++) {
			cid = _colOrder[i];
			isBeingUsed = false;
			if (colIndex[cid].type !== "O" || cid === "o4" || cid === "o7") {
				options = createOptions(cid, indexCols[cid]["properties"]);
				//deal with user level to know what filters will be expanded and which ones will be collapsed
				if (expandedCols < cols2Expand) {
					collapsed = false;
					expandedCols++;
				} else {
					collapsed = true;
				}
				//similar to the above but this is for the shown/hidden column icon
				if (checkedCols < cols2Check) {
					checked = true;
					checkedCols++;
				} else {
					checked = false;
				}
				tmpVals = options.values.slice();
				if (typeof tmpVals[0] !== "object") makeObjFromStr(tmpVals);

				tmpApplied = [];
				tmpBool = indexCols[cid]["searchBooleanType"];

				if (!utils.isEmpty(initialFilters[cid])) {
					tmpApplied = initialFilters[cid].values;
					tmpBool = initialFilters[cid].type;
					isBeingUsed = true;
				}
				tmpCol = new Object();
				tmpCol = {
					cid : cid,
					collapsed : (isBeingUsed) ? false : collapsed,
					//checked : (isBeingUsed) ? true : checked,
					checked : checked,
					label : indexCols[cid]["name"],
					attr : (indexCols[cid].attribute !== undefined) ? " (" + indexCols[cid].attribute + ") " : "",
					unit: (indexCols[cid]["units"] !== undefined) ? " (" + indexCols[cid]["units"] + ")" : "",
					type : indexCols[cid]["controlType"],
					units: (indexCols[cid]["units"] === undefined) ? "" : indexCols[cid]["units"],
					defType : indexCols[cid]["searchBooleanType"],
					searchType : tmpBool,
					sliderType : options.sliderType,
					options : options.values.slice(),
					vals : tmpVals,
					applied : tmpApplied,
					appliedBool : tmpBool,
					prefilter : tmpApplied.slice(),
					isDirty : false,
					fromQuickLink : false
				};
				order.push(tmpCol);
			}
		}
		return order;
	}

	function createPartQuery(part){
		var q = {};
		if (part.prefilter.length > 0) {
			q = {
				type : (part.searchType === "OFF") ? "OR" : part.searchType,
				values : part.prefilter
			};
		}
		return q;
	}

	function clearDirty() {
		var i;
		for (i=0; i<_colDataLen; i++) {
			//_colData[i].prefilter = []; //--tk commented out
			_colData[i].isDirty = false;
		}
	}

	function colDataToQuery() {
		var i,
			colInfo,
			partQ,
			q = {};
		for (i=0; i<_colDataLen; i++) {
			colInfo = _colData[i];
			partQ = createPartQuery(colInfo);
			if (!utils.isEmpty(partQ)) {
				q[colInfo.cid] = partQ;
			};
		}
		return q;
	}

	self.on("rst_init", function(params){
		//console.log("rst init filter store");
		indexCols = params.colDef;
		indexRows = params.partDef;
		_colData = initColOrder(indexCols, params.expandedFilters, params.initialNumber, params.userLevel, params.initialFilters);
		_colDataLen = _colData.length;
		self.trigger(filterPrefix + "init", _colData);
		self.trigger("qs_init2", _colData);
	});

	self.on("rst_filter_checkbox_change", function(cid, checked) {
		var item = _colData.filter(function(col){
				return col.cid === cid;
			}),
			action = (checked) ? "add" : "del",
			newQ;
		item[0].checked = checked;
		//if unchecked
		//remove items from filter
		if (!checked) {
			item[0].applied = [];
			item[0].prefilter = []; //--tk added
			clearDirty();
			newQ = colDataToQuery();
			self.trigger(filterPrefix + "sync_ui", _colData);
			self.trigger(filterPrefix + "set_dirty", false);
			RiotControl.trigger("rst_filter", newQ);
		}
		newQ = colDataToQuery();
		RiotControl.trigger("rst_column_change", cid, action, newQ);
	});

	self.on("rst_download", function(){
		RiotControl.trigger("rst_download_parts", _colData);
	});

	self.on("rst_filter_change", function(cid, val, type, checked){
		var i,
			colInfo,
			query = {},
			inPrefilter, //to see what is in se in prefilter, including previously applied items
			isReset = (cid === undefined),
			bigDirty = false,
			tmpVals,
			tmpLast,
			tmpMin,
			tmpMax;
		//clear quickfilter
		self.trigger(quickFilterPrefix + "reset");
		//create new filter query
		//loop through the whole filter
		for (i=0; i<_colDataLen; i++) {
			colInfo = _colData[i];
			//when we run accross the filter we touched
			//update the model
			//otherwise, continue generating the query
			if (!isReset && colInfo.cid === cid) {
				colInfo.searchType = type;
				if (type === "RANGE" || type === "OPTEMPRANGE")  {
					tmpVals = colInfo.vals;
					tmpLast = tmpVals.length -1;
					tmpMin = parseFloat(tmpVals[0].v);
					tmpMax = parseFloat(tmpVals[tmpLast].v);
					if (val.length > 0 && (tmpMin < val[0] || tmpMax > val[1])) {
						colInfo.prefilter = val;
					} else {
						colInfo.prefilter = [];
					}
				} else {
					if (val) {
						inPrefilter = utils.inArray(val, colInfo.prefilter);
						if (inPrefilter === -1 && checked) {
							colInfo.prefilter.push(val);
							colInfo.prefilter.sort();
						}
						else if (inPrefilter > -1 && !checked) colInfo.prefilter.splice(inPrefilter, 1);
					}
				}
			} else if (isReset) {
				colInfo.applied = [];
				colInfo.prefilter = [];
				colInfo.searchType = colInfo.defType
				colInfo.appliedBool = colInfo.searchType;
			}
			if (type === "RANGE" || type === "OPTEMPRANGE") colInfo.isDirty = (colInfo.prefilter.toString() !== colInfo.applied.toString());
			else colInfo.isDirty = (colInfo.prefilter.toString() !== colInfo.applied.toString() || colInfo.appliedBool !== colInfo.searchType);
			bigDirty = bigDirty || colInfo.isDirty;
			query = colDataToQuery();
		}
		if (isReset) self.trigger(filterPrefix + "sync_ui", _colData);
		else self.trigger(filterPrefix + "sync_checks", _colData);
		self.trigger(filterPrefix + "set_dirty", bigDirty);
		RiotControl.trigger("rst_filter", query);
	});

	self.on("rst_col_filter_change", function(colsInUse){
		var i,
			colInfo;

		for (i=0; i<_colDataLen; i++) {
			colInfo = _colData[i];
			colInfo.applied = colInfo.prefilter.slice();
			colInfo.appliedBool = colInfo.searchType;
			colInfo.fromQuickLink = false;
			colInfo.isDirty = false;
			if (utils.inArray(colInfo.cid, colsInUse) > -1) colInfo.checked = true;
		}
		self.trigger(filterPrefix + "set_dirty", false);
		self.trigger(filterPrefix + "update_prefilter_count");
		self.trigger(filterPrefix + "sync_ui", _colData);
		self.trigger(filterPrefix + "go_to_table");
	});

	self.on("rst_qs_col_update", function(cols, q) {
		var i, colInfo, qPart;
		for (i=0; i<_colDataLen; i++) {
			colInfo = _colData[i];
			colInfo.isDirty = false;
			if (q[colInfo.cid] === undefined) {
				colInfo.collapsed = true;
				colInfo.applied = [];
				colInfo.prefilter = [];
				colInfo.appliedBool = colInfo.searchType;
			} else {
				qPart = q[colInfo.cid];
				colInfo.checked = true;
				colInfo.collapsed = false;
				colInfo.applied = qPart.values.slice();
				colInfo.prefilter = colInfo.applied.slice();
				colInfo.searchType = qPart.type;
				colInfo.appliedBool = colInfo.searchType;
				colInfo.fromQuickLink = true;
			}
		}
	});

	self.on("rst_filter_expand_all", function(){
		for (var i=0; i<_colDataLen; i++) {
			_colData[i].collapsed = false;
		}
		self.trigger(filterPrefix + "sync_ui", _colData);
	});

	self.on("rst_filter_collapse_all", function(){
		for (var i=0; i<_colDataLen; i++) {
			_colData[i].collapsed = true;
		}
		self.trigger(filterPrefix + "sync_ui", _colData);
	});

	self.on("rst_filter_check_collapsed", function(){
		self.trigger(filterPrefix + "sync_collapsed");

	});
};
com.TI.util.nsExtend(window,"com.TI.rst.storeDef");

com.TI.rst.storeDef.LanguageStore = function(lang, stringsonly){
	riot.observable(this);

	var cDomain = document.domain,
		cPort = location.port,
		newDomains = {
			"en" : "www.ti.com",
			"cn" : "www.ti.com.cn",
			"jp" : "www.tij.co.jp"
		};
	
	if (cPort !== "") cPort = ":" + cPort;
	
	if (cDomain.indexOf('www-int') > -1) {
		newDomains["en"] = "www-int.itg.ti.com";
		newDomains["cn"] = "www-cn-int.itg.ti.com";
		newDomains["jp"] = "www-jp-int.itg.ti.com";
	} else if (cDomain.indexOf('www-uat') > -1) {
		newDomains["en"] = "www-uat.itg.ti.com";
		newDomains["cn"] = "www-cn-uat.itg.ti.com";
		newDomains["jp"] = "www-jp-uat.itg.ti.com";
	} else if (cDomain.indexOf('www-sat') > -1) {
		newDomains["en"] = "www-sat.itg.ti.com";
		newDomains["cn"] = "www-cn-sat.itg.ti.com";
		newDomains["jp"] = "www-jp-sat.itg.ti.com";
	} else if (cDomain.indexOf('www.ti') === -1) {
		newDomains["en"] = cDomain + cPort;
		newDomains["cn"] = cDomain + cPort;
		newDomains["jp"] = cDomain + cPort;
	}
	
	
	this.language = 'EN';

	this.languages = ['CN', 'DE', 'EN', 'JP', 'KR'];

	this.langStrings = {
		CN: {
			BETA_BACK: "返回原始参数选择工具",
			BETA_TRY: "尝试全新 BETA 参数选择工具",
			BETA_FLAIR: "尝试 TI 有史以来最快速，触摸最便捷的参数选择工具",
			BETA_FEEDBACK: "请提供给我们有关这款全新参数选择工具的反馈建议。",
			CLICKCOLUMN: "点击显示/隐藏列",
			CLICKFULLSIZE: "点击显示完整信息",
			COMPARE: "比较",
			COMPAREPARTS: "比较",
			DESCRIPTIONPARAMETRICS: "描述与参数",
			DOWNLOADDATASHEET: "产品详情",
			DOWNLOADTOEXCEL: "下载到电子表格中",
			EMAIL: "邮件",
			FEEDBACK: "信息反馈",
			FILTERBYPART: "根据器件型号筛选",
			FUNCTIONALDIAGRAM: "功能图",
			HIDEFILTERS: "隐藏过滤器",
			XITEMSSELECTED: "已选中 !!X!! 项",
			ONLINEDATASHEET: "在线数据表",
			SEEDATASHEET: "产品详情 ",
			PARAMETERS: "参数",
			XPARTSFOUND: "未找到对应器件",  // no parts found
			PRINT: "打印",
			PRINTTHISTABLE: "打印此表",
			PRODUCTDETAILS: "产品详情",
			RESET: "复位",
			SAMPLEBUY: "立即下单",
			SEARCH: "搜索",
			SELECT: "请选择",
			SHOWBLANKS: "显示空白",
			SHOWFILTERS: "显示过滤器",
			SHOWMORE: "显示更多信息",
			QUICKSEARCHSHOW: "显示快速搜索",
			QUICKSEARCHHIDE: "隐藏快速搜索",
			SHOWINGXPARTS: "显示 !!X!! 种器件",
			SHOWINGXOFYPARTS: "总共 !!Y!! 个器件中匹配了 !!X!! 个器件",
			SUPPORTTRAINING: "支持与社区",
			TECHNICALDOCUMENTS: "技术文档",
			TOOLSSOFTWARE: "工具与软件",
			TOOLTITLE: "产品",
			VIEWXPARTS: "查看 !!X!! 种器件",
			VOUTLTVIN: "输出电压必须 < Vin",
			QUALITYPACKAGING: "质量与封装",
			QUICKPARAMETERS: "单击以下参数",
			QUICKPARAMETERS_INSTRUCTIONS: "只需单击一下就可找到指定产品:",
			QUICKPARAMETERS_NOISE: "噪声敏感型应用",
			QUICKPARAMETERS_LOWIQ: "低 IQ",
			QUICKPARAMETERS_WIDEINPUT: "宽输入电压",
			QUICKPARAMETERS_SMALL: "小型封装",
			QUICKPARAMETERS_POWERSUPPLY: "Power Supply",
			QUICKPARAMETERS_SYNC_RECT: "Synchronous rectification",
			QUICKPARAMETERS_SWITCHING_FREQ: "2 MHz switching frequency",
			QUICKPARAMETERS_SINGLE: "Single",
			QUICKPARAMETERS_DUAL: "Dual",
			QUICKPARAMETERS_DESCRIPTION: "查找符合指定要求的器件",
			QUICKPARAMETERS_SMALL_FOOTPRINT: "Small Footprint",
			QUICKPARAMETERS_LOW_OFFSET: "Low Input Offset",
			QUICKPARAMETERS_LOW_GAIN_ERROR: "Low Gain Error",
			QUICKSEARCH: "快速搜索",
			CHANNELCOUNT: "Number of Channels (#)",
			GAIN_BANDWIDTH: "Gain Bandwidth",
			SUPPLY_VOLTAGES: "Supply Voltages",
			SLEW_RATES: "Slew Rates",
			QUIESCENT_CURRENT: "Quiescent Current",
			RAIL_TO_RAIL: "Rail-to-Rail",
			RAIL2RAIL_IN: "In",
			RAIL2RAIL_OUT: "Out",
			RAIL2RAIL_INTO_VPLUS: "In to V+",
			RAIL2RAIL_INTO_VMINUS: "In to V-",
			LOW_NOISE: "低噪声 (≤ 10nV/√Hz)",
			LOW_OFFSET: "低偏移 (≤ 500µV)",
			LOW_POWER: "低功耗 (≤ 500µA",
			WIDE_BANDWIDTH: "宽带宽 (≥ 5MHz)",
			SMALL_FOOTPRINT: "小型封装 (≤ 9mm2)",
			OFFSET_VOLTAGE: "Offset Voltage",
			LOW_INPUT_BIAS: "低输入偏置",
			SELECT_ONE: "None selected",
			POWER_MANAGEMENT_INTRO: "找到合适的电池管理产品快速.",
			BATTERY_CHEMISTRY: "Battery Chemistry",
			INPUT_VOLTAGE: "Input Voltage",
			REG_BATTERY_VOLTAGE: "Regulated Battery Voltage",
			CHARGE_CURRENT: "Charge Current",
			EXPAND_ALL: "全部展开",
			COLLAPSE_ALL: "全部折叠",
			QUICKSEARCH_ARM: "ARM",
			QUICKSEARCH_FRAM: "FRAM",
			QUICKSEARCH_SMALL_PACKAGE: "小型封装 < 5x5 mm2",
			QUICKSEARCH_LARGE_MEMORY_DEVICES: "大型存储器器件",
			QUICKSEARCH_CAPTIVATE_TT: "Captivate™触摸技术",
			QUICKSEARCH_USB: "USB",
			QUICKSEARCH_LCD: "LCD",
			QUICKSEARCH_BEST_ACTIVE_PWR: "最佳工作功耗",
			QUICKSEARCH_BEST_STANDBY_PWR: "最佳待机功耗",
			QUICKPARAMETERS_CAPACITIVE: "电容按钮、滑块和滚轮",
			QUICKPARAMETERS_ACCEL_PROCESSING: "加速处理",
			QUICKPARAMETERS_BGA_PKGS: "芯片 - 尺寸球状引脚栅格阵列 (BGA) 封装",
			QUICKPARAMETERS_ENHANCED_SECURITY: "增强安全功能",
			QUICKPARAMETERS_SYS_STATE_RETENTION: "系统状态保持通过电源故障",
			QUICKPARAMETERS_FEATURED_MCU: "按功能特色微控制器",
			QUICKSEARCH_NUMBER_CORES: "Number of cores",
			QUICKSEARCH_DSP_SPEED: "DSP Speed",
			QUICKSEARCH_TOTAL_CACHE: "Total On-Chip Memory",
			QUICKPARAMETERS_SINGLE_CORE: "单核 DSP",
			QUICKPARAMETERS_HI_PERF_DSP: "高性能 DSP",
			QUICKPARAMETERS_HI_SPEED_INTERFACES: " 高速接口",
			QUICKPARAMETERS_FLOAT_PT_DSP: "浮点 DSP",
			QUICKPARAMETERS_EXT_TEMP_DEVICES: "扩展温度器件",
			QUICKPARAMETERS_HIGH_SUPPLY_VOLTAGE: "High Supply Voltage (> 6V)",
			QUICKPARAMETERS_LOW_SUPPLY_VOLTAGE: "Low Supply Voltage (<= 6V)",
			QUICKPARAMETERS_AUTO_QUALIFIED: "通过汽车认证 (AEC-Q100)",
			QUICKPARAMETERS_LOW_OFFSET_VOLTAGE: "Low Offset Voltage (<=500µV)",
			QUICKPARAMETERS_LOW_QUIE_CURRENT: "Low Quiescent Current (<=500µA)",
			QUICKPARAMETERS_LOW_NOISE_DENSITY: "Low Noise Density (≤ 10nV/√Hz)",
			INTRO_TEXT: "TI has updated its parametric selection tool to work on both desktops and tablets",
			INTRO_LINK: "Find out what's new",
			QUICKPARAMETERS_HIREL_DESCRIPTION: "Find high reliability parts specific to your industry",
			QUICKPARAMETERS_SPACE: "Space",
			QUICKPARAMETERS_ENHANCED_PRODUCTS: "Enhanced Products",
			QUICKPARAMETERS_HIGH_TEMPERATURE: "Hermetic / High Temperature",
			QUICKPARAMETERS_PRODUCT_CAT: "Product Category",
			QUICKPARAMETERS_PRODUCT_SUBCAT: "product Sub-Category",
			QUICKPARAMETERS_AUTOMOTIVE: "汽车",
			QUICKPARAMETERS_CATALOG: "目录",
			QUICKPARAMETERS_COSTOPTIMIZED: "成本优化",
			QUICKPARAMETERS_HIGHACCURACY: "高精度",
			QUICKPARAMETERS_LOWPOWER: "低功率",
			QUICKPARAMETERS_NONBGA: "非 BGA",
			QUICKPARAMETERS_PACKAGETYPE: "封装类型?",
			QUICKPARAMETERS_SMALLPACKAGE: "小型封装",
			QUICKPARAMETERS_RATING: "评分",
			QUICKPARAMETERS_KEYDESIGNNEED: "您的主要设计需求是什么？",
			QUICKPARAMETERS_QP1: "执行",
    		QUICKPARAMETERS_QP2: "交叉参考搜索",
    		QUICKPARAMETERS_QP3: "来替换非 TI 温度传感器",
			WEBENCH_INPUT: "Select either Nominal or Min/Max Vin.",
			WEBENCH_OUTPUT: "Output",
			WEBENCH_OUTPUT1: "Specify Output #1",
			WEBENCH_OUTPUT2: "Specify Output #2",
			WEBENCH_ONE_OUT: "One output",
			WEBENCH_TWO_OUT: "Two outputs",
			WEBENCH_V_OUT: "Vout",
			WEBENCH_I_OUT: "Iout",
			WEBENCH_OUTPUT_ERR: "Error: you have selected two outputs, but have only completed one.",
			WEBENCH_WHAT: "What are WEBENCH® recommended parts?",
			WEBENCH_V_NOMINAL: "Vin Nominal",
			WEBENCH_V_MIN: "Vin Min",
			WEBENCH_VIN: "Vin",
			WEBENCH_V_MAX: "Vin Max",
    		QUICKPARAMETERS_OPTIMIZED_CABLES_PROBES: "针对线缆/探头进行了优化",
    		QUICKPARAMETERS_V18_CAPABLE: "支持 1.8V 电压",
    		QUICKPARAMETERS_INTEGRATED_POWER_MONITORING: "集成式功耗监测",
    		QUICKPARAMETERS_FACTORY_PRESET: "出厂预设",
    		QUICKPARAMETERS_PIN_CONFIGURABLE: "可配置引脚",
    		QUICKPARAMETERS_RESISTOR_PROGRAMMABLE: "电阻器可编程",
    		QUICKPARAMETERS_DUAL_TRIP_POINTS: "双跳闸点",
    		QUICKPARAMETERS_THRUHOLE: "通孔",
    		QUICKPARAMETERS_SMALL_NONBGA: "小型非 BGA",
    		QUICKPARAMETERS_P2P: "点对点（长达 2 米)",
    		QUICKPARAMETERS_DAISY_CHAIN: "菊链（长达 300 米）",
    		QUICKPARAMETERS_LOOK_FOR: "您在寻找什么？",
    		QUICKPARAMETERS_INTERFACE_TYPE: "接口类型是什么？",
    		QUICKPARAMETERS_PACKAGE_TYPE: "您选择了哪种封装组？",
    		QUICKPARAMETERS_TOPOLOGY: "拓扑",
    		QUICKPARAMETERS_CROSS_REF: "http://" + newDomains["cn"] + "/zh-cn/sensing-products/temperature-sensors/cross-reference.html",
    		QUICKPARAMETERS_ALERT_MSG: "回答有关您的设计要求的几个问题，并查找最适合的温度传感器。",
			QUICKPARAMETERS_OPTIMIZED_CABLES_PROBES: "针对电缆/探头进行了优化",
    		QUICKPARAMETERS_LOW_TEMP_SENSOR_SINGLE_CHANNEL: "本地温度传感器（单通道）",
    		QUICKPARAMETERS_SWITCHES_THERMOSTATS: "开关/恒温器",
    		QUICKPARAMETERS_REMOTE_TEMP_SENSOR_MULTI_CHANNEL: "远程温度传感器（多通道）",
    		QUICKPARAMETERS_CABLES_PROBES: "电缆/探头",
    		QUICKPARAMETERS_HIGH_CHANNEL_COUNT: "高通道数",
    		QUICKPARAMETERS_PACKAGE: "封裝",
    		QUICKPARAMETERS_SELECT: "- 请选择 -",
			//LDO CQS
			//DEVICE_GRADE: "Device Grade",
			LDO_CQS_ALL_GRADES: "所有級別",
			LDO_CQS_ALL_OUTPUT_TYPE: "所有輸出類型",
			LDO_CQS_ALL_SMALL_PACKAGE: "小型封裝",
			LDO_CQS_AJUSTABLE_OUTPUT: "可調整輸出",
			LDO_CQS_AUTOMOTIVE_GRADE: "汽車 (AEC-Q100) 級別",
			LDO_CQS_ENHANCED_PERFORMACE_GRADE: "Enhanced Performance Grade",
			LDO_CQS_FIXED_OUTPUT: "固定輸出",
			LDO_CQS_IOUT_LABEL_1: "Iout value is OK.",
			LDO_CQS_IOUT_LABEL_2: "Iout must be > 0.0001 A and < 50 A",
			LDO_CQS_IOUT_LABEL_3: "An LDO can only source current. Try using a positive IOUT value.",
			LDO_CQS_IOUT_LABEL_4: "Iout 必須大於 0",
			LDO_CQS_INPUT: "輸入",
			LDO_CQS_PROGRAM_OUTPUT: "可編程輸出",
			LDO_CQS_SEARCH_LABEL_1: "請輸入 Vin、Vout 和 Iout.數值。",
			LDO_CQS_SEARCH_LABEL_2: "未找到任何與搜尋條件相符的產品。請嘗試變更參數值、主要功能和裝置級別濾波器 ABEL_2：",
			LDO_CQS_SEARCH_LABEL_3: "LDO 需要適當的 VIN – VOUT 空餘空間進行調節。嘗試改變輸入電壓。",
			LDO_CQS_SEARCH_LABEL_4: "找不到與輸入相符的 LDO。嘗試變更 IoutMax、Vin 或 Vout。",
			LDO_CQS_VOUT_LABEL_1: "Vin 出現 not a number",
			LDO_CQS_VOUT_LABEL_2: "Vout 出現 not a number",
			LDO_CQS_VOUT_LABEL_3: "LDO 無法設定輸入電壓。嘗試改變輸入或輸出電壓。",
			LDO_CQS_VOUT_LABEL_4: "好的，搜尋正 LDO...",
			LDO_CQS_VOUT_LABEL_5: "好的，搜尋負 LDO...",
			LDO_CQS_VOUT_LABEL_6: "Vout 必須小於 Vin",
			LDO_CQS_VOUT_LABEL_7: "LDO 無法轉換輸入電壓。嘗試比對輸入或輸出電壓的極性。",
			LDO_CQS_VOUT_LABEL_8: "選擇一或兩個功能，縮小輸入範圍",
			LDO_CQS_VOUT_LABEL_9: "對雜訊敏感的應用",
			LDO_CQS_VOUT_LABEL_10: "Vout 必須小於 Vin",
			LDO_CQS_VOUT_LABEL_11: "請輸入 Vin、Vout 和 Iout.數值。",
			LDO_CQS_VOUT_LABEL_12: "Iout 必須大於 0 才可選擇 LDO。",
			LDO_CQS_WIDEINPUT: "大範圍輸入電壓",
			QUICKPARAMETERS_TITLE: "主要特色",

			//Strings for Clock Oscillator CQS
			CO_CQS_OSCILLATOR_TYPE: "振荡器类型",
			CO_CQS_STABILITY:	"稳定性",
			CO_CQS_VIEW:	"查看",
			CO_CQS_PARTS:	"元件",
			CO_CQS_PIN_SELECTABLE:	"引脚可选",
			CO_CQS_PROGRAMMABLE:	"可使用 EEPROM 编程",
			CO_CQS_OUTPUT_FORMAT:	"输出格式",
			CO_CQS_HCSL:	"HCSL",
			CO_CQS_LVCMOS:	"LVCMOS",
			CO_CQS_LVDS:	"LVDS",
			CO_CQS_LVPECL:	"LVPECL",
			CO_CQS_STANDARD:	"标准",
			CO_CQS_FREQUENCY:	"频率",
			CO_CQS_PACKAGE:	"封装",
			CO_CQS_CUSTOM:	"定制",
			CO_CQS_REQUEST_SAMPLES:	"申请定制样片",
			CO_CQS_FORM_REQUEST_CO:	"申请定制振荡器",
			CO_CQS_FORM_ORDER_CUSTOM_FREQ:	"订购一款定制频率振荡器",
			CO_CQS_FORM_ULTRA_LOW_JITTER:	"超低抖动振荡器，可定制频率范围为 10MHz 至 1GHz。适用于任何封装尺寸的项目，1-2 周内即可获得样片！",
			CO_CQS_FORM_WHY_ORDER_CUSTOM_OSC:	"为什么订购定制频率振荡器？",
			CO_CQS_FORM_SIMPLE_SAMPLES:	"通过简单快捷的方式即可获得系统所需的精确频率，且性能不打折扣。简单样片！",
			CO_CQS_FORM_STEPS:	"流程步骤",
			CO_CQS_FORM_STEP1:	"在此处表单中简略地输入您的信息并提交",
			CO_CQS_FORM_STEP2:	"最多可申请 x 个样片",
			CO_CQS_FORM_STEP3:	"向我们的分销合作伙伴定制的小量订单",
			CO_CQS_FORM_STEP4:	"直接向 TI 定制的大量订单",
			CO_CQS_FORM_COMPLETE_FORM:	"请完成下面的表单以便为您寄送样片。",
			CO_CQS_FORM_CUSTOMER_NAME:	"客户名称 ",
			CO_CQS_FORM_COMPANY_NAME:	"公司名称 ",
			CO_CQS_FORM_EMAIL:	"电子邮件地址",
			CO_CQS_FORM_PHONE:	"电话",
			CO_CQS_FORM_REQ_FREQUNECY:	"申请的频率（单位：MHz",
			CO_CQS_FORM_COMMENT:	"注释",
			CO_CQS_FORM_DETAILS:	"详细信息",
			CO_CQS_FORM_CANCEL:	"取消",
			CO_CQS_FORM_SUBMIT:	"提交申请",
			CO_CQS_FORM_FIELD:	"请填写此字段"
		},
		DE: {
			BETA_BACK: "Zurück zum original parametrischen Auswahltool",
			BETA_TRY: "Versuchen Sie unsere neue BETA-Version des parametrischen Auswahltools",
			BETA_FLAIR: "Versuchen Sie unser neues, für Touchscreens geeignetes parametrisches Auswahltool",
			BETA_FEEDBACK: "Bitte teilen Sie uns Ihre Meinung zu unserem neuen parametrischen Auwahltool mit",
			CLICKCOLUMN: "Spalte zeigen/verstecken",
			CLICKFULLSIZE: "Klicken Sie hier für eine Vollansicht. ",
			COMPARE: "Vergleichen",
			COMPAREPARTS: "Bauteile vergleichen",
			DESCRIPTIONPARAMETRICS: "Beschreibung & Parametrics",
			DOWNLOADDATASHEET: "Datenblatt runterladen",
			DOWNLOADTOEXCEL: "In Excel runterladen",
			EMAIL: "E-mail",
			FEEDBACK: "Rückmeldung",
			FILTERBYPART: "Nach Bauteilnummer filtern",
			FUNCTIONALDIAGRAM: "Funktionelles Diagramm",
			HIDEFILTERS: "Ausblenden",
			XITEMSSELECTED: "!!X!! Teile gewählt",
			ONLINEDATASHEET: "Online Datenblatt",
			SEEDATASHEET: "Datenblatt runterladen ",
			PARAMETERS: "Parameter",
			XPARTSFOUND: "!!X!! Bauteile gefunden",
			PRINT: "Drucken",
			PRINTTHISTABLE: "Diese Tabelle drucken",
			PRODUCTDETAILS: "Produktdetails",
			RESET: "Zurücksetzen",
			SAMPLEBUY: "Jetzt bestellen",
			SEARCH: "Suchen",
			SELECT: "Auswählen",
			SHOWFILTERS: "Anzeigen",
			SHOWBLANKS: "Leerstellen anzeigen",
			SHOWMORE: "Mehr zeigen",
			QUICKSEARCHSHOW: "Schnellsuche anzeigen",
			QUICKSEARCHHIDE: "Schnellsuche verbergen",
			SHOWINGXPARTS: "!!X!! Bauteile angezeigt",
			SHOWINGXOFYPARTS: "!!X!! passende von insgesamt !!Y!! Bauteilen",
			SUPPORTTRAINING: "Support \& Schulungen",
			TECHNICALDOCUMENTS: "Technische Dokumente",
			TOOLSSOFTWARE: "Tools \& software",
			TOOLTITLE: "Produkte für",
			VIEWXPARTS: "!!X!! Bauteile ansehen",
			VOUTLTVIN: "Vout muss <Vin sein",
			QUALITYPACKAGING: "Qualität \& Packaging",
			QUICKPARAMETERS: "Ein-Klick-Parameter",
			QUICKPARAMETERS_NOISE: "rausch-empfindliche Anwendungen",
			QUICKPARAMETERS_LOWIQ: "kleine IQ",
			QUICKPARAMETERS_WIDEINPUT: "breite Eingangsspannung",
			QUICKPARAMETERS_SMALL: "kleine Gehäuse",
			QUICKPARAMETERS_INSTRUCTIONS: "Spezifische Bausteine mit einem Klick finden:",
			QUICKPARAMETERS_POWERSUPPLY: "Power Supply",
			QUICKPARAMETERS_SYNC_RECT: "Synchronous rectification",
			QUICKPARAMETERS_SWITCHING_FREQ: "2 MHz switching frequency",
			QUICKPARAMETERS_SINGLE: "Single",
			QUICKPARAMETERS_DUAL: "Dual",
			QUICKPARAMETERS_SMALL_FOOTPRINT: "Small Footprint",
			QUICKPARAMETERS_LOW_OFFSET: "Low Input Offset",
			QUICKPARAMETERS_LOW_GAIN_ERROR: "Low Gain Error",
			QUICKPARAMETERS_DESCRIPTION: "Finden Sie Bauteile, die Ihren spezifischen Anforderungen entsprechen",
			QUICKSEARCH: "Schnellsuche",
			CHANNELCOUNT: "Number of Channels (#)",
			GAIN_BANDWIDTH: "Gain Bandwidth",
			SUPPLY_VOLTAGES: "Supply Voltages",
			SLEW_RATES: "Slew Rates",
			QUIESCENT_CURRENT: "Quiescent Current",
			RAIL_TO_RAIL: "Rail-to-Rail",
			RAIL2RAIL_IN: "In",
			RAIL2RAIL_OUT: "Out",
			RAIL2RAIL_INTO_VPLUS: "In to V+",
			RAIL2RAIL_INTO_VMINUS: "In to V-",
			LOW_NOISE: "Geringes Rauschen (≤ 10nV/√Hz)",
			LOW_OFFSET: "Niedrige Offset (≤ 500µV)",
			LOW_POWER: "Niedriger Stromverbrauch (≤ 500µA)",
			WIDE_BANDWIDTH: "Große Bandbreite (≥ 5MHz)",
			SMALL_FOOTPRINT: "Geringer Platzbedarf (≤ 9mm2)",
			OFFSET_VOLTAGE: "Offset Voltage",
			LOW_INPUT_BIAS: "Geringe Eingangsruhe",
			SELECT_ONE: "None selected",
			POWER_MANAGEMENT_INTRO: "Finden Sie den richtigen Batterie-Management -Produkte fast.",
			BATTERY_CHEMISTRY: "Battery Chemistry",
			INPUT_VOLTAGE: "Input Voltage",
			REG_BATTERY_VOLTAGE: "Regulated Battery Voltage",
			CHARGE_CURRENT: "Charge Current",
			EXPAND_ALL: "Alles erweitern",
			COLLAPSE_ALL: "Alles ausblenden",
			QUICKSEARCH_ARM: "ARM",
			QUICKSEARCH_FRAM: "FRAM",
			QUICKSEARCH_SMALL_PACKAGE: "Kompaktes Gehäuse < 5x5 mm2",
			QUICKSEARCH_LARGE_MEMORY_DEVICES: "Große Speichergeräte",
			QUICKSEARCH_CAPTIVATE_TT: "CapTIvate™ Touch-Technologie",
			QUICKSEARCH_USB: "USB",
			QUICKSEARCH_LCD: "LCD",
			QUICKSEARCH_BEST_ACTIVE_PWR: "Beste Wirkleistung",
			QUICKSEARCH_BEST_STANDBY_PWR: "Am besten im Standby",
			QUICKPARAMETERS_CAPACITIVE: "Kapazitive Tasten, Schieberegler und Räder",
			QUICKPARAMETERS_ACCEL_PROCESSING: "Beschleunigte Bearbeitung",
			QUICKPARAMETERS_BGA_PKGS: "Die- Größe BGA-Gehäuse",
			QUICKPARAMETERS_ENHANCED_SECURITY: "Verbesserte Sicherheitsfunktionen",
			QUICKPARAMETERS_SYS_STATE_RETENTION: "bei Stromausfall den Erhalt des Systemzustands",
			QUICKPARAMETERS_FEATURED_MCU: "Empfohlene Mikrocontroller nach Funktion",
			QUICKSEARCH_NUMBER_CORES: "Number of cores",
			QUICKSEARCH_DSP_SPEED: "DSP Speed",
			QUICKSEARCH_TOTAL_CACHE: "Total On-Chip Memory",
			QUICKPARAMETERS_SINGLE_CORE: "Single-Core –DSP",
			QUICKPARAMETERS_HI_PERF_DSP: "Hochleistungs-DSP",
			QUICKPARAMETERS_HI_SPEED_INTERFACES: "High Speed Schnittstellen",
			QUICKPARAMETERS_FLOAT_PT_DSP: "Fließkomma-DSP",
			QUICKPARAMETERS_EXT_TEMP_DEVICES: "Erweiterter Temperaturbereich",
			QUICKPARAMETERS_HIGH_SUPPLY_VOLTAGE: "High Supply Voltage (> 6V)",
			QUICKPARAMETERS_LOW_SUPPLY_VOLTAGE: "Low Supply Voltage (<= 6V)",
			QUICKPARAMETERS_AUTO_QUALIFIED: "Qualifiziert für Automobile (AEC-Q100)",
			QUICKPARAMETERS_LOW_OFFSET_VOLTAGE: "Low Offset Voltage (<=500µV)",
			QUICKPARAMETERS_LOW_QUIE_CURRENT: "Low Quiescent Current (<=500µA)",
			QUICKPARAMETERS_LOW_NOISE_DENSITY: "Low Noise Density (≤ 10nV/√Hz)",
			INTRO_TEXT: "Parametrisches Suchwerkzeug von TI nach Überarbeitung jetzt auf Desktops und Tablets nutzbar",
			INTRO_LINK: "Finden Sie heraus, was neu ist",
			QUICKPARAMETERS_HIREL_DESCRIPTION: "Find high reliability parts specific to your industry",
			QUICKPARAMETERS_SPACE: "Space",
			QUICKPARAMETERS_ENHANCED_PRODUCTS: "Enhanced Products",
			QUICKPARAMETERS_HIGH_TEMPERATURE: "Hermetic / High Temperature",
			QUICKPARAMETERS_PRODUCT_CAT: "Product Category",
			QUICKPARAMETERS_PRODUCT_SUBCAT: "product Sub-Category",
			QUICKPARAMETERS_AUTOMOTIVE: "Automobilindustrie",
			QUICKPARAMETERS_CATALOG: "Katalog",
			QUICKPARAMETERS_COSTOPTIMIZED: "Kostenoptimiert",
			QUICKPARAMETERS_HIGHACCURACY: "High Accuracy",
			QUICKPARAMETERS_LOWPOWER: "Geringer Stromverbrauch",
			QUICKPARAMETERS_NONBGA: "NICHT-BGA",
			QUICKPARAMETERS_PACKAGETYPE: "Gehäusetyp?",
			QUICKPARAMETERS_SMALLPACKAGE: "Kompaktes Gehäuse",
			QUICKPARAMETERS_KEYDESIGNNEED: "Wo liegt Ihr Design-Schwerpunkt?",
			QUICKPARAMETERS_RATING: "Bewertung",
			QUICKPARAMETERS_QP1: "Querverweissuche ",
    		QUICKPARAMETERS_QP2: "nach TI-Vergleichstypen für ",
    		QUICKPARAMETERS_QP3: "Temperatursensoren",
			WEBENCH_INPUT: "Select either Nominal or Min/Max Vin.",
			WEBENCH_OUTPUT: "Output",
			WEBENCH_OUTPUT1: "Specify Output #1",
			WEBENCH_OUTPUT2: "Specify Output #2",
			WEBENCH_ONE_OUT: "One output",
			WEBENCH_TWO_OUT: "Two outputs",
			WEBENCH_V_OUT: "Vout",
			WEBENCH_I_OUT: "Iout",
			WEBENCH_OUTPUT_ERR: "Error: you have selected two outputs, but have only completed one.",
			WEBENCH_WHAT: "What are WEBENCH® recommended parts?",
			WEBENCH_V_NOMINAL: "Vin Nominal",
			WEBENCH_V_MIN: "Vin Min",
			WEBENCH_VIN: "Vin",
			WEBENCH_V_MAX: "Vin Max",
			QUICKPARAMETERS_OPTIMIZED_CABLES_PROBES: "Optimiert für Kabel/Sonden",
    		QUICKPARAMETERS_V18_CAPABLE: "Betrieb an 1,8 V möglich",
    		QUICKPARAMETERS_INTEGRATED_POWER_MONITORING: "Integrierte Leistungsüberwachung",
    		QUICKPARAMETERS_FACTORY_PRESET: "Werksvoreinstellung",
    		QUICKPARAMETERS_PIN_CONFIGURABLE: "Pin-konfigurierbar",
    		QUICKPARAMETERS_RESISTOR_PROGRAMMABLE: "Widerstand programmierbar",
    		QUICKPARAMETERS_DUAL_TRIP_POINTS: "Zwei Auslösepunkte",
    		QUICKPARAMETERS_THRUHOLE: "Durchgangsbohrung",
    		QUICKPARAMETERS_SMALL_NONBGA: "Kompaktes Nicht-BGA-Gehäuse",
    		QUICKPARAMETERS_P2P:"Punkt zu Punkt (bis zu 2 Meter)",
    		QUICKPARAMETERS_DAISY_CHAIN:"Verkettung (bis zu 300 Meter)",
    		QUICKPARAMETERS_LOOK_FOR: "Was suchen Sie?",
    		QUICKPARAMETERS_INTERFACE_TYPE: "Was ist der Schnittstellentyp?",
    		QUICKPARAMETERS_PACKAGE_TYPE: "Welche Gehäusegruppe wird gewünscht?",
    		QUICKPARAMETERS_TOPOLOGY: "Topologie",
    		QUICKPARAMETERS_CROSS_REF: "http://" + newDomains["en"] + "/sensing-products/temperature-sensors/cross-reference.html",
    		QUICKPARAMETERS_ALERT_MSG: "Ermitteln Sie durch die Beantwortung weniger Fragen zu Ihren Designanforderungen den am besten geeigneten Temperatursensor.",
			QUICKPARAMETERS_OPTIMIZED_CABLES_PROBES: "Optimiert für Kabel/Sonden",
    		QUICKPARAMETERS_LOW_TEMP_SENSOR_SINGLE_CHANNEL: "Lokaler Temperatursensor (ein Kanal)",
    		QUICKPARAMETERS_SWITCHES_THERMOSTATS: "Schalter/Thermostate",
    		QUICKPARAMETERS_REMOTE_TEMP_SENSOR_MULTI_CHANNEL: "Remote-Temperatursensor (mehrere Kanäle)",
    		QUICKPARAMETERS_CABLES_PROBES: "Kabel/Sonden",
    		QUICKPARAMETERS_HIGH_CHANNEL_COUNT: "Kabel/Sonden",
    		QUICKPARAMETERS_PACKAGE: "Gehäuse",
    		QUICKPARAMETERS_SELECT: " - Auswählen -",
			//LDO CQS
			//DEVICE_GRADE: "Device Grade",
			LDO_CQS_AJUSTABLE_OUTPUT: "Ausgang einstellbar",
			LDO_CQS_ALL_GRADES: "All Qualitätsklassen",
			LDO_CQS_ALL_OUTPUT_TYPE: "Alle Ausgabetypen",
			LDO_CQS_ALL_SMALL_PACKAGE: "Small Package",
			LDO_CQS_AUTOMOTIVE_GRADE: "Automotive (AEC-Q100) Grade",
			LDO_CQS_ENHANCED_PERFORMACE_GRADE: "Enhanced Performance Grade",
			LDO_CQS_FIXED_OUTPUT: "Ausgang fest",
			LDO_CQS_INPUT: "Eingang",
			LDO_CQS_IOUT_LABEL_1: "Wert für Iout ist OK.",
			LDO_CQS_IOUT_LABEL_2: "Iout muss > 0,0001 A und < 50 A sein",
			LDO_CQS_IOUT_LABEL_3: "Ein LDO kann nur Quelle für Strom sein. Verwenden Sie einen positiven Wert für IOUT.",
			LDO_CQS_IOUT_LABEL_4: "Iout muss > 0 sein",
			LDO_CQS_PROGRAM_OUTPUT: "Ausgang programmierbar",
			LDO_CQS_SEARCH_LABEL_1: "Bitte Werte für Vin, Vout und Iout eingeben.",
			LDO_CQS_SEARCH_LABEL_2: "Suche ergab keine Produkte. Verwenden Sie andere Parameterwerte sowie Filter für Hauptmerkmale und Bausteinqualitätsklasse.",
			LDO_CQS_SEARCH_LABEL_3: "Ein LDO benötigt zur Regelung einen angemessenen Abstand zwischen VIN und VOUT. Ändern Sie die Eingangsspannung.",
			LDO_CQS_SEARCH_LABEL_4: "Es wurden keine LDOs gefunden, die diesen Eingaben entsprechen. Ändern Sie den Wert für IoutMax, Vin oder Vout.",
			LDO_CQS_VOUT_LABEL_1: "Vin is not a number!",
			LDO_CQS_VOUT_LABEL_2: "Vout is not a number!",
			LDO_CQS_VOUT_LABEL_3: "Ein LDO kann die Eingangsspannung nicht hochsetzen. Ändern Sie die Eingangs- oder Ausgangsspannung.",
			LDO_CQS_VOUT_LABEL_5: "OK, negative LDOs suchen ...",
			LDO_CQS_VOUT_LABEL_6: "Vout muss > Vin sein",
			LDO_CQS_VOUT_LABEL_7: "Ein LDO kann die Eingangsspannung nicht invertieren. Passen Sie die Polarität von Eingangs- und Ausgangsspannung an.",
			LDO_CQS_VOUT_LABEL_8: "narrow your input",
			LDO_CQS_VOUT_LABEL_9: "Noise Sensitive Applications",
			LDO_CQS_VOUT_LABEL_11: "Please enter values for Vin, vout and Iout",
			LDO_CQS_VOUT_LABEL_12: "Iout must be > 0 to select LDOs.",
			LDO_CQS_WIDEINPUT: "Wide Input voltage",
			QUICKPARAMETERS_TITLE: "Wichtigste Leistungsmerkmale",

			//Strings for Clock Oscillator
			CO_CQS_OSCILLATOR_TYPE: "Oszillatortyp",
			CO_CQS_STABILITY:	"Stabilität",
			CO_CQS_VIEW:	"Ansicht",
			CO_CQS_PARTS:	"Teile",
			CO_CQS_PIN_SELECTABLE:	"Pin-auswählbar",
			CO_CQS_PROGRAMMABLE:	"Programmierbar mit EEPROM",
			CO_CQS_OUTPUT_FORMAT:	"Ausgangsformat",
			CO_CQS_HCSL:	"HCSL",
			CO_CQS_LVCMOS:	"LVCMOS",
			CO_CQS_LVDS:	"LVDS",
			CO_CQS_LVPECL:	"LVPECL",
			CO_CQS_STANDARD:	"Standard",
			CO_CQS_FREQUENCY:	"Frequenz",
			CO_CQS_PACKAGE:	"Gehäuse",
			CO_CQS_CUSTOM:	"BENUTZERSPEZIFISCH",
			CO_CQS_REQUEST_SAMPLES:	"Individuelle Muster anfordern",
			CO_CQS_FORM_REQUEST_CO:	"Individuellen Oszillator anfordern",
			CO_CQS_FORM_ORDER_CUSTOM_FREQ:	"Individuellen Frequenzoszillator bestellen",
			CO_CQS_FORM_ULTRA_LOW_JITTER:	"Oszillatoren mit extrem niedrigem Jitter, eingestellt auf jede beliebige Frequenz zwischen 10 MHz und 1 GHz. Für Projekte jeder Größenordnung – Muster sind 1–2 Wochen bei Ihnen!",
			CO_CQS_FORM_WHY_ORDER_CUSTOM_OSC:	"Warum einen individuellen Oszillator bestellen?",
			CO_CQS_FORM_SIMPLE_SAMPLES:	"Die einfache und schnelle Möglichkeit, genau die benötigte Frequenz für Ihr System zu erhalten – ohne Kompromisse. Einfache Muster!",
			CO_CQS_FORM_STEPS:	"Schritte im Prozess",
			CO_CQS_FORM_STEP1:	"Einfach Ihre Daten hier in das Formular eingeben und absenden",
			CO_CQS_FORM_STEP2:	"Musteranforderungen bis zu x Exemplaren",
			CO_CQS_FORM_STEP3:	"Kleine Bestellmengen von unserem Vertriebspartner angepasst",
			CO_CQS_FORM_STEP4:	"Große Bestellmengen direkt von TI angepasst",
			CO_CQS_FORM_COMPLETE_FORM:	"Bestellen Sie Ihre Muster mit dem untenstehenden Formular.",
			CO_CQS_FORM_CUSTOMER_NAME:	"Kundenname ",
			CO_CQS_FORM_COMPANY_NAME:	"Firmenname ",
			CO_CQS_FORM_EMAIL:	"E-Mail-Adresse",
			CO_CQS_FORM_PHONE:	"Telefon",
			CO_CQS_FORM_REQ_FREQUNECY:	"Gewünschte Frequenz (in MHz)",
			CO_CQS_FORM_COMMENT:	"Kommentar",
			CO_CQS_FORM_DETAILS:	"Details",
			CO_CQS_FORM_CANCEL:	"Abbrechen",
			CO_CQS_FORM_SUBMIT:	"Anforderung absenden",
			CO_CQS_FORM_FIELD:	"Bitte dieses Feld ausfüllen"
		},
		EN: {
			BETA_BACK: "Go back to original Parametric selection tool",
			BETA_TRY: "Try our NEW Parametric selection tool",
			BETA_FLAIR: "Try our fastest ever, touch friendly parametric selection tool",
			BETA_FEEDBACK: "Please give us your feedback on this new parametric selection tool",
			CLICKCOLUMN: "Add/hide parameter",
			CLICKFULLSIZE: "Click to view full size",
			COMPARE: "Compare",
			COMPAREPARTS: "Compare Parts",
			DESCRIPTIONPARAMETRICS: "Description \& parametrics",
			DOWNLOADDATASHEET: "Download datasheet",
			DOWNLOADTOEXCEL: "Download to Excel",
			EMAIL: "Email",
			FEEDBACK: "Feedback",
			FILTERBYPART: "Filter by part number",
			FUNCTIONALDIAGRAM: "Functional diagram",
			HIDEFILTERS: "Hide filters",
			XITEMSSELECTED: "!!X!! items selected",
			ONLINEDATASHEET: "Online datasheet",
			SEEDATASHEET: "See datasheet ",
			PARAMETERS: "Parameters",
			XPARTSFOUND: "!!X!! parts found",
			PRINT: "Print",
			PRINTTHISTABLE: "Print this table",
			PRODUCTDETAILS: "Product details",
			RESET: "Reset",
			SAMPLEBUY: "Order Now",
			SEARCH: "Search",
			SELECT: "Select",
			SHOWBLANKS: "Show blanks",
			SHOWFILTERS: "Show filters",
			SHOWMORE: "Load more",
			QUICKSEARCHSHOW: "Show quick search",
			QUICKSEARCHHIDE: "Hide quick search",
			SHOWINGXPARTS: "!!X!! total parts",
			SHOWINGXOFYPARTS: "<strong>!!X!! matching parts</strong> out of !!Y!! total parts",
			SUPPORTTRAINING: "Support \& training",
			TECHNICALDOCUMENTS: "Technical documents",
			TOOLSSOFTWARE: "Tools \& software",
			TOOLTITLE: "Products for",
			VIEWXPARTS: "View !!X!! parts",
			VOUTLTVIN: "Vout must be < Vin",
			QUALITYPACKAGING: "Quality \& packaging",
			QUICKPARAMETERS: "One-click search",
			QUICKPARAMETERS_NOISE: "Noise Sensitive Applications",
			QUICKPARAMETERS_LOWIQ: "Low IQ",
			QUICKPARAMETERS_WIDEINPUT: "Wide Input Voltage",
			QUICKPARAMETERS_SMALL: "Small Package",
			QUICKPARAMETERS_INSTRUCTIONS: "Find specific parts with one click:",
			QUICKPARAMETERS_POWERSUPPLY: "Power Supply",
			QUICKPARAMETERS_SYNC_RECT: "Synchronous rectification",
			QUICKPARAMETERS_SWITCHING_FREQ: "2 MHz switching frequency",
			QUICKPARAMETERS_SINGLE: "Single",
			QUICKPARAMETERS_DUAL: "Dual",
			QUICKPARAMETERS_SMALL_FOOTPRINT: "Small Footprint",
			QUICKPARAMETERS_LOW_OFFSET: "Low Input Offset",
			QUICKPARAMETERS_LOW_GAIN_ERROR: "Low Gain Error",
			QUICKPARAMETERS_DESCRIPTION: "Find parts that match specific requirements",
			QUICKSEARCH: "Quick search",
			CHANNELCOUNT: "Channel Count",
			GAIN_BANDWIDTH: "Gain Bandwidth",
			SUPPLY_VOLTAGES: "Supply Voltages",
			SLEW_RATES: "Slew Rates",
			QUIESCENT_CURRENT: "Quiescent Current",
			RAIL_TO_RAIL: "Rail-to-Rail",
			RAIL2RAIL_IN: "In",
			RAIL2RAIL_OUT: "Out",
			RAIL2RAIL_INTO_VPLUS: "In to V+",
			RAIL2RAIL_INTO_VMINUS: "In to V-",
			LOW_NOISE: "Low Noise (≤ 10nV/√Hz)",
			LOW_OFFSET: "Low Offset (≤ 500µV)",
			LOW_POWER: "Low Power (≤ 500µA)",
			WIDE_BANDWIDTH: "Wide Bandwidth (≥ 5MHz)",
			SMALL_FOOTPRINT: "Small Footprint (≤ 9mm2)",
			OFFSET_VOLTAGE: "Offset Voltage",
			LOW_INPUT_BIAS: "Low Input Bias",
			SELECT_ONE: "None selected",
			POWER_MANAGEMENT_INTRO: "Find the right Battery Management products fast.",
			BATTERY_CHEMISTRY: "Battery Chemistry",
			INPUT_VOLTAGE: "Input Voltage",
			REG_BATTERY_VOLTAGE: "Regulated Battery Voltage",
			CHARGE_CURRENT: "Charge Current",
			EXPAND_ALL: "Expand All",
			COLLAPSE_ALL: "Collapse All",
			QUICKSEARCH_ARM: "ARM",
			QUICKSEARCH_FRAM: "FRAM",
			QUICKSEARCH_SMALL_PACKAGE: "Small Package < 5x5 mm2",
			QUICKSEARCH_LARGE_MEMORY_DEVICES: "Large memory devices",
			QUICKSEARCH_CAPTIVATE_TT: "CapTIvate™ Touch Technology",
			QUICKSEARCH_USB: "USB",
			QUICKSEARCH_LCD: "LCD",
			QUICKSEARCH_BEST_ACTIVE_PWR: "Best Active Power",
			QUICKSEARCH_BEST_STANDBY_PWR: "Best Standby Power",
			QUICKPARAMETERS_CAPACITIVE: "Capacitive buttons, sliders and wheels",
			QUICKPARAMETERS_ACCEL_PROCESSING: "Accelerated processing",
			QUICKPARAMETERS_BGA_PKGS: "Die- size BGA packages",
			QUICKPARAMETERS_ENHANCED_SECURITY: "Enhanced security features",
			QUICKPARAMETERS_SYS_STATE_RETENTION: "System state retention through power failure",
			QUICKPARAMETERS_FEATURED_MCU: "Featured Microcontrollers by Function",
			QUICKSEARCH_NUMBER_CORES: "Number of cores",
			QUICKSEARCH_DSP_SPEED: "DSP Speed",
			QUICKSEARCH_TOTAL_CACHE: "Total On-Chip Memory",
			QUICKPARAMETERS_SINGLE_CORE: "Single Core DSP",
			QUICKPARAMETERS_HI_PERF_DSP: "High performance DSP",
			QUICKPARAMETERS_HI_SPEED_INTERFACES: "High speed interfaces",
			QUICKPARAMETERS_FLOAT_PT_DSP: "Floating point DSP",
			QUICKPARAMETERS_EXT_TEMP_DEVICES: "Extended temperature devices",
			QUICKPARAMETERS_HIGH_SUPPLY_VOLTAGE: "High Supply Voltage (> 6V)",
			QUICKPARAMETERS_LOW_SUPPLY_VOLTAGE: "Low Supply Voltage (<= 6V)",
			QUICKPARAMETERS_AUTO_QUALIFIED: "Automotive Qualified (AEC-Q100)",
			QUICKPARAMETERS_LOW_OFFSET_VOLTAGE: "Low Offset Voltage (<=500µV)",
			QUICKPARAMETERS_LOW_QUIE_CURRENT: "Low Quiescent Current (<=500µA)",
			QUICKPARAMETERS_LOW_NOISE_DENSITY: "Low Noise Density (≤ 10nV/√Hz)",
			INTRO_TEXT: "TI has updated its parametric selection tool to work on both desktops and tablets",
			INTRO_LINK: "Find out what's new",
			QUICKPARAMETERS_HIREL_DESCRIPTION: "Find high reliability parts specific to your industry",
			QUICKPARAMETERS_SPACE: "Space",
			QUICKPARAMETERS_ENHANCED_PRODUCTS: "Enhanced Products",
			QUICKPARAMETERS_HIGH_TEMPERATURE: "Hermetic / High Temperature",
			QUICKPARAMETERS_PRODUCT_CAT: "Product Category",
			QUICKPARAMETERS_PRODUCT_SUBCAT: "product Sub-Category",
			QUICKPARAMETERS_AUTOMOTIVE: "Automotive",
			QUICKPARAMETERS_CATALOG: "Catalog",
			QUICKPARAMETERS_COSTOPTIMIZED: "Cost-optimized",
			QUICKPARAMETERS_HIGHACCURACY: "High Accuracy",
			QUICKPARAMETERS_LOWPOWER: "Low Power",
			QUICKPARAMETERS_NONBGA: "NON-BGA",
			QUICKPARAMETERS_PACKAGETYPE: "Package Type?",
			QUICKPARAMETERS_SMALLPACKAGE: "Small Package",
			QUICKPARAMETERS_KEYDESIGNNEED: "What is your key design need?",
			QUICKPARAMETERS_RATING: "Rating",
			QUICKPARAMETERS_QP1: "Or, perform a ",
    		QUICKPARAMETERS_QP2: "cross reference search ",
    		QUICKPARAMETERS_QP3: "to replace non-TI temp sensor",
			WEBENCH_INPUT: "Select either Nominal or Min/Max Vin.",
			WEBENCH_OUTPUT: "Output",
			WEBENCH_OUTPUT1: "Specify Output #1",
			WEBENCH_OUTPUT2: "Specify Output #2",
			WEBENCH_ONE_OUT: "One output",
			WEBENCH_TWO_OUT: "Two outputs",
			WEBENCH_V_OUT: "Vout",
			WEBENCH_I_OUT: "Iout",
			WEBENCH_OUTPUT_ERR: "Error: you have selected two outputs, but have only completed one.",
			WEBENCH_WHAT: "What are WEBENCH® recommended parts?",
			WEBENCH_V_NOMINAL: "Vin Nominal",
			WEBENCH_V_MIN: "Vin Min",
			WEBENCH_VIN: "Vin",
			WEBENCH_V_MAX: "Vin Max",
			QUICKPARAMETERS_V18_CAPABLE: "1.8V Capable",
    		QUICKPARAMETERS_INTEGRATED_POWER_MONITORING: "Integrated Power Monitor",
    		QUICKPARAMETERS_FACTORY_PRESET: "Factory Preset",
    		QUICKPARAMETERS_PIN_CONFIGURABLE: "Pin Configurable",
    		QUICKPARAMETERS_RESISTOR_PROGRAMMABLE: "Resistor Programmable",
    		QUICKPARAMETERS_DUAL_TRIP_POINTS: "Dual Trip Points",
    		QUICKPARAMETERS_THRUHOLE: "Thru Hole",
    		QUICKPARAMETERS_SMALL_NONBGA: "Small Non-BGA",
    		QUICKPARAMETERS_P2P:"Point to Point (up to 2 meters)",
    		QUICKPARAMETERS_DAISY_CHAIN:"Daisy-chain (up to 300 meters)",
    		QUICKPARAMETERS_LOOK_FOR:"What are you looking for?",
    		QUICKPARAMETERS_INTERFACE_TYPE: "What is the interface type?",
    		QUICKPARAMETERS_PACKAGE_TYPE: "What is your choice of package group?",
    		QUICKPARAMETERS_TOPOLOGY: "Topology",
    		QUICKPARAMETERS_CROSS_REF: "http://" + newDomains["en"] + "/sensing-products/temperature-sensors/cross-reference.html",
    		QUICKPARAMETERS_ALERT_MSG: "Answer a few questions about your design requirements and find the most appropriate Temperature Sensor.",
    		QUICKPARAMETERS_OPTIMIZED_CABLES_PROBES: "Optimized for Cables/Probes",
    		QUICKPARAMETERS_LOW_TEMP_SENSOR_SINGLE_CHANNEL: "Local Temp Sensor (Single Channel)",
    		QUICKPARAMETERS_SWITCHES_THERMOSTATS: "Switches/Thermostats",
    		QUICKPARAMETERS_REMOTE_TEMP_SENSOR_MULTI_CHANNEL: "Remote Temp Sensor (Multi-channel)",
    		QUICKPARAMETERS_CABLES_PROBES: "Cables/Probes",
    		QUICKPARAMETERS_HIGH_CHANNEL_COUNT: "High Channel Count",
    		QUICKPARAMETERS_PACKAGE: "Package",
    		QUICKPARAMETERS_SELECT: " - Select -",
			//LDO
			//DEVICE_GRADE: "Device Grade",
			LDO_CQS_ALL_GRADES: "All Grade",
			LDO_CQS_AJUSTABLE_OUTPUT: "Adjustable Output",
			LDO_CQS_ALL_OUTPUT_TYPE: "All Output Types",
			LDO_CQS_ALL_SMALL_PACKAGE: "Small Package",
			LDO_CQS_AUTOMOTIVE_GRADE: "Automotive (AEC-Q100) Grade",
			LDO_CQS_ENHANCED_PERFORMACE_GRADE: "Enhanced Performance Grade",
			LDO_CQS_FIXED_OUTPUT: "Fixed Output",
			LDO_CQS_INPUT: "Input",
			LDO_CQS_IOUT_LABEL_1: "Iout value is OK.",
			LDO_CQS_IOUT_LABEL_2: "Iout must be > 0.0001 A and < 50 A",
			LDO_CQS_IOUT_LABEL_3: "An LDO can only source current. Try using a positive IOUT value.",
			LDO_CQS_IOUT_LABEL_4: "Iout must be > 0 to select LDOs.",
			LDO_CQS_PROGRAM_OUTPUT: "Programmable Output",
			LDO_CQS_SEARCH_LABEL_1: "Please enter values for Vin, Vout and Iout.",
			LDO_CQS_SEARCH_LABEL_2: "Search did not match any products. Try changing parameter values and key feature and device grade filters.",
			LDO_CQS_SEARCH_LABEL_3: "An LDO requires adequate VIN – VOUT headroom for regulation. Try changing the input voltage.",
			LDO_CQS_SEARCH_LABEL_4: "No LDOs were found matching these inputs. Try changing IoutMax, Vin or Vout.",
			LDO_CQS_VOUT_LABEL_1: "Vin is not a number!",
			LDO_CQS_VOUT_LABEL_2: "Vout is not a number!",
			LDO_CQS_VOUT_LABEL_3: "An LDO cannot step up the input voltage. Try changing the input or output voltage.",
			LDO_CQS_VOUT_LABEL_4: "OK, Search for positive LDOs ...",
			LDO_CQS_VOUT_LABEL_5: "OK, Search for negative LDOs ...",
			LDO_CQS_VOUT_LABEL_6: "Vout must be > Vin",
			LDO_CQS_VOUT_LABEL_7: "An LDO cannot invert the input voltage. Try matching the polarity of the input and output voltage.",
			LDO_CQS_VOUT_LABEL_8: "narrow your input",
			LDO_CQS_VOUT_LABEL_9: "Noise Sensitive Applications",
			LDO_CQS_VOUT_LABEL_10: "Vout must be < Vin",
			LDO_CQS_VOUT_LABEL_11: "Please enter values for Vin, vout and Iout",
			LDO_CQS_VOUT_LABEL_12: "Iout must be > 0 to select LDOs.",
			LDO_CQS_WIDEINPUT: "Wide Input voltage",
			QUICKPARAMETERS_TITLE: "Key Features",

			//Strings for Clock Oscillator CQS
			CO_CQS_OSCILLATOR_TYPE: "Oscillator Type",
			CO_CQS_STABILITY: "Stability",
			CO_CQS_VIEW: "View",
			CO_CQS_PARTS: "Parts",
			CO_CQS_PIN_SELECTABLE: "Pin Selectable",
			CO_CQS_PROGRAMMABLE: "Programmable with EEPROM",
			CO_CQS_OUTPUT_FORMAT: "Output Format",
			CO_CQS_HCSL: "HCSL",
			CO_CQS_LVCMOS: "LVCMOS",
			CO_CQS_LVDS: "LVDS",
			CO_CQS_LVPECL: "LVPECL",
			CO_CQS_STANDARD: "Standard",
			CO_CQS_FREQUENCY: "Frequency",
			CO_CQS_PACKAGE: "Package",
			CO_CQS_CUSTOM: "CUSTOM",
			CO_CQS_REQUEST_SAMPLES: "Request Custom Samples",
			CO_CQS_FORM_REQUEST_CO: "Request custom oscillator",
			CO_CQS_FORM_ORDER_CUSTOM_FREQ: "Order a custom frequency oscillator",
			CO_CQS_FORM_ULTRA_LOW_JITTER: "Ultra-low jitter oscillators customized to any frequency from 10MHz to 1GHz. For any size project - Get samples within 1-2 weeks!",
			CO_CQS_FORM_WHY_ORDER_CUSTOM_OSC: "Why order a custom oscillator?",
			CO_CQS_FORM_SIMPLE_SAMPLES: "A simple and quick way to get the exact frequency you need for your system without compromise. Simple Samples!",
			CO_CQS_FORM_STEPS: "Steps in the process",
			CO_CQS_FORM_STEP1: "Simply enter your information in the form here and submit",
			CO_CQS_FORM_STEP2: "Sample requests up to x pieces",
			CO_CQS_FORM_STEP3: "Small order quantities customized from our distribution partner",
			CO_CQS_FORM_STEP4: "Large order quantities customized directly from TI",
			CO_CQS_FORM_COMPLETE_FORM: "Please complete the form below to receive your samples.",
			CO_CQS_FORM_CUSTOMER_NAME: "Customer name",
			CO_CQS_FORM_COMPANY_NAME: "Company name",
			CO_CQS_FORM_EMAIL: "Email address",
			CO_CQS_FORM_PHONE: "Phone",
			CO_CQS_FORM_REQ_FREQUNECY: "Requested Frequency (in MHz)",
			CO_CQS_FORM_COMMENT: "Comment",
			CO_CQS_FORM_DETAILS: "Details",
			CO_CQS_FORM_CANCEL: "Cancel",
			CO_CQS_FORM_SUBMIT: "Submit Request",
			CO_CQS_FORM_FIELD: "Please fill out this field"
		},
		JP: {
			BETA_BACK: "オリジナルのパラメータ・セレクション・ツールへ戻る",
			BETA_TRY: "新しい BETA パラメータ・セレクション・ツールを試す",
			BETA_FLAIR: "最速で、使いやすいパラメトリック・セレクション・ツールをお試しください。",
			BETA_FEEDBACK: "新しいパラメトリック・セレクション・ツールについてフィードバックをお願いします。",
			CLICKCOLUMN: "クリックしてカラムを表示/隠す",
			CLICKFULLSIZE: "クリックしてフルサイズを表示",
			COMPARE: "比較",
			COMPAREPARTS: "選択した製品を比較",
			DESCRIPTIONPARAMETRICS: "概要と機能一覧",
			DOWNLOADDATASHEET: "データシート",
			DOWNLOADTOEXCEL: "Excelへダウンロード",
			EMAIL: "メール",
			FEEDBACK: "フィードバック",
			FILTERBYPART: "製品番号でフィルタリング",
			FUNCTIONALDIAGRAM: "機能図",
			HIDEFILTERS: "フィルタを非表示",
			XITEMSSELECTED: "!!X!! 項目を選択",
			ONLINEDATASHEET: "オンライン・データシート",
			SEEDATASHEET: "データシート ",
			PARAMETERS: "パラメータ",
			XPARTSFOUND: "!!X!! 製品が見つかりました",
			PRINT: "プリント",
			PRINTTHISTABLE: "このテーブルをプリント",
			PRODUCTDETAILS: "製品の詳細",
			RESET: "リセット",
			SAMPLEBUY: "今すぐ購入",
			SEARCH: "検索",
			SELECT: "選択",
			SHOWBLANKS: "空白を表示",
			SHOWFILTERS: "フィルタの表示",
			SHOWMORE: "さらに表示",
			QUICKSEARCHSHOW: "クイック・サーチを表示",
			QUICKSEARCHHIDE: "クイック・サーチを隠す",
			SHOWINGXPARTS: "!!X!! 製品を表示",
			SHOWINGXOFYPARTS: "!!Y!! 件中 !!X!! 件の製品が一致しました。",
			SUPPORTTRAINING: "サポートとコミュニティ",
			TECHNICALDOCUMENTS: "技術資料",
			TOOLSSOFTWARE: "ツールとソフトウェア",
			TOOLTITLE: "Products for",
			VIEWXPARTS: "!!X!! 製品を表示",
			VOUTLTVIN: "Vout条件: <Vin",
			QUALITYPACKAGING: "品質とパッケージ",
			QUICKPARAMETERS: "ワンクリック・パラメータ",
			QUICKPARAMETERS_NOISE: "ノイズ感知アプリケーション",
			QUICKPARAMETERS_LOWIQ: "低 IQ",
			QUICKPARAMETERS_WIDEINPUT: "ワイド入力電圧",
			QUICKPARAMETERS_SMALL: "小型パッケージ",
			QUICKPARAMETERS_INSTRUCTIONS: "ワンクリックでお探しの部品を検索:",
			QUICKPARAMETERS_POWERSUPPLY: "Power Supply",
			QUICKPARAMETERS_SYNC_RECT: "Synchronous rectification",
			QUICKPARAMETERS_SWITCHING_FREQ: "2 MHz switching frequency",
			QUICKPARAMETERS_SINGLE: "Single",
			QUICKPARAMETERS_DUAL: "Dual",
			QUICKPARAMETERS_SMALL_FOOTPRINT: "Small Footprint",
			QUICKPARAMETERS_LOW_OFFSET: "Low Input Offset",
			QUICKPARAMETERS_LOW_GAIN_ERROR: "Low Gain Error",
			QUICKPARAMETERS_DESCRIPTION: "具体的な要求に合った製品を見つける",
			QUICKSEARCH: "クイック・サーチ",
			CHANNELCOUNT: "Number of Channels (#)",
			GAIN_BANDWIDTH: "Gain Bandwidth",
			SUPPLY_VOLTAGES: "Supply Voltages",
			SLEW_RATES: "Slew Rates",
			QUIESCENT_CURRENT: "Quiescent Current",
			RAIL_TO_RAIL: "Rail-to-Rail",
			RAIL2RAIL_IN: "In",
			RAIL2RAIL_OUT: "Out",
			RAIL2RAIL_INTO_VPLUS: "In to V+",
			RAIL2RAIL_INTO_VMINUS: "In to V-",
			LOW_NOISE: "低雑音 (≤ 10nV/√Hz)"	,
			LOW_OFFSET: "低オフセット (≤ 500µV)",
			LOW_POWER: "低消費電力 (≤ 500µA)",
			WIDE_BANDWIDTH: "広い帯域幅 (≥ 5MHz)",
			SMALL_FOOTPRINT: "小型のフットプリント (≤ 9mm2)",
			OFFSET_VOLTAGE: "Offset Voltage",
			LOW_INPUT_BIAS: "低入力バイアス電流",
			SELECT_ONE: "None selected",
			POWER_MANAGEMENT_INTRO: "右側のバッテリ・マネージメント製品の高速検索.",
			BATTERY_CHEMISTRY: "Battery Chemistry",
			INPUT_VOLTAGE: "Input Voltage",
			REG_BATTERY_VOLTAGE: "Regulated Battery Voltage",
			CHARGE_CURRENT: "Charge Current",
			EXPAND_ALL: "すべて展開する",
			COLLAPSE_ALL: "すべて折り畳む",
			QUICKSEARCH_ARM: "ARM",
			QUICKSEARCH_FRAM: "FRAM",
			QUICKSEARCH_SMALL_PACKAGE: "小型パッケージ < 5x5 mm2",
			QUICKSEARCH_LARGE_MEMORY_DEVICES: "大容量メモリデバイス",
			QUICKSEARCH_CAPTIVATE_TT: "CapTIvate™ タッチテクノロジ",
			QUICKSEARCH_USB: "USB",
			QUICKSEARCH_LCD: "LCD",
			QUICKSEARCH_BEST_ACTIVE_PWR: "最高のアクティブ消費電力",
			QUICKSEARCH_BEST_STANDBY_PWR: "最高のスタンバイ電力",
			QUICKPARAMETERS_CAPACITIVE: "静電容量式ボタン、スライダ、およびホイール",
			QUICKPARAMETERS_ACCEL_PROCESSING: "Accelerated 処理",
			QUICKPARAMETERS_BGA_PKGS: "ダイ - サイズの BGA パッケージ",
			QUICKPARAMETERS_ENHANCED_SECURITY: "セキュリティ強化機能",
			QUICKPARAMETERS_SYS_STATE_RETENTION: "電源障害によってシステムの状態を保持",
			QUICKPARAMETERS_FEATURED_MCU: "関数によって主なマイコン",
			QUICKSEARCH_NUMBER_CORES: "Number of cores",
			QUICKSEARCH_DSP_SPEED: "DSP Speed",
			QUICKSEARCH_TOTAL_CACHE: "Total On-Chip Memory",
			QUICKPARAMETERS_SINGLE_CORE: "シングル・コア DSP",
			QUICKPARAMETERS_HI_PERF_DSP: "高性能 DSP",
			QUICKPARAMETERS_HI_SPEED_INTERFACES: "高速インターフェイス",
			QUICKPARAMETERS_FLOAT_PT_DSP: "浮動小数点 DSP",
			QUICKPARAMETERS_EXT_TEMP_DEVICES: "拡張温度範囲デバイス",
			QUICKPARAMETERS_HIGH_SUPPLY_VOLTAGE: "High Supply Voltage (> 6V)",
			QUICKPARAMETERS_LOW_SUPPLY_VOLTAGE: "Low Supply Voltage (<= 6V)",
			QUICKPARAMETERS_AUTO_QUALIFIED: "車載認定 (AEC-Q100)",
			QUICKPARAMETERS_LOW_OFFSET_VOLTAGE: "Low Offset Voltage (<=500µV)",
			QUICKPARAMETERS_LOW_QUIE_CURRENT: "Low Quiescent Current (<=500µA)",
			QUICKPARAMETERS_LOW_NOISE_DENSITY: "Low Noise Density (≤ 10nV/√Hz)",
			INTRO_TEXT: "パラメトリック・セレクション・ツールがデスクトップとタブレットで動作するよう更新しました",
			INTRO_LINK: "最新機能の詳細はこちら",
			QUICKPARAMETERS_HIREL_DESCRIPTION: "Find high reliability parts specific to your industry",
			QUICKPARAMETERS_SPACE: "Space",
			QUICKPARAMETERS_ENHANCED_PRODUCTS: "Enhanced Products",
			QUICKPARAMETERS_HIGH_TEMPERATURE: "Hermetic / High Temperature",
			QUICKPARAMETERS_PRODUCT_CAT: "Product Category",
			QUICKPARAMETERS_PRODUCT_SUBCAT: "product Sub-Category",
			QUICKPARAMETERS_AUTOMOTIVE: "車載",
			QUICKPARAMETERS_CATALOG: "カタログ",
			QUICKPARAMETERS_COSTOPTIMIZED: "コスト最適化済み",
			QUICKPARAMETERS_HIGHACCURACY: "高精度",
			QUICKPARAMETERS_LOWPOWER: "低消費電力",
			QUICKPARAMETERS_NONBGA: "BGA 以外",
			QUICKPARAMETERS_PACKAGETYPE: "パッケージの種類?",
			QUICKPARAMETERS_SMALLPACKAGE: "小型パッケージ",
			QUICKPARAMETERS_RATING: "定格",
			QUICKPARAMETERS_KEYDESIGNNEED: "設計に重要なニーズは？",
			QUICKPARAMETERS_QP1: "検索する",
    		QUICKPARAMETERS_QP2:"クロスリファレンスの検索",
    		QUICKPARAMETERS_QP3: "TI製品に置き換える",
			WEBENCH_INPUT: "Select either Nominal or Min/Max Vin.",
			WEBENCH_OUTPUT: "Output",
			WEBENCH_OUTPUT1: "Specify Output #1",
			WEBENCH_OUTPUT2: "Specify Output #2",
			WEBENCH_ONE_OUT: "One output",
			WEBENCH_TWO_OUT: "Two outputs",
			WEBENCH_V_OUT: "Vout",
			WEBENCH_I_OUT: "Iout",
			WEBENCH_OUTPUT_ERR: "Error: you have selected two outputs, but have only completed one.",
			WEBENCH_WHAT: "What are WEBENCH® recommended parts?",
			WEBENCH_V_NOMINAL: "Vin Nominal",
			WEBENCH_V_MIN: "Vin Min",
			WEBENCH_VIN: "Vin",
			WEBENCH_V_MAX: "Vin Max",
			QUICKPARAMETERS_OPTIMIZED_CABLES_PROBES: "ケーブルとプローブ向けに最適化",
    		QUICKPARAMETERS_V18_CAPABLE: "1.8V 対応",
    		QUICKPARAMETERS_INTEGRATED_POWER_MONITORING: "電力監視機能内蔵",
    		QUICKPARAMETERS_FACTORY_PRESET: "出荷時プリセット",
    		QUICKPARAMETERS_PIN_CONFIGURABLE: "ピン設定可能",
    		QUICKPARAMETERS_RESISTOR_PROGRAMMABLE: "抵抗によるプログラミングが可能",
    		QUICKPARAMETERS_DUAL_TRIP_POINTS: "デュアル・トリップ・ポイント",
    		QUICKPARAMETERS_THRUHOLE: "スルー・ホール",
    		QUICKPARAMETERS_SMALL_NONBGA: "小型の非 BGA",
    		QUICKPARAMETERS_P2P: "ポイント・ツー・ポイント（最大 2 メートル）",
    		QUICKPARAMETERS_DAISY_CHAIN: "デイジーチェーン（最大 300 メートル）",
    		QUICKPARAMETERS_LOOK_FOR: "何をお探しですか ?",
    		QUICKPARAMETERS_INTERFACE_TYPE: "インターフェイス・タイプは何ですか？",
    		QUICKPARAMETERS_PACKAGE_TYPE: "パッケージ・グループは何を選択しますか？",
    		QUICKPARAMETERS_TOPOLOGY: "トポロジー",
    		QUICKPARAMETERS_CROSS_REF: "http://" + newDomains["jp"] + "/ja-jp/sensing-products/temperature-sensors/cross-reference.html",
    		QUICKPARAMETERS_ALERT_MSG: "実際の設計要件に関する質問に回答して、最適な温度センサを見つけてください。",
			QUICKPARAMETERS_OPTIMIZED_CABLES_PROBES: "ケーブルとプローブ向けに最適化",
    		QUICKPARAMETERS_LOW_TEMP_SENSOR_SINGLE_CHANNEL: "ローカル温度センサ（シングル・チャネル）",
    		QUICKPARAMETERS_SWITCHES_THERMOSTATS: "スイッチ/サーモスタット",
    		QUICKPARAMETERS_REMOTE_TEMP_SENSOR_MULTI_CHANNEL: "リモート温度センサ（マルチチャネル）",
    		QUICKPARAMETERS_CABLES_PROBES: "ケーブルとプローブ",
    		QUICKPARAMETERS_HIGH_CHANNEL_COUNT: "高チャネル数",
    		QUICKPARAMETERS_PACKAGE: "封裝",
    		QUICKPARAMETERS_SELECT: "- 選択 -",
			//LDO CQS
			//DEVICE_GRADE: "Device Grade",
			LDO_CQS_AJUSTABLE_OUTPUT: "可変出力",
			LDO_CQS_ALL_GRADES: "すべてのグレード",
			LDO_CQS_ALL_SMALL_PACKAGE: "小型封裝",
			LDO_CQS_ALL_OUTPUT_TYPE: "すべての出力方式",
			LDO_CQS_AUTOMOTIVE_GRADE: "車載（AEC-Q100）グレード ",
			LDO_CQS_ENHANCED_PERFORMACE_GRADE: "拡張された性能グレード ",
			LDO_CQS_FIXED_OUTPUT: "固定出力",
			LDO_CQS_INPUT: "入力",
			LDO_CQS_IOUT_LABEL_1: "Iout の値は適切です",
			LDO_CQS_IOUT_LABEL_2: "-50 ～ 125V の電圧入力範囲が必須",
			LDO_CQS_IOUT_LABEL_3: "LDO は電流の供給（ソース）のみが可能です。IOUT として正の値を使用してみてください。",
			LDO_CQS_IOUT_LABEL_4: "Iout > 0 が必須",
			LDO_CQS_PROGRAM_OUTPUT: "プログラマブル出力",
			LDO_CQS_SEARCH_LABEL_1: "Vin、Vout、Iout の数値を入力してください。",
			LDO_CQS_SEARCH_LABEL_2: "検索の結果、一致する製品が見つかりませんでした。パラメータの値、主な機能、デバイス・グレードの各フィルタを変更してみてください",
			LDO_CQS_SEARCH_LABEL_3: "LDO はレギュレーションを行うために、適切な VIN – VOUT のヘッドルームを必要とします。入力電圧を変更してみてください。",
			LDO_CQS_SEARCH_LABEL_4: "これらの入力条件に一致する LDO は見つかりませんでした。IoutMax、Vin、または Vout を変更してみてください。",
			LDO_CQS_VOUT_LABEL_1: "Vin が NaN（数値以外）です",
			LDO_CQS_VOUT_LABEL_2: "Vout が NaN（数値以外）です",
			LDO_CQS_VOUT_LABEL_3: "LDO は入力電圧を昇圧することはできません。入力電圧または出力電圧を変更してみてください。",
			LDO_CQS_VOUT_LABEL_4: "条件を確認しました。正の LDO を検索します ...",
			LDO_CQS_VOUT_LABEL_5: "条件を確認しました。負の LDO を検索します ...",
			LDO_CQS_VOUT_LABEL_6: "Vout < Vin が必須",
			LDO_CQS_VOUT_LABEL_7: "LDO は入力電圧を反転することはできません。入力電圧と出力電圧の極性を合わせてみてください。",
			LDO_CQS_VOUT_LABEL_8: "つまたは複数の特長を選択して、入力を絞り込むことができます",
			LDO_CQS_VOUT_LABEL_9: "ノイズの影響を受けやすいアプリケーション",
			LDO_CQS_VOUT_LABEL_11: "Please enter values for Vin, vout and Iout",
			LDO_CQS_VOUT_LABEL_12: "LDO を選択する場合、Iout > 0 は必須です。",
			LDO_CQS_WIDEINPUT: "Wide Input voltage",
			QUICKPARAMETERS_TITLE: "主な特長",

			//Strings for Clock Oscillator
			CO_CQS_OSCILLATOR_TYPE: "発振器の種類",
			CO_CQS_STABILITY:	"安定性",
			CO_CQS_VIEW:	"表示",
			CO_CQS_PARTS:	"部品",
			CO_CQS_PIN_SELECTABLE:	"ピン選択可能",
			CO_CQS_PROGRAMMABLE:	"プログラマブル EEPROM",
			CO_CQS_OUTPUT_FORMAT:	"出力形式",
			CO_CQS_HCSL:	"HCSL",
			CO_CQS_LVCMOS:	"LVCMOS",
			CO_CQS_LVDS:	"LVDS",
			CO_CQS_LVPECL:	"LVPECL",
			CO_CQS_STANDARD:	"規格",
			CO_CQS_FREQUENCY:	"周波数",
			CO_CQS_PACKAGE:	"パッケージ",
			CO_CQS_CUSTOM:	"カスタム",
			CO_CQS_REQUEST_SAMPLES:	"カスタム・サンプルのご注文",
			CO_CQS_FORM_REQUEST_CO:	"カスタム発振器のご注文",
			CO_CQS_FORM_ORDER_CUSTOM_FREQ:	"カスタム周波数発振器のご注文",
			CO_CQS_FORM_ULTRA_LOW_JITTER:	"10MHz ～ 1GHz の任意の周波数にカスタマイズした超低ジッタ発振器あらゆるサイズのプロジェクト用に、1 ～ 2 週間でサンプルをご提供",
			CO_CQS_FORM_WHY_ORDER_CUSTOM_OSC:	"カスタム発振器をお求めの理由",
			CO_CQS_FORM_SIMPLE_SAMPLES:	"システムで必要な正確な周波数を、簡単かつ迅速にご提供します。シンプルなサンプルをご活用ください。",
			CO_CQS_FORM_STEPS:	"プロセスのステップ",
			CO_CQS_FORM_STEP1:	"このフォームに情報を入力して送信するだけです",
			CO_CQS_FORM_STEP2:	"最大 x 個のサンプルのご請求",
			CO_CQS_FORM_STEP3:	"カスタマイズした少量のご注文は TI の販売特約店パートナーから",
			CO_CQS_FORM_STEP4:	"カスタマイズした大量のご注文は TI から直接",
			CO_CQS_FORM_COMPLETE_FORM:	"サンプルを入手するには、以下のフォームにご記入ください。",
			CO_CQS_FORM_CUSTOMER_NAME:	"お名前 ",
			CO_CQS_FORM_COMPANY_NAME:	"会社名 ",
			CO_CQS_FORM_EMAIL:	"E メール・アドレス",
			CO_CQS_FORM_PHONE:	"電話番号",
			CO_CQS_FORM_REQ_FREQUNECY:	"お求めの周波数（MHz）",
			CO_CQS_FORM_COMMENT:	"コメント",
			CO_CQS_FORM_DETAILS:	"詳細",
			CO_CQS_FORM_CANCEL:	"キャンセル",
			CO_CQS_FORM_SUBMIT:	"ご注文の送信",
			CO_CQS_FORM_FIELD:	"このフィールドにご記入ください"
		},
		KR: {
			BETA_BACK: "원래 매개 변수의 선택 툴로 돌아가기",
			BETA_TRY: "새로운 베타 매개 변수의 선택 툴 사용하기",
			BETA_FLAIR: "가장 빠르게, 친화적인 매개 변수 선택 툴을 터치해 보세요.",
			BETA_FEEDBACK: "새로운 매개 변수 선택 툴에 대한 귀하의 의견을 부탁합니다.",
			CLICKCOLUMN: "열 보기/숨김 클릭하기",
			CLICKFULLSIZE: "전체 화면을 보려면 클릭하세요",
			COMPARE: "비교",
			COMPAREPARTS: "부품 비교",
			DESCRIPTIONPARAMETRICS: "설명 \& 매개 변수",
			DOWNLOADDATASHEET: "데이터 시트",
			DOWNLOADTOEXCEL: "엑셀 다운로드",
			EMAIL: "이메일",
			FEEDBACK: "피드백",
			FILTERBYPART: "부품 넘버로 필터",
			FUNCTIONALDIAGRAM: "기능 다이어그램",
			HIDEFILTERS: "필터를 숨기기",
			XITEMSSELECTED: "!!X!! 아이템 선택",
			ONLINEDATASHEET: "온라인 데이터시트",
			SEEDATASHEET: "데이터 시트 ",
			PARAMETERS: "파라미터",
			XPARTSFOUND: "!!X!! 부품이 탐색됨",
			PRINT: "인쇄",
			PRINTTHISTABLE: "이 표 인쇄하기",
			PRODUCTDETAILS: "제품 상세 정보",
			RESET: "리셋",
			SAMPLEBUY: "지금 주문하세요.",
			SEARCH: "검색 불가",
			SELECT: "선택",
			SHOWBLANKS: "블랭크 표시",
			SHOWFILTERS: "필터 표시",
			SHOWMORE: "보다 자세한 내용 보기",
			QUICKSEARCHSHOW: "빠른 검색 보기",
			QUICKSEARCHHIDE: "빠른 검색 숨기기",
			SHOWINGXPARTS: "!!X!! 부품 살펴보기",
			SHOWINGXOFYPARTS: "!!Y!! 총 부품중 !!X!! 일치하는 부품",
			SUPPORTTRAINING: "지원 \& 교육",
			TECHNICALDOCUMENTS: "기술 문서",
			TOOLSSOFTWARE: "툴 \& 소트프웨어",
			TOOLTITLE: "제품",
			VIEWXPARTS: "!!X!! 부품 보기",
			VOUTLTVIN: "Vout must be < Vin", //"출력전압(Vout)은 입력전압(Vin)보다 작아야 합니다",
			QUALITYPACKAGING: "품질 \& 패키징",
			QUICKPARAMETERS: "원 클릭 파라미터",
			QUICKPARAMETERS_NOISE: "소음에 민감한 애플리케이션",
			QUICKPARAMETERS_LOWIQ: "낮은 IQ",
			QUICKPARAMETERS_WIDEINPUT: "광범위한 입력 전압",
			QUICKPARAMETERS_SMALL: "소형 패키지",
			QUICKPARAMETERS_INSTRUCTIONS: "클릭 한 번으로 특정 부품들을 찾아보세요:",
			QUICKPARAMETERS_POWERSUPPLY: "전원 공급 장치",
			QUICKPARAMETERS_SYNC_RECT: "Synchronous rectification",
			QUICKPARAMETERS_SWITCHING_FREQ: "2 MHz switching frequency",
			QUICKPARAMETERS_SINGLE: "Single",
			QUICKPARAMETERS_DUAL: "Dual",
			QUICKPARAMETERS_SMALL_FOOTPRINT: "Small Footprint",
			QUICKPARAMETERS_LOW_OFFSET: "Low Input Offset",
			QUICKPARAMETERS_LOW_GAIN_ERROR: "Low Gain Error",
			QUICKPARAMETERS_DESCRIPTION: "적합한 특정 요건의 부품 찾기",
			QUICKSEARCH: "빠른 검색",
			CHANNELCOUNT: "채널 수",
			GAIN_BANDWIDTH: "이득 대역폭",
			SUPPLY_VOLTAGES: "공급 전압",
			SLEW_RATES: "Slew Rates",
			QUIESCENT_CURRENT: "Quiescent Current",
			RAIL_TO_RAIL: "레일 투 레일",
			RAIL2RAIL_IN: "In",
			RAIL2RAIL_OUT: "Out",
			RAIL2RAIL_INTO_VPLUS: "In to V+",
			RAIL2RAIL_INTO_VMINUS: "In to V-",
			LOW_NOISE: "저잡음 (≤ 10nV/√Hz)",
			LOW_OFFSET: "낮은 오프셋 (≤ 500µV)",
			LOW_POWER: "저전력 (≤ 500µA)",
			WIDE_BANDWIDTH: "광대역 (≥ 5MHz)",
			SMALL_FOOTPRINT: "작은 풋프린트 (≤ 9mm2)",
			OFFSET_VOLTAGE: "오프셋 전압",
			LOW_INPUT_BIAS: "낮은 입력 바이어스",
			SELECT_ONE: "None selected",
			POWER_MANAGEMENT_INTRO: "찾기 오른쪽 배터리 관리 제품 빠른.",
			BATTERY_CHEMISTRY: "Battery Chemistry",
			INPUT_VOLTAGE: "Input Voltage",
			REG_BATTERY_VOLTAGE: "Regulated Battery Voltage",
			CHARGE_CURRENT: "Charge Current",
			EXPAND_ALL: "모두 확장",
			COLLAPSE_ALL: "모두 축소",
			QUICKSEARCH_ARM: "ARM",
			QUICKSEARCH_FRAM: "FRAM",
			QUICKSEARCH_SMALL_PACKAGE: "소형 패키지 5x5mm2 미만이며",
			QUICKSEARCH_LARGE_MEMORY_DEVICES: "대용량 메모리 장치",
			QUICKSEARCH_CAPTIVATE_TT: "Captivate™ 터치 기술",
			QUICKSEARCH_USB: "USB",
			QUICKSEARCH_LCD: "LCD",
			QUICKSEARCH_BEST_ACTIVE_PWR: "능동 전력",
			QUICKSEARCH_BEST_STANDBY_PWR: "최고의 대기 전력",
			QUICKPARAMETERS_CAPACITIVE: "커패시티브 휠, 버튼, 슬라이더",
			QUICKPARAMETERS_ACCEL_PROCESSING: "가속 처리",
			QUICKPARAMETERS_BGA_PKGS: "다이 크기의 BGA 패키지",
			QUICKPARAMETERS_ENHANCED_SECURITY: "향상된 보안 기능",
			QUICKPARAMETERS_SYS_STATE_RETENTION: "시스템 상태 보존을 통해 전원 장애 시",
			QUICKPARAMETERS_FEATURED_MCU: "주요 기능에 의해 마이크로컨트롤러",
			QUICKSEARCH_NUMBER_CORES: "Number of cores",
			QUICKSEARCH_DSP_SPEED: "DSP Speed",
			QUICKSEARCH_TOTAL_CACHE: "Total On-Chip Memory",
			QUICKPARAMETERS_SINGLE_CORE: "싱글코어 DSP",
			QUICKPARAMETERS_HI_PERF_DSP: "고성능 DSP",
			QUICKPARAMETERS_HI_SPEED_INTERFACES: "고속 인터페이스",
			QUICKPARAMETERS_FLOAT_PT_DSP: "부동 소수점 DSP",
			QUICKPARAMETERS_EXT_TEMP_DEVICES: "폭넓은 온도 디바이스",
			QUICKPARAMETERS_HIGH_SUPPLY_VOLTAGE: "High Supply Voltage (> 6V)",
			QUICKPARAMETERS_LOW_SUPPLY_VOLTAGE: "Low Supply Voltage (<= 6V)",
			QUICKPARAMETERS_AUTO_QUALIFIED: "차량용 등급 인증 (AEC-Q100)",
			QUICKPARAMETERS_LOW_OFFSET_VOLTAGE: "Low Offset Voltage (<=500µV)",
			QUICKPARAMETERS_LOW_QUIE_CURRENT: "Low Quiescent Current (<=500µA)",
			QUICKPARAMETERS_LOW_NOISE_DENSITY: "Low Noise Density (≤ 10nV/√Hz)",
			INTRO_TEXT: "TI가 데스크톱과 태블릿에서 모두 사용할 수 있는 파라메트릭 선택 툴을 업데이트했습니다",
			INTRO_LINK: "새로운 기능 알아보기",
			QUICKPARAMETERS_HIREL_DESCRIPTION: "Find high reliability parts specific to your industry",
			QUICKPARAMETERS_SPACE: "Space",
			QUICKPARAMETERS_ENHANCED_PRODUCTS: "Enhanced Products",
			QUICKPARAMETERS_HIGH_TEMPERATURE: "Hermetic / High Temperature",
			QUICKPARAMETERS_PRODUCT_CAT: "Product Category",
			QUICKPARAMETERS_PRODUCT_SUBCAT: "product Sub-Category",
			QUICKPARAMETERS_AUTOMOTIVE: "오?? 모티브",
			QUICKPARAMETERS_CATALOG: "카탈로그",
			QUICKPARAMETERS_COSTOPTIMIZED: "최? ?화된 비용",
			QUICKPARAMETERS_HIGHACCURACY: "높은 ? ?밀도",
			QUICKPARAMETERS_LOWPOWER: "저전력",
			QUICKPARAMETERS_NONBGA: "NON-BGA",
			QUICKPARAMETERS_PACKAGETYPE: "패키지 ?? 형?",
			QUICKPARAMETERS_SMALLPACKAGE: "소형 패키지",
			QUICKPARAMETERS_RATING: "등급",
			QUICKPARAMETERS_KEYDESIGNNEED: "설계에 필요한 핵심이 무엇입니까?",
			WEBENCH_INPUT: "Select either Nominal or Min/Max Vin.",
			WEBENCH_OUTPUT: "Output",
			WEBENCH_OUTPUT1: "Specify Output #1",
			WEBENCH_OUTPUT2: "Specify Output #2",
			WEBENCH_ONE_OUT: "One output",
			WEBENCH_TWO_OUT: "Two outputs",
			WEBENCH_V_OUT: "Vout",
			WEBENCH_I_OUT: "Iout",
			WEBENCH_OUTPUT_ERR: "Error: you have selected two outputs, but have only completed one.",
			WEBENCH_WHAT: "What are WEBENCH® recommended parts?",
			WEBENCH_V_NOMINAL: "Vin Nominal",
			WEBENCH_V_MIN: "Vin Min",
			WEBENCH_VIN: "Vin",
			WEBENCH_V_MAX: "Vin Max",
			QUICKPARAMETERS_AUTOMOTIVE: "오토모티브",
			QUICKPARAMETERS_CATALOG: "카탈로그",
			QUICKPARAMETERS_COSTOPTIMIZED: "최적화된 비용",
			QUICKPARAMETERS_HIGHACCURACY: "높은 정밀도",
			QUICKPARAMETERS_LOWPOWER: "저전력",
			QUICKPARAMETERS_NONBGA: "NON-BGA",
			QUICKPARAMETERS_PACKAGETYPE: "패키지 유형?",
			QUICKPARAMETERS_SMALLPACKAGE: "소형 패키지",
			QUICKPARAMETERS_RATING: "등급",
			QUICKPARAMETERS_QP1: "TI가 아닌",
    		QUICKPARAMETERS_QP2:"온도 센서를 대체하기 위한",
    		QUICKPARAMETERS_QP3: "상호 참조 검색 실행",
    		QUICKPARAMETERS_OPTIMIZED_CABLES_PROBES: "케이블/프로브에 최적화",
    		QUICKPARAMETERS_V18_CAPABLE: "1.8V 지원",
    		QUICKPARAMETERS_INTEGRATED_POWER_MONITORING: "통합 전원 모니터링",
    		QUICKPARAMETERS_FACTORY_PRESET: "공장 사전 설정",
    		QUICKPARAMETERS_PIN_CONFIGURABLE: "핀 구성 가능",
    		QUICKPARAMETERS_RESISTOR_PROGRAMMABLE: "저항 프로그래머블",
    		QUICKPARAMETERS_DUAL_TRIP_POINTS: "이중 정지점",
    		QUICKPARAMETERS_THRUHOLE: "스루홀",
    		QUICKPARAMETERS_SMALL_NONBGA: "소형 Non-BGA",
    		QUICKPARAMETERS_P2P: "점대점(최대 2미터)",
    		QUICKPARAMETERS_DAISY_CHAIN: "데이지 체인(최대 300미터)",
    		QUICKPARAMETERS_LOOK_FOR: "무엇을 찾고 계신가요?",
    		QUICKPARAMETERS_INTERFACE_TYPE: "인터페이스 유형은 무엇입니까?",
    		QUICKPARAMETERS_PACKAGE_TYPE: "어떤 패키지 그룹을 선택하시겠습니까?",
    		QUICKPARAMETERS_TOPOLOGY: "토폴로지",
    		QUICKPARAMETERS_CROSS_REF: "http://" + newDomains["en"] + "/sensing-products/temperature-sensors/cross-reference.html",
    		QUICKPARAMETERS_ALERT_MSG: "설계 요구 사항에 대한 몇 가지 질문에 대답하고 가장 적절한 온도 센서를 찾아보십시오..",
    		QUICKPARAMETERS_OPTIMIZED_CABLES_PROBES: "케이블/프로브에 최적화",
    		QUICKPARAMETERS_LOW_TEMP_SENSOR_SINGLE_CHANNEL: "로컬 온도 센서(싱글 채널)",
    		QUICKPARAMETERS_SWITCHES_THERMOSTATS: "스위치/서모스탯",
    		QUICKPARAMETERS_REMOTE_TEMP_SENSOR_MULTI_CHANNEL: "스위치/서모스탯",
    		QUICKPARAMETERS_CABLES_PROBES: "케이블/프로브",
    		QUICKPARAMETERS_HIGH_CHANNEL_COUNT: "많은 채널 수",
    		QUICKPARAMETERS_PACKAGE: "패키지",
    		QUICKPARAMETERS_SELECT: "- 선택 -",

			//LDO
			//DEVICE_GRADE: "Device Grade",
			LDO_CQS_AJUSTABLE_OUTPUT: "조정 가능한 출력",
			LDO_CQS_ALL_GRADES: "모든 등급",
			LDO_CQS_ALL_OUTPUT_TYPE: "모든 출력 유형",
			LDO_CQS_ALL_SMALL_PACKAGE: "소형 패키지",
			LDO_CQS_AUTOMOTIVE_GRADE: "오토모티브(AEC-Q100) 등급",
			LDO_CQS_ENHANCED_PERFORMACE_GRADE: "향상된 성능 등급",
			LDO_CQS_IOUT_LABEL_1: "Iout 값이 정상입니다.",
			LDO_CQS_IOUT_LABEL_2: "Iout이 0.0001A보다 크고 50A보다 작아야 합니다.",
			LDO_CQS_IOUT_LABEL_3: "LDO는 전류만 공급할 수 있습니다. 양극 IOUT 값을 사용해 보세요.",
			LDO_CQS_IOUT_LABEL_4: "Iout이 0보다 커야 합니다.",
			LDO_CQS_INPUT: "입력",
			LDO_CQS_FIXED_OUTPUT: "고정 출력",
			LDO_CQS_PROGRAM_OUTPUT: "프로그래머블 출력",
			LDO_CQS_SEARCH_LABEL_1: "Vin, Vout 및 Iout에 값을 입력하세요.",
			LDO_CQS_SEARCH_LABEL_2: "일치하는 제품을 찾지 못했습니다. 매개 변수 값과 주요 기능 및 디바이스 등급 필터를 변경해 보세요",
			LDO_CQS_SEARCH_LABEL_3: "LDO에는 조정을 위한 적절한 VIN – VOUT 헤드룸이 필요합니다. 입력 전압을 변경해 보세요.",
			LDO_CQS_SEARCH_LABEL_4: "이러한 입력과 일치하는 LDO를 찾지 못했습니다. IoutMax, Vin 또는 Vout을 변경해 보세요.",
			LDO_CQS_VOUT_LABEL_1: "Vin이 NaN입니다!",
			LDO_CQS_VOUT_LABEL_2: "Vout이 NaN입니다!",
			LDO_CQS_VOUT_LABEL_3: "LDO가 입력 전압을 승압할 수 없습니다. 입력 또는 출력 전압을 변경해 보세요.",
			LDO_CQS_VOUT_LABEL_4: "확인. 양극 LDO 검색...",
			LDO_CQS_VOUT_LABEL_5: "확인. 음극 LDO 검색...",
			LDO_CQS_VOUT_LABEL_6: "Vout이 Vin보다 커야 합니다.",
			LDO_CQS_VOUT_LABEL_7: "LDO가 입력 전압을 인버팅할 수 없습니다. 입력 및 출력 전압의 극성을 일치시켜 보세요.",
			LDO_CQS_VOUT_LABEL_8: "하나 이상의 기능을 선택해 입력 범위를 좁혀 보세요.",
			LDO_CQS_VOUT_LABEL_9: "노이즈에 민감한 애플리케이션",
			LDO_CQS_VOUT_LABEL_11: "Vin, Vout 및 Iout에 값을 입력하세요.",
			LDO_CQS_VOUT_LABEL_12: "Iout이 0보다 커야 합니다.",
			QUICKPARAMETERS_TITLE: "주요 기능",

			//Strings for Clock Oscillator CQS
			CO_CQS_OSCILLATOR_TYPE: "오실레이터 유형",
			CO_CQS_STABILITY:	"안정성",
			CO_CQS_VIEW:	"보기",
			CO_CQS_PARTS:	"부품",
			CO_CQS_PIN_SELECTABLE:	"핀 선택 가능",
			CO_CQS_PROGRAMMABLE:	"EEPROM으로 프로그래밍 가능",
			CO_CQS_OUTPUT_FORMAT:	"출력 형식",
			CO_CQS_HCSL:	"HCSL",
			CO_CQS_LVCMOS:	"LVCMOS",
			CO_CQS_LVDS:	"LVDS",
			CO_CQS_LVPECL:	"LVPECL",
			CO_CQS_STANDARD:	"표준",
			CO_CQS_FREQUENCY:	"주파수",
			CO_CQS_PACKAGE:	"패키지",
			CO_CQS_CUSTOM:	"맞춤형",
			CO_CQS_REQUEST_SAMPLES:	"맞춤형 샘플 요청",
			CO_CQS_FORM_REQUEST_CO:	"맞춤형 오실레이터 요청",
			CO_CQS_FORM_ORDER_CUSTOM_FREQ:	"맞춤형 주파수 오실레이터 주문",
			CO_CQS_FORM_ULTRA_LOW_JITTER:	"10MHz~1GHz의 주파수에 적합한 초저지터 오실레이터 모든 크기의 프로젝트 - 1-2주 이내에 샘플 도착!",
			CO_CQS_FORM_WHY_ORDER_CUSTOM_OSC:	"맞춤형 오실레이터를 주문하는 이유",
			CO_CQS_FORM_SIMPLE_SAMPLES:	"어떠한 타협도 없이 시스템에 필요한 정확한 주파수를 간단하고 빠르게 얻을 수 있습니다. 간단한 샘플입니다!",
			CO_CQS_FORM_STEPS:	"프로세스의 단계",
			CO_CQS_FORM_STEP1:	"여기 양식에 해당 정보를 입력하고 제출",
			CO_CQS_FORM_STEP2:	"최대 x조각의 샘플 요청",
			CO_CQS_FORM_STEP3:	"당사의 대리점을 통해 주문 제작한 소량 주문 수량",
			CO_CQS_FORM_STEP4:	"TI에서 직접 주문 제작한 대량 주문 수량",
			CO_CQS_FORM_COMPLETE_FORM:	"샘플을 받으려면 아래 양식을 작성하십시오.",
			CO_CQS_FORM_CUSTOMER_NAME:	"고객 이름",
			CO_CQS_FORM_COMPANY_NAME:	"회사명",
			CO_CQS_FORM_EMAIL:	"이메일 주소",
			CO_CQS_FORM_PHONE:	"전화",
			CO_CQS_FORM_REQ_FREQUNECY:	"요청한 주파수(MHz)",
			CO_CQS_FORM_COMMENT:	"설명",
			CO_CQS_FORM_DETAILS:	"세부 정보",
			CO_CQS_FORM_CANCEL:	"취소",
			CO_CQS_FORM_SUBMIT:	"요청 제출",
			CO_CQS_FORM_FIELD:	"이 필드를 작성하십시오."
		}

	};

	this.langURLs = {
		CN: {
			AUTOQS: "/assets/js/selectiontool/automatedQS/",
			BETA_SURVEY: "https://s2.userzoom.com/m/MSBDMTU3Uzgx",
			DATA_SERVICE: "/wsapi/paramdata/family/!!familyId!!/!!type!!?lang=!!lang!!&output=json",
			EXPORT_SERVICE: "/wsapi/download",
			FUNCTDIAGRAMS: "/ds_dgm/images/",
			FUNCTTHUMBS: "/ds_dgm/thumbnails/",
			DATASHEET: "/cn",
			ODS: "",
			PARTIMAGES: "/graphics/folders/partimages/",
			PRODUCTDETAILS: "",
			PRODUCTFOLDER_BASE: "/product/cn",
			QS: "/assets/js/selectiontool/qs/",
			QUALITYPKG: "",
			REST: "/foldercomponents/docs/comp/restResponse.tsp?uiTemplateId=REST_RST_T&param=familyId~!!familyId!!",
			SAMPLEBUY: "",
			SERVER_BASE: "//" + newDomains["cn"] + "",
			SUPPORT: "",
			TECHDOCS: "",
			TI_BASE: "//" + newDomains["cn"] + "",
			TOOLSSOFT: "",
			WBJS: "https://webench.ti.com/webench5/pf/templates/wbparametric.min.js",
			WBCSS: "//" + newDomains["en"] + "/assets/css/com.ti.webench.panel.css?versionNumber=1.1"
		},

		DE: {
			AUTOQS: "/assets/js/selectiontool/automatedQS/",
			BETA_SURVEY: "https://s2.userzoom.com/m/MSBDMTU3Uzgx",
			DATA_SERVICE: "/wsapi/paramdata/family/!!familyId!!/!!type!!?lang=!!lang!!&output=json",
			EXPORT_SERVICE: "/wsapi/download",
			FUNCTDIAGRAMS: "/ds_dgm/images/",
			FUNCTTHUMBS: "/ds_dgm/thumbnails/",
			DATASHEET: "",
			ODS: "",
			PARTIMAGES: "/graphics/folders/partimages/",
			PRODUCTDETAILS: "",
			PRODUCTFOLDER_BASE: "/product",
			QS: "/assets/js/selectiontool/qs/",
			QUALITYPKG: "",
			REST: "/foldercomponents/docs/comp/restResponse.tsp?uiTemplateId=REST_RST_T&param=familyId~!!familyId!!",
			SAMPLEBUY: "",
			SERVER_BASE: "//" + newDomains["en"],
			SUPPORT: "",
			TECHDOCS: "",
			TI_BASE: "//" + newDomains["en"],
			TOOLSSOFT: "",
			WBJS: "https://webench.ti.com/webench5/pf/templates/wbparametric.min.js",
			WBCSS: "//" + newDomains["en"] + "/assets/css/com.ti.webench.panel.css?versionNumber=1.1"
		},

		EN: {
			AUTOQS: "/assets/js/selectiontool/automatedQS/",
			BETA_SURVEY: "https://s2.userzoom.com/m/MSBDMTU3Uzgx",
			DATA_SERVICE: "/wsapi/paramdata/family/!!familyId!!/!!type!!?lang=!!lang!!&output=json",
			EXPORT_SERVICE: "/wsapi/download",
			FUNCTDIAGRAMS: "/ds_dgm/images/",
			FUNCTTHUMBS: "/ds_dgm/thumbnails/",
			DATASHEET: "",
			ODS: "",
			PARTIMAGES: "/graphics/folders/partimages/",
			PRODUCTDETAILS: "",
			PRODUCTFOLDER_BASE: "/product",
			QS: "/assets/js/selectiontool/qs/",
			QUALITYPKG: "",
			REST: "/foldercomponents/docs/comp/restResponse.tsp?uiTemplateId=REST_RST_T&param=familyId~!!familyId!!",
			SAMPLEBUY: "",
			SERVER_BASE: "//" + newDomains["en"],
			SUPPORT: "",
			TECHDOCS: "",
			TI_BASE: "//" + newDomains["en"],
			TOOLSSOFT: "",
			WBJS: "https://webench.ti.com/webench5/pf/templates/wbparametric.min.js",
			WBCSS: "//" + newDomains["en"] + "/assets/css/com.ti.webench.panel.css?versionNumber=1.1"
		},

		JP: {
			AUTOQS: "/assets/js/selectiontool/automatedQS/",
			BETA_SURVEY: "https://s2.userzoom.com/m/MSBDMTU3Uzgx",
			DATA_SERVICE: "/wsapi/paramdata/family/!!familyId!!/!!type!!?lang=!!lang!!&output=json",
			EXPORT_SERVICE: "/wsapi/download",
			FUNCTDIAGRAMS: "/ds_dgm/images/",
			FUNCTTHUMBS: "/ds_dgm/thumbnails/",
			DATASHEET: "/jp",
			ODS: "",
			PARTIMAGES: "/graphics/folders/partimages/",
			PRODUCTDETAILS: "",
			PRODUCTFOLDER_BASE: "/product/jp",
			QS: "/assets/js/selectiontool/qs/",
			QUALITYPKG: "",
			REST: "/foldercomponents/docs/comp/restResponse.tsp?uiTemplateId=REST_RST_T&param=familyId~!!familyId!!",
			SAMPLEBUY: "",
			SERVER_BASE: "//" + newDomains["jp"] + "",
			SUPPORT: "",
			TECHDOCS: "",
			TI_BASE: "//" + newDomains["jp"] + "",
			TOOLSSOFT: "",
			WBJS: "https://webench.ti.com/webench5/pf/templates/wbparametric.min.js",
			WBCSS: "//" + newDomains["en"] + "/assets/css/com.ti.webench.panel.css?versionNumber=1.1"
		},

		KR: {
			AUTOQS: "/assets/js/selectiontool/automatedQS/",
			BETA_SURVEY: "https://s2.userzoom.com/m/MSBDMTU3Uzgx",
			DATA_SERVICE: "/wsapi/paramdata/family/!!familyId!!/!!type!!?lang=!!lang!!&output=json",
			EXPORT_SERVICE: "/wsapi/download",
			FUNCTDIAGRAMS: "/ds_dgm/images/",
			FUNCTTHUMBS: "/ds_dgm/thumbnails/",
			DATASHEET: "",
            ODS: "",
			PARTIMAGES: "/graphics/folders/partimages/",
			PRODUCTDETAILS: "",
			PRODUCTFOLDER_BASE: "/product",
			QS: "/assets/js/selectiontool/qs/",
			QUALITYPKG: "",
			REST: "/foldercomponents/docs/comp/restResponse.tsp?uiTemplateId=REST_RST_T&param=familyId~!!familyId!!",
			SAMPLEBUY: "",
			SERVER_BASE: "//" + newDomains["en"],
			SUPPORT: "",
			TECHDOCS: "",
			TI_BASE: "//" + newDomains["en"],
			TOOLSSOFT: "",
			WBJS: "https://webench.ti.com/webench5/pf/templates/wbparametric.min.js",
			WBCSS: "//" + newDomains["en"] + "/assets/css/com.ti.webench.panel.css?versionNumber=1.1"
		}
	}

	this.quickSearches = {
		"space_hirel": "hirel",
		// 72: "NO_QS",  // any string not matching a qs will disable custom and auto qs for that familyid
		78: "amp",
		400: "ldo",
		490: "buck",
		1293: "opAmp",
		1986: "dsp-c6",
		3054: "led",
		3170: "current-sense-amp",
		3172: "current-sense-amp",
		3173: "current-sense-amp",
		3174: "current-sense-amp",
		409: "gate-drivers",
		3392: "gate-drivers",
		3393: "gate-drivers",
		3125: "gate-drivers",
		433: "boost",
		2137: "boost",
		752: "boost",
		756: "boost",
		3386: "clock-oscillator"
	};

	var langStore = this;

	// get single string for language
	langStore.langString = function(language, thisString, tokenVals) {
		var resultString = 'STRINGNOTFOUND';

		if (langStore.langStrings[language][thisString]) {
			resultString = langStore.langStrings[language][thisString];

			if (tokenVals) {
				// do replacements - $0.10 version for now
				// TODO: tokenVals.each(key, val)
				if (tokenVals.x) {
					resultString = resultString.replace('!!X!!', tokenVals.x);
				}

				if (tokenVals.y) {
					resultString = resultString.replace('!!Y!!', tokenVals.y);
				}
			}
		}

		return resultString;
	};

	// get single string
	langStore.string = function(thisString, tokenVals) {
		return langStore.langString(langStore.language, thisString, tokenVals);
	};

	// set language
	langStore.setLanguage = function(lang) {

		if (lang) {
			lang = lang.toUpperCase();

			if (com.TI.util.inArray(lang, langStore.languages) >= 0) {
				langStore.language = lang;
			} else {
				langStore.language = 'EN';
			}
		}

		return langStore.language;
	};

	Object.defineProperty(langStore, 'strings', {
		get: function() { return langStore.langStrings[langStore.language] }
	});

	Object.defineProperty(langStore, 'URLs', {
		get: function() { return langStore.langURLs[langStore.language] }
	});


	// just in case
	// TODO: for some reason this doesnt fire properly
	if (RiotControl) {
		RiotControl.on('language-change', function(lang) {
			langStore.setLanguage(lang);
		});
	}

	// can I do this as part of the init?
	// init with language choice
	if (lang) {
		langStore.setLanguage(lang);
	};

	// howbout this?
	// return string object only on init
	if (stringsonly) {
		return {strings: langStore.langStrings[langStore.language], URLs: langStore.langURLs[langStore.language]};
	}
};

com.TI.util.nsExtend(window, "com.TI.rst.storeDef");

com.TI.rst.storeDef.PartStore = function () {
	riot.observable(this);
	var self = this;
	//riot.observable(self);

	var utils = com.TI.util;

	var indexRows,
		indexCols;

	var _familyId = "",
		_lang = "",
		_masterHeader = [],
		_masterBody = [],
		_allParts = [],
		_colOrder = [],
		_itemsPerLoad = 0,
		_filteredParts = [],
		_foundParts = [],
		_lastQuery = {},
		_newCols = [],
		_partsSelected = [],
		_metrics,
		_sort = {};

	var dataTablePrefix = "ti_data_table_",
		filterPrefix = "ti_filters_",
		collapsPrefix = "ti_collapsible";

	self.lastQuery = function () {
		return _lastQuery;
	};

	function initColOrder(colIndex, totalCols) {
		var cid, order;
		order = ["o1"]; //might as well initialize this with the o1 by default
		if (colIndex["o7"]) order.push("o7");
		for (cid in colIndex) {
			if (colIndex[cid].type !== "O") order.push(cid);
			if (order.length === totalCols) break;
		}
		if (colIndex["o4"] && (order.length < totalCols)) order.push("o4");
		return order;
	}

	function initParts(parts) {
		var k, partArr;
		partArr = [];
		for (k in parts) {
			if (parts.hasOwnProperty(k)) {
				partArr.push(parts[k]);
			}
		}
		return partArr;
	}

	function makeHeader(colIndex, order, modCols) {
		var i, len, header, cid, tmpColData, tmpHeaderText, tmpSort;
		header = [];
		len = order.length;
		for (i = 0; i < len; i++) {
			cid = order[i];
			tmpColData = colIndex[cid];
			if (cid === "o1") {
				tmpHeaderText = "Part Number";
				tmpSort = "noSort";
			} else {
				tmpHeaderText = tmpColData.name;
				if (tmpColData.attribute !== undefined) tmpHeaderText += " (" + tmpColData.attribute + ")";
				if (tmpColData.units !== undefined) tmpHeaderText += " (" + tmpColData.units + ")";
				if (cid === "p1811") tmpHeaderText = tmpHeaderText.replace("<sup>", "").replace("</sup>", "");
				if (_sort.cid !== undefined && _sort.cid === cid) tmpSort = _sort.dir;
				else tmpSort = "";
			}
			header.push({
				cid: cid,
				field: tmpHeaderText,
				sort: tmpSort,
				justAdded: utils.inArray(cid, modCols) > -1
			});
		}
		modCols = [];
		return header;
	}

	function makeBody(parts, order) {
		var i, j, rowsLen, colsLen, body, cid, currentPart, cVals, tmpVal;
		body = [];
		rowsLen = parts.length;
		colsLen = order.length;

		for (i = 0; i < rowsLen; i++) {
			currentPart = parts[i];
			body.push([]);
			for (j = 0; j < colsLen; j++) {
				cid = order[j];

				var cleanDesc = utils.convertASCII(currentPart["o3"]);
				if (cid === "o1") {
					body[i].push({
						tag: "ti-rst-cell",
						label: currentPart["o1"],
						qgpn: currentPart["o2"],
						desc: cleanDesc, //currentPart["o3"],
						pstatus: currentPart["o4"],
						hirel: currentPart["o8"],
						newPart: currentPart["o9"],
						image: currentPart["o10"],
						ods: currentPart["o14"]
					});
				} else if (cid === "p2954" || cid === "p1811") {
					cVals = currentPart[cid];
					tmpVal = fixArray(cVals);
					//=== does not work for covering this case
					//if tmpVal is blank, a class will be applied to see
					//the TI dash in the table
					if(tmpVal == '' || tmpVal == ' '){
						body[i].push('');
					}
					else{
						body[i].push({
							textValues: tmpVal,
							tag: "ti-rst-simple-cell",
							qgpn: currentPart["o2"],
							ods: currentPart["o14"],
							cid: cid
						});
					}
				} else {
					cVals = currentPart[cid];
					tmpVal = flattenArr(cVals);
					body[i].push(tmpVal);
				}
			}
		}
		return body;
	}

	function flattenArr(arr) {
		var i, len, ret, tmpArr;
		if (arr === undefined) arr = [""];
		if (typeof arr[0] === "object") { //is multipair, one or many
			tmpArr = [];
			len = arr.length;
			for (i = 0; i < len; i++) tmpArr.push(arr[i].l);
			ret = tmpArr.join(",\n");
		} else if (arr.length > 1) { //multi value
			ret = arr.join(",\n");
		} else { //single val or empty space
			ret = arr[0];
		}
		return ret;
	}

	function fixArray(input) {
		var i, len, output, tmpArr;
		if (input === undefined) input = [""];
		if (typeof input[0] === "object") { //is multipair, one or many
			tmpArr = [];
			len = input.length;
			for (i = 0; i < len; i++) tmpArr.push(input[i].l);
			output = tmpArr;
		} else {
			output = input;
		}
		return output;
	}

	function filter(q, data) {
		if (q === undefined) q = {};
		if (data === undefined) data = _allParts;

		var match,
			matchingParts = [],
			i, partLen, tmpPart;

		partLen = data.length;

		for (i = 0; i < partLen; i++) {
			tmpPart = data[i];
			match = partMatchesQuery(q, tmpPart);
			if (match) matchingParts.push(tmpPart);
		}

		return matchingParts;

	}

	function partMatchesQuery(q, part) {
		var match = true,
			cid,
			type,
			vals,
			col;
		for (cid in q) {
			//right now everything will be considered a checkbox
			//todo: have to work on this when sliders get implemented
			//object looks like this:
			//cid: {type:"or/and/not/range", values:[]}
			if (q.hasOwnProperty(cid)) {
				col = q[cid];
				type = col.type;
				vals = col.values;
				var i,
					len = part[cid].length,
					tmpArrVals = [];
				if (typeof part[cid][0] !== "object") tmpArrVals = part[cid];
				else {
					for (i = 0; i < len; i++) tmpArrVals.push(part[cid][i].v);
				}
				if (type === "OR") {
					match = matchOr(vals, tmpArrVals);
				} else if (type === "AND") {
					match = matchAnd(vals, tmpArrVals);
				} else if (type === "NOT") {
					match = !matchOr(vals, tmpArrVals);
				} else if (type === "RANGE") {
					match = matchRange(vals, tmpArrVals);
				} else if (type === "DROPDOWNMIN") {
					match = matchDropDownDataMin(vals, tmpArrVals);
				} else if (type === "DROPDOWNMAX") {
					match = matchDropDownDataMax(vals, tmpArrVals);
				} else if (type === "TEMPRANGE") {
					match = matchTempRange(vals, tmpArrVals);
				} else if (type === "OPTEMPRANGE") {
					match = matchOperatingTempRange(vals, tmpArrVals);
				} else if (type === "CUSTOM") {
					if(typeof q[cid]["filter"] === "function") {
						match = q[cid]["filter"](q,part);
					}
				}
				if (!match) break;
			}
		}
		return match;
	}

	function matchOr(filterVals, partVals) {
		//where filterVals is supposed to be the values inputed by user
		//partVals is all the values available for this part
		var ret = false,
			len = filterVals.length,
			i;
		for (i = 0; i < len; i++) {
			if (utils.inArray(filterVals[i], partVals) > -1) {
				ret = true;
				break;
			}
		}
		return ret;
	}

	function matchAnd(filterVals, partVals) {
		var ret = true,
			len = filterVals.length,
			i;
		for (i = 0; i < len; i++) {
			if (utils.inArray(filterVals[i], partVals) === -1) {
				ret = false;
				break;
			}
		}
		return ret;
	}

	function matchRange(filterVals, partVals) {
		var min = filterVals[0],
			max = filterVals[1],
			len = partVals.length,
			i,
			cVal;

		for (i = 0; i < len; i++) {
			cVal = partVals[i];
			if (!isNaN(min) && !isNaN(max) && Number(cVal) >= Number(min) && Number(cVal) <= Number(max)) return true;
		}

		return false;
	}

	function matchOperatingTempRange(filterVals, partVals) {
		var min = filterVals[0],
			max = filterVals[1],
			len = partVals.length,
			i,
			cVal;

		for (i = 0; i < len; i++) {
			if (partVals[i].indexOf(":") > 0)
			{
				cValMin = partVals[i].split(":")[0];
				cValMax = partVals[i].split(":")[1];
				if (!isNaN(min) && !isNaN(max) && Number(cValMin) <= Number(min) && Number(cValMax) >= Number(max)) {
					return true;
				}
			}
		}
		return false;
	}

	//Filter function for parsing max temp in temp range string. Example - -40 to 125.
	function matchTempRange(filterVals, partVals) {
		var tVal = filterVals[0],
			len = partVals.length,
			i,
			tMax;

		for (i = 0; i < len; i++) {
			tMax = parseFloat(partVals[i].match(/\d+$/)[0]);
			if (!isNaN(tMax) && Number(tVal) <= Number(tMax)) return true;
		}

		return false;
	}

	//Filter function for params with discrete values instead of range - min
	function matchDropDownDataMin(filterVals, partVals) {
		var val = filterVals[0],
			len = partVals.length,
			i,
			min = partVals[0];

		for (i = 0; i < len; i++) {
			if (!isNaN(min) && Number(val) >= Number(min)) return true;
		}

		return false;
	}

	//Filter function for params with discrete values instead of range - max
	function matchDropDownDataMax(filterVals, partVals) {
		var val = filterVals[0],
			len = partVals.length,
			i,
			max = partVals[0];

		for (i = 0; i < len; i++) {
			if (!isNaN(max) && Number(val) <= Number(max)) return true;
		}

		return false;
	}

	function columnChange(cid, action) {
		//cid of the column to de added/removed
		//action can be "add" or "delete"
		var colLoc = utils.inArray(cid, _colOrder),
			i,
			len = _colOrder.length,
			position,
			curOrder = indexCols[cid].order,
			tmpOrder;
		//var position = (pos === undefined) ? 1 : pos;
		if (action === "add" && colLoc === -1) {
			//determine position

			for (i = 0; i < len; i++) {
				tmpOrder = indexCols[_colOrder[i]].order;
				if (curOrder > tmpOrder) position = i + 1;
				else break;
			}
			_colOrder.splice(position, 0, cid);
			_newCols.push(cid);
			return position;
		} else if (action === "del" && colLoc > -1) {
			_colOrder.splice(colLoc, 1);
		}
	}

	function makeDownloadHeader() {
		var i,
			len = _masterHeader.length,
			ret = [],
			cid,
			colInfo,
			cellText;
		ret.push("<tr style='font-weight: bold;border:1px solid #E0E0E0'>");
		for (i = 0; i < len; i++) {
			cid = _masterHeader[i].cid;
			colInfo = indexCols[cid];
			//split o1 into part number and description
			if (cid === "o1") {
				cellText = "Part Number";
				cellText = "<th style='border: 1px solid Black;'>" + cellText + "</th>";
				ret.push(cellText);

				cellText = "Description";
			} else cellText = colInfo.name;

			if (!utils.isEmpty(colInfo.attribute)) cellText += " (" + colInfo.attribute + ")";
			if (!utils.isEmpty(colInfo.units)) cellText += " (" + colInfo.units + ")";

			cellText = "<th style='border: 1px solid Black;'>" + cellText + "</th>";
			ret.push(cellText);
		}
		ret.push("</tr>");
		return ret.join("");
	}

	function makeDownloadBody() {
		var i,
			len,
			ret = [];

		len = _masterBody.length;
		for (i = 0; i < len; i++) {
			ret.push("<tr style='border: 1px solid Black;'>");
			ret.push(makeDownloadRow(_masterBody[i]));
			ret.push("</tr>");
		}
		return ret.join("");
	}

	function makeDownloadRow(rowData) {
		var ret = rowData.slice(),
			i,
			len = rowData.length,
			prodLink = "http:" + com.TI.rst.langStore.URLs.TI_BASE + com.TI.rst.langStore.URLs.PRODUCTFOLDER_BASE + "/";

		ret[0] = "<a href='" + prodLink + rowData[0].qgpn + "'>" + rowData[0].label + "</a></td><td>" + rowData[0].desc;

		for (i = 0; i < len; i++) {
			if (typeof (ret[i]) == "object") {
				ret[i] = "<td>" + ret[i].textValues.join(", ") + "</td>"; // handle object sets (pkg group, etc)
			} else {
				ret[i] = "<td class='rsttext'>" + ret[i].toString().replace(/,\n/g, ", ") + "</td>"; // added toString() to be sure .replace was available
			}
		}
		ret = ret.join("");
		return ret;
	}

	function makeFilterInfo(filterData) {
		var i,
			len = filterData.length,
			cFilter,
			newFilterInfo = "<div>";

		for (i = 0; i < len; i++) {
			cFilter = filterData[i];

			if (cFilter.applied.length > 0) {
				newFilterInfo += "<div>";
				newFilterInfo += cFilter.label;
				newFilterInfo += ": ";
				if (cFilter.searchType === "RANGE") newFilterInfo += cFilter.applied[0] + " to " + cFilter.applied[1];
				else newFilterInfo += cFilter.applied.toString();
				newFilterInfo += "</div>";
			}
		}
		newFilterInfo += "</div>";
		newFilterInfo += "<div><a href='" + window.location.href + "'>View Selection Tool on TI.com</a></div><br>";
		return newFilterInfo;
	}

	function insertToColOrder(newCid, newCidOrder) {
		var i, len, currentCidOrder, tmpCid;
		len = _colOrder.length;
		for (i = 0; i < len; i++) {
			tmpCid = _colOrder[i];
			currentCidOrder = indexCols[tmpCid].order;
			if (currentCidOrder > newCidOrder) break;
		}
		//i is the new index of cid
		_colOrder.splice(i, 0, newCid);
	}

	function addNewColsOrder() {
		var i, len, cidOrderIndex, tmpCid, currentlyInUse;
		len = _newCols.length;

		for (i = 0; i < len; i++) {
			tmpCid = _newCols[i];
			cidOrderIndex = indexCols[tmpCid].order;
			currentlyInUse = utils.inArray(tmpCid, _colOrder) > -1;
			if (!currentlyInUse) insertToColOrder(tmpCid, cidOrderIndex);
		}
	}

	self.on("rst_init", function (params) {
		//console.log("rst init part store");
		var searchType = 'main';

		if (params.metricsMixin) _metrics = params.metricsMixin;
		indexCols = params.colDef;
		indexRows = params.partDef;
		_familyId = params.famId;
		_lang = params.lang;
		_colOrder = initColOrder(indexCols, params.initialNumber);
		_allParts = initParts(indexRows);
		_masterHeader = makeHeader(indexCols, _colOrder);
		_itemsPerLoad = params.stagger;
		_lastQuery = params.initialFilters;
		_standalone = (params.standalone !== undefined && (params.standalone === true || params.standalone === '' || params.standalone.toString().toLowerCase() === 'true') ? true : false);
		_pqsRef = params.pqsRef || 'n/a'; // was this referred from a pqs?

		if (!utils.isEmpty(params.initialFilters)) _masterBody = makeBody(filter(params.initialFilters), _colOrder);
		else _masterBody = makeBody(_allParts, _colOrder);

		_filteredParts = _masterBody.slice();

		self.trigger(dataTablePrefix + "pass_data", _masterHeader, _masterBody.slice(), _itemsPerLoad, _partsSelected);
		self.trigger(filterPrefix + "update_count", _masterBody.length, _allParts.length);
		self.trigger(filterPrefix + "update_prefilter_count", _masterBody.length);

		if (_standalone) {
			quicksearches = com.TI.rst.langStore.quickSearches;
			if (quicksearches[_familyId]) {
				searchType = 'pcqs';
			} else {
				searchType = 'paqs';
			};
		};

		var trackParams = {
			errorMsg: 'GA _tiAT init track error',
			familyId: _familyId,
			linkId: _pqsRef,
			searchType: searchType,
			trackType: "selection tool search"
		};

		_metrics.tiATrack(trackParams);

		self.trigger("qs_init", _lang, _familyId, indexCols, _allParts, _colOrder, filter, makeBody);
	});

	self.on("rst_apply", function (parts, query, cols2front, action, source) {
		self.trigger("rst_loading", true);
		//PSS-710
		_foundParts = [];
		self.trigger(dataTablePrefix + "clear_parts_filtered");

		var newCol = false,
			skipHashUpdate = false;
		//--tk: to retain sorting info for filtered result set
		if (action !== "apply") {
			_sort = {};
		}
		if (source !== undefined && source === "hash") skipHashUpdate = true;

		self.trigger(collapsPrefix + "reset_highlights");

		if (query !== undefined) _lastQuery = query;

		//reorder everything
		var inUseCols = ["o1"],
			unusedCols = [],
			highlightCols = [],
			i,
			len = _colOrder.length,
			tmpCid,
			tmpLoc,
			lastUsedIndex,
			lastUsedOrder;

		if (action === "quickLink" || action === "quickSearch" || action === "autoQuickSearch") { //remove this conditinal once column ordering is back
			//if cid is being used in filter, goes to 1st array
			//otherwise it goes to a second array with unused cid

			for (i = 1; i < len; i++) {
				tmpCid = _colOrder[i];
				if (_lastQuery[tmpCid] !== undefined) {
					inUseCols.push(tmpCid);
					highlightCols.push(tmpCid);
				} else unusedCols.push(tmpCid);
			}

			//now we check the query. if a cid is in use, we add it to first array
			for (tmpCid in _lastQuery) {
				if (_lastQuery.hasOwnProperty(tmpCid)) {
					tmpLoc = utils.inArray(tmpCid, _colOrder);
					if (tmpLoc === -1) {
						lastUsedIndex = inUseCols.length - 1;
						lastUsedOrder = indexCols[inUseCols[lastUsedIndex]]["order"];
						indexCols[inUseCols[lastUsedIndex]]["order"] = lastUsedOrder + 1;
						inUseCols.push(tmpCid);
						_newCols.push(tmpCid);
					}
				}
			}

			//marking newCol as true to force redraw, given some column is bound to be moved
			newCol = true;

			//add both arrays and you have the new column order
			_colOrder = [].concat(inUseCols, unusedCols);

		} //remove this conditinal once column ordering is back

		//make sure cids used in filter are on colOrder
		for (tmpCid in _lastQuery) {
			if (_lastQuery.hasOwnProperty(tmpCid)) {
				tmpLoc = utils.inArray(tmpCid, _colOrder);
				if (tmpLoc === -1) {
					_newCols.push(tmpCid);
					highlightCols.push(tmpCid);
					newCol = true;
				}
			}
		}
		if (_newCols.length > 0) addNewColsOrder();

		//pass this to filter store
		RiotControl.trigger("rst_col_filter_change", _newCols);

		if (!skipHashUpdate) self.trigger("rst_update_hash", _lastQuery);

		if (parts !== undefined && parts.length > 0) _filteredParts = parts;

		if (newCol) _filteredParts = makeBody(filter(_lastQuery), _colOrder);
		_masterBody = _filteredParts.slice();
		_masterHeader = makeHeader(indexCols, _colOrder, highlightCols);

		_newCols = [];

		if (action !== undefined) _metrics.trackApply(action, _filteredParts.length, _lastQuery);

		_partsSelected = [];
		self.trigger(dataTablePrefix + "pass_data", _masterHeader, _masterBody.slice(), null, _partsSelected);
		self.trigger(filterPrefix + "update_count", _masterBody.length);
		//--tk: to restore column sorting that is getting lost upon filtering (if action=apply)
		if (action === "apply" && _sort.cid != null) {
			RiotControl.trigger("rst_sort_filtered", _sort.cid, _sort.dir, _sort.isByV);
		}
	});

	self.on("rst_filter", function (q, data) {
		//console.log("rst filter");
		_filteredParts = makeBody(filter(q, data), _colOrder);
		_lastQuery = q;
		_metrics.trackFilter(_lastQuery, _filteredParts.length);
		RiotControl.trigger(filterPrefix + "update_prefilter_count", _filteredParts.length);
	});

	self.on("rst_column_change", function (cid, action, q) {

		columnChange(cid, action);

		_newCols = [];
		_lastQuery = q;
		_filteredParts = makeBody(filter(q), _colOrder);
		//update body and head data
		_masterBody = _filteredParts.slice();
		_masterHeader = makeHeader(indexCols, _colOrder, _newCols);
		//update count and table
		self.trigger(dataTablePrefix + "pass_data", _masterHeader, _masterBody.slice());
		RiotControl.trigger(filterPrefix + "update_prefilter_count", _filteredParts.length);
		//metrics
		_metrics.trackShowHideCol(_colOrder.toString());
	});

	self.on("rst_sort_filtered", function (cid, dir) {
		//loop through header
		//clean up the "sort" property in all but
		//the one where cid matches
		//check current direction and decide if down or up is next
		//_masterHeader is attached to table so no need to pass data
		var i,
			len = _masterHeader.length,
			loopCid,
			sortedParts,
			sortbyIndex,
			sortByProp = "",
			sortType = "",
			isSortByV = true;

		for (i = 0; i < len; i++) {
			loopCid = _masterHeader[i].cid;
			if (loopCid !== cid) _masterHeader[i].sort = "";
			else {
				sortbyIndex = i;
				sortByProp = loopCid;
				if (loopCid === "p1811") isSortByV = false;
				_masterHeader[i].sort = dir;
				sortType = _masterHeader[i].sort;
			}
		}

		if (_foundParts.length < 1) {
			sortedParts = _allParts.slice().sort((utils.sortArrayByProp)(sortByProp, sortType, isSortByV));
		} else {
			sortedParts = _foundParts.slice().sort((utils.sortArrayByProp)(sortByProp, sortType, isSortByV));
		}

		_metrics.trackSort(cid);
		_partsSelected = [];
		_masterBody = makeBody(filter(_lastQuery, sortedParts), _colOrder);
		self.trigger(dataTablePrefix + "pass_data", null, _masterBody.slice());
		RiotControl.trigger(filterPrefix + "set_sorted");
	});

	self.on("rst_sort", function (cid, inverse) {
		//loop through header
		//clean up the "sort" property in all but
		//the one where cid matches
		//check current direction and decide if down or up is next
		//_masterHeader is attached to table so no need to pass data
		var i,
			len = _masterHeader.length,
			loopCid,
			currentSort,
			sortByProp = "",
			sortType = "",
			isSortByV = true;

		for (i = 0; i < len; i++) {
			loopCid = _masterHeader[i].cid;
			if (loopCid !== cid) _masterHeader[i].sort = "";
			else {
				currentSort = _masterHeader[i].sort;
				sortByProp = loopCid;
				if (loopCid === "p1811") isSortByV = false;
				if (currentSort === "desc" || inverse) _masterHeader[i].sort = "asc";
				else _masterHeader[i].sort = "desc";
				sortType = _masterHeader[i].sort;
				_sort = {
					"cid": cid,
					"dir": _masterHeader[i].sort,
					"isByV": isSortByV
				};
			}

		}

		if (_foundParts.length < 1) {
			sortedParts = _allParts.slice().sort((utils.sortArrayByProp)(sortByProp, sortType, isSortByV));
		} else {
			sortedParts = _foundParts.slice().sort((utils.sortArrayByProp)(sortByProp, sortType, isSortByV));
		}

		_metrics.trackSort(cid);
		_partsSelected = [];
		_masterBody = makeBody(filter(_lastQuery, sortedParts), _colOrder);
		self.trigger(dataTablePrefix + "pass_data", null, _masterBody.slice());
		RiotControl.trigger(filterPrefix + "set_sorted");
		RiotControl.trigger(dataTablePrefix + "set_parts_selected", _partsSelected);
	});

	self.on("rst_filterParts", function (filterVal) {
		//basically same as a sort, but filters the _allparts for part numbers
		var i,
			len = _masterHeader.length,
			loopCid,
			parts,
			sortByProp = "",
			sortType = "asc",
			isSortByV = true;

		for (i = 0; i < len; i++) {
			loopCid = _masterHeader[i].cid;
			if (_masterHeader[i].sort !== "") {
				sortByProp = loopCid;
				if (loopCid === "p1811") isSortByV = false;
				sortType = _masterHeader[i].sort;
				break;
			}
		}

		if (filterVal !== '') {
			var partQuery = {
				o1: {
					type: "AND",
					values: [filterVal]
				}
			};
			parts = _foundParts = filter(partQuery, _allParts);
		} else {
			parts = _allParts;
			_foundParts = [];
			sortByProp = '';
		}

		if (sortByProp !== "") {
			parts = parts.slice().sort((utils.sortArrayByProp)(sortByProp, sortType, isSortByV));
		}

		_masterBody = makeBody(filter(_lastQuery, parts), _colOrder);
		self.trigger(dataTablePrefix + "pass_data", null, _masterBody.slice());
		RiotControl.trigger(filterPrefix + "set_sorted");
	});

	self.on("rst_download_parts", function (filterData) {
		var downloadThis,
			filterInfo = makeFilterInfo(filterData),
			downloadHeader = makeDownloadHeader(),
			//receives string with header row
			downloadBody = makeDownloadBody(),
			tableStart = "<table style='border-collapse:collapse;'>",
			tableEnd = "</table>";
			//receives big string with all the body rows

		downloadThis = [filterInfo, tableStart, downloadHeader, downloadBody, tableEnd].join("");
		self.trigger('rst_export_parts', downloadThis);
		//utils.html2sheet(downloadThis);

		_metrics.trackBtn("download");
	});

	self.on("rst_export_parts", function(partsHTML) {
		utils.html2sheet(partsHTML);
	})

	self.on("rst_email", function () {
		_metrics.trackBtn("email");
	});

	self.on("rst_part_toggled", function (partId, checked) {
		var arrayPos = utils.inArray(partId, _partsSelected);
		if (checked && arrayPos === -1) _partsSelected.push(partId);
		else if (!checked && arrayPos > -1) _partsSelected.splice(arrayPos, 1);
		self.trigger(dataTablePrefix + "set_parts_selected", _partsSelected);
	});

	self.on("rst_compare", function () {
		var parts = _partsSelected.toString(),
			ord = _colOrder.toString(),
			comparePath = (_lang === "local") ? "compare" : "http:" + com.TI.rst.langStore.URLs.SERVER_BASE + "/assets/js/compareParts",
			url = comparePath + "/compare.html?familyId=" + _familyId + "&parts=" + parts + "&cols=" + ord + "&lang=" + _lang,
			popupWindow = window.open(url, "Compare", "height=800,width=800,modal=yes,alwaysRaised=yes,location=0,status=no,menubar=no,resizable=yes,scrollbars=yes");
		popupWindow.focus();

		_metrics.trackBtn("compare");

		var metricsParams = {
			clickType: 'compare',
			errorMsg: 'GA _tiAT compare track error',
			linkId: 'st_main_compare',
			trackType: 'selection tool link click'
		};
		_metrics.tiATrack(metricsParams);
	});

	self.on(dataTablePrefix + "loaded", function () {
		_metrics.pushTime(new Date().getTime());
		self.trigger("rst_loading", false);
	});

	self.on("rst_metrics", function (params) {

		if (params) {

			if (typeof (params.linkId) !== 'undefined' && params.linkId !== null) {
				_metrics.tiATrack(params);
			}

			switch (params.action) {
				case "partFilter":
					_metrics.trackPartFilter(params);
					break;
				case "filterToggle":
					_metrics.trackFilterToggle(params);
					break;
				case "loadMore":
					_metrics.trackLoadMore();
					break;
				case "boolType":
					_metrics.trackBoolChange(params);
					break;
				case "infoDrawer":
					_metrics.trackOpenDrawer(params);
					break;
				case "drawerLink":
					_metrics.trackDrawerLinks(params);
					break;
				default:
			}

		} else {
			//console.log('metrics error: no data recieved for event');
		};
	});
};

/*! nouislider - 8.1.0 - 2015-10-25 16:05:43 */

(function (factory) {

    if ( typeof define === 'function' && define.amd ) {

        // AMD. Register as an anonymous module.
        define([], factory);

    } else if ( typeof exports === 'object' ) {

        // Node/CommonJS
        module.exports = factory();

    } else {

        // Browser globals
        window.noUiSlider = factory();
    }

}(function( ){

	'use strict';


	// Removes duplicates from an array.
	function unique(array) {
		return array.filter(function(a){
			return !this[a] ? this[a] = true : false;
		}, {});
	}

	// Round a value to the closest 'to'.
	function closest ( value, to ) {
		return Math.round(value / to) * to;
	}

	// Current position of an element relative to the document.
	function offset ( elem ) {

	var rect = elem.getBoundingClientRect(),
		doc = elem.ownerDocument,
		docElem = doc.documentElement,
		pageOffset = getPageOffset();

		// getBoundingClientRect contains left scroll in Chrome on Android.
		// I haven't found a feature detection that proves this. Worst case
		// scenario on mis-match: the 'tap' feature on horizontal sliders breaks.
		if ( /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) ) {
			pageOffset.x = 0;
		}

		return {
			top: rect.top + pageOffset.y - docElem.clientTop,
			left: rect.left + pageOffset.x - docElem.clientLeft
		};
	}

	// Checks whether a value is numerical.
	function isNumeric ( a ) {
		return typeof a === 'number' && !isNaN( a ) && isFinite( a );
	}

	// Rounds a number to 7 supported decimals.
	function accurateNumber( number ) {
		var p = Math.pow(10, 7);
		return Number((Math.round(number*p)/p).toFixed(7));
	}

	// Sets a class and removes it after [duration] ms.
	function addClassFor ( element, className, duration ) {
		addClass(element, className);
		setTimeout(function(){
			removeClass(element, className);
		}, duration);
	}

	// Limits a value to 0 - 100
	function limit ( a ) {
		return Math.max(Math.min(a, 100), 0);
	}

	// Wraps a variable as an array, if it isn't one yet.
	function asArray ( a ) {
		return Array.isArray(a) ? a : [a];
	}

	// Counts decimals
	function countDecimals ( numStr ) {
		var pieces = numStr.split(".");
		return pieces.length > 1 ? pieces[1].length : 0;
	}

	// http://youmightnotneedjquery.com/#add_class
	function addClass ( el, className ) {
		if ( el.classList ) {
			el.classList.add(className);
		} else {
			el.className += ' ' + className;
		}
	}

	// http://youmightnotneedjquery.com/#remove_class
	function removeClass ( el, className ) {
		if ( el.classList ) {
			el.classList.remove(className);
		} else {
			el.className = el.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
		}
	}

	// http://youmightnotneedjquery.com/#has_class
	function hasClass ( el, className ) {
		if ( el.classList ) {
			el.classList.contains(className);
		} else {
			new RegExp('(^| )' + className + '( |$)', 'gi').test(el.className);
		}
	}

	// https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY#Notes
	function getPageOffset ( ) {

		var supportPageOffset = window.pageXOffset !== undefined,
			isCSS1Compat = ((document.compatMode || "") === "CSS1Compat"),
			x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? document.documentElement.scrollLeft : document.body.scrollLeft,
			y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;

		return {
			x: x,
			y: y
		};
	}

	// todo
	function addCssPrefix(cssPrefix) {
		return function(className) {
			return cssPrefix + className;
		};
	}


	var
	// Determine the events to bind. IE11 implements pointerEvents without
	// a prefix, which breaks compatibility with the IE10 implementation.
	/** @const */
	actions = window.navigator.pointerEnabled ? {
		start: 'pointerdown',
		move: 'pointermove',
		end: 'pointerup'
	} : window.navigator.msPointerEnabled ? {
		start: 'MSPointerDown',
		move: 'MSPointerMove',
		end: 'MSPointerUp'
	} : {
		start: 'mousedown touchstart',
		move: 'mousemove touchmove',
		end: 'mouseup touchend'
	},
	defaultCssPrefix = 'noUi-';


// Value calculation

	// Determine the size of a sub-range in relation to a full range.
	function subRangeRatio ( pa, pb ) {
		return (100 / (pb - pa));
	}

	// (percentage) How many percent is this value of this range?
	function fromPercentage ( range, value ) {
		return (value * 100) / ( range[1] - range[0] );
	}

	// (percentage) Where is this value on this range?
	function toPercentage ( range, value ) {
		return fromPercentage( range, range[0] < 0 ?
			value + Math.abs(range[0]) :
				value - range[0] );
	}

	// (value) How much is this percentage on this range?
	function isPercentage ( range, value ) {
		return ((value * ( range[1] - range[0] )) / 100) + range[0];
	}


// Range conversion

	function getJ ( value, arr ) {

		var j = 1;

		while ( value >= arr[j] ){
			j += 1;
		}

		return j;
	}

	// (percentage) Input a value, find where, on a scale of 0-100, it applies.
	function toStepping ( xVal, xPct, value ) {

		if ( value >= xVal.slice(-1)[0] ){
			return 100;
		}

		var j = getJ( value, xVal ), va, vb, pa, pb;

		va = xVal[j-1];
		vb = xVal[j];
		pa = xPct[j-1];
		pb = xPct[j];

		return pa + (toPercentage([va, vb], value) / subRangeRatio (pa, pb));
	}

	// (value) Input a percentage, find where it is on the specified range.
	function fromStepping ( xVal, xPct, value ) {

		// There is no range group that fits 100
		if ( value >= 100 ){
			return xVal.slice(-1)[0];
		}

		var j = getJ( value, xPct ), va, vb, pa, pb;

		va = xVal[j-1];
		vb = xVal[j];
		pa = xPct[j-1];
		pb = xPct[j];

		return isPercentage([va, vb], (value - pa) * subRangeRatio (pa, pb));
	}

	// (percentage) Get the step that applies at a certain value.
	function getStep ( xPct, xSteps, snap, value ) {

		if ( value === 100 ) {
			return value;
		}

		var j = getJ( value, xPct ), a, b;

		// If 'snap' is set, steps are used as fixed points on the slider.
		if ( snap ) {

			a = xPct[j-1];
			b = xPct[j];

			// Find the closest position, a or b.
			if ((value - a) > ((b-a)/2)){
				return b;
			}

			return a;
		}

		if ( !xSteps[j-1] ){
			return value;
		}

		return xPct[j-1] + closest(
			value - xPct[j-1],
			xSteps[j-1]
		);
	}


// Entry parsing

	function handleEntryPoint ( index, value, that ) {

		var percentage;

		// Wrap numerical input in an array.
		if ( typeof value === "number" ) {
			value = [value];
		}

		// Reject any invalid input, by testing whether value is an array.
		if ( Object.prototype.toString.call( value ) !== '[object Array]' ){
			throw new Error("noUiSlider: 'range' contains invalid value.");
		}

		// Covert min/max syntax to 0 and 100.
		if ( index === 'min' ) {
			percentage = 0;
		} else if ( index === 'max' ) {
			percentage = 100;
		} else {
			percentage = parseFloat( index );
		}

		// Check for correct input.
		if ( !isNumeric( percentage ) || !isNumeric( value[0] ) ) {
			throw new Error("noUiSlider: 'range' value isn't numeric.");
		}

		// Store values.
		that.xPct.push( percentage );
		that.xVal.push( value[0] );

		// NaN will evaluate to false too, but to keep
		// logging clear, set step explicitly. Make sure
		// not to override the 'step' setting with false.
		if ( !percentage ) {
			if ( !isNaN( value[1] ) ) {
				that.xSteps[0] = value[1];
			}
		} else {
			that.xSteps.push( isNaN(value[1]) ? false : value[1] );
		}
	}

	function handleStepPoint ( i, n, that ) {

		// Ignore 'false' stepping.
		if ( !n ) {
			return true;
		}

		// Factor to range ratio
		that.xSteps[i] = fromPercentage([
			 that.xVal[i]
			,that.xVal[i+1]
		], n) / subRangeRatio (
			that.xPct[i],
			that.xPct[i+1] );
	}


// Interface

	// The interface to Spectrum handles all direction-based
	// conversions, so the above values are unaware.

	function Spectrum ( entry, snap, direction, singleStep ) {

		this.xPct = [];
		this.xVal = [];
		this.xSteps = [ singleStep || false ];
		this.xNumSteps = [ false ];

		this.snap = snap;
		this.direction = direction;

		var index, ordered = [ /* [0, 'min'], [1, '50%'], [2, 'max'] */ ];

		// Map the object keys to an array.
		for ( index in entry ) {
			if ( entry.hasOwnProperty(index) ) {
				ordered.push([entry[index], index]);
			}
		}

		// Sort all entries by value (numeric sort).
		if ( ordered.length && typeof ordered[0][0] === "object" ) {
			ordered.sort(function(a, b) { return a[0][0] - b[0][0]; });
		} else {
			ordered.sort(function(a, b) { return a[0] - b[0]; });
		}


		// Convert all entries to subranges.
		for ( index = 0; index < ordered.length; index++ ) {
			handleEntryPoint(ordered[index][1], ordered[index][0], this);
		}

		// Store the actual step values.
		// xSteps is sorted in the same order as xPct and xVal.
		this.xNumSteps = this.xSteps.slice(0);

		// Convert all numeric steps to the percentage of the subrange they represent.
		for ( index = 0; index < this.xNumSteps.length; index++ ) {
			handleStepPoint(index, this.xNumSteps[index], this);
		}
	}

	Spectrum.prototype.getMargin = function ( value ) {
		return this.xPct.length === 2 ? fromPercentage(this.xVal, value) : false;
	};

	Spectrum.prototype.toStepping = function ( value ) {

		value = toStepping( this.xVal, this.xPct, value );

		// Invert the value if this is a right-to-left slider.
		if ( this.direction ) {
			value = 100 - value;
		}

		return value;
	};

	Spectrum.prototype.fromStepping = function ( value ) {

		// Invert the value if this is a right-to-left slider.
		if ( this.direction ) {
			value = 100 - value;
		}

		return accurateNumber(fromStepping( this.xVal, this.xPct, value ));
	};

	Spectrum.prototype.getStep = function ( value ) {

		// Find the proper step for rtl sliders by search in inverse direction.
		// Fixes issue #262.
		if ( this.direction ) {
			value = 100 - value;
		}

		value = getStep(this.xPct, this.xSteps, this.snap, value );

		if ( this.direction ) {
			value = 100 - value;
		}

		return value;
	};

	Spectrum.prototype.getApplicableStep = function ( value ) {

		// If the value is 100%, return the negative step twice.
		var j = getJ(value, this.xPct), offset = value === 100 ? 2 : 1;
		return [this.xNumSteps[j-2], this.xVal[j-offset], this.xNumSteps[j-offset]];
	};

	// Outside testing
	Spectrum.prototype.convert = function ( value ) {
		return this.getStep(this.toStepping(value));
	};

/*	Every input option is tested and parsed. This'll prevent
	endless validation in internal methods. These tests are
	structured with an item for every option available. An
	option can be marked as required by setting the 'r' flag.
	The testing function is provided with three arguments:
		- The provided value for the option;
		- A reference to the options object;
		- The name for the option;

	The testing function returns false when an error is detected,
	or true when everything is OK. It can also modify the option
	object, to make sure all values can be correctly looped elsewhere. */

	var defaultFormatter = { 'to': function( value ){
		return value !== undefined && value.toFixed(2);
	}, 'from': Number };

	function testStep ( parsed, entry ) {

		if ( !isNumeric( entry ) ) {
			throw new Error("noUiSlider: 'step' is not numeric.");
		}

		// The step option can still be used to set stepping
		// for linear sliders. Overwritten if set in 'range'.
		parsed.singleStep = entry;
	}

	function testRange ( parsed, entry ) {

		// Filter incorrect input.
		if ( typeof entry !== 'object' || Array.isArray(entry) ) {
			throw new Error("noUiSlider: 'range' is not an object.");
		}

		// Catch missing start or end.
		if ( entry.min === undefined || entry.max === undefined ) {
			throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
		}

		parsed.spectrum = new Spectrum(entry, parsed.snap, parsed.dir, parsed.singleStep);
	}

	function testStart ( parsed, entry ) {

		entry = asArray(entry);

		// Validate input. Values aren't tested, as the public .val method
		// will always provide a valid location.
		if ( !Array.isArray( entry ) || !entry.length || entry.length > 2 ) {
			throw new Error("noUiSlider: 'start' option is incorrect.");
		}

		// Store the number of handles.
		parsed.handles = entry.length;

		// When the slider is initialized, the .val method will
		// be called with the start options.
		parsed.start = entry;
	}

	function testSnap ( parsed, entry ) {

		// Enforce 100% stepping within subranges.
		parsed.snap = entry;

		if ( typeof entry !== 'boolean' ){
			throw new Error("noUiSlider: 'snap' option must be a boolean.");
		}
	}

	function testAnimate ( parsed, entry ) {

		// Enforce 100% stepping within subranges.
		parsed.animate = entry;

		if ( typeof entry !== 'boolean' ){
			throw new Error("noUiSlider: 'animate' option must be a boolean.");
		}
	}

	function testConnect ( parsed, entry ) {

		if ( entry === 'lower' && parsed.handles === 1 ) {
			parsed.connect = 1;
		} else if ( entry === 'upper' && parsed.handles === 1 ) {
			parsed.connect = 2;
		} else if ( entry === true && parsed.handles === 2 ) {
			parsed.connect = 3;
		} else if ( entry === false ) {
			parsed.connect = 0;
		} else {
			throw new Error("noUiSlider: 'connect' option doesn't match handle count.");
		}
	}

	function testOrientation ( parsed, entry ) {

		// Set orientation to an a numerical value for easy
		// array selection.
		switch ( entry ){
		  case 'horizontal':
			parsed.ort = 0;
			break;
		  case 'vertical':
			parsed.ort = 1;
			break;
		  default:
			throw new Error("noUiSlider: 'orientation' option is invalid.");
		}
	}

	function testMargin ( parsed, entry ) {

		if ( !isNumeric(entry) ){
			throw new Error("noUiSlider: 'margin' option must be numeric.");
		}

		parsed.margin = parsed.spectrum.getMargin(entry);

		if ( !parsed.margin ) {
			throw new Error("noUiSlider: 'margin' option is only supported on linear sliders.");
		}
	}

	function testLimit ( parsed, entry ) {

		if ( !isNumeric(entry) ){
			throw new Error("noUiSlider: 'limit' option must be numeric.");
		}

		parsed.limit = parsed.spectrum.getMargin(entry);

		if ( !parsed.limit ) {
			throw new Error("noUiSlider: 'limit' option is only supported on linear sliders.");
		}
	}

	function testDirection ( parsed, entry ) {

		// Set direction as a numerical value for easy parsing.
		// Invert connection for RTL sliders, so that the proper
		// handles get the connect/background classes.
		switch ( entry ) {
		  case 'ltr':
			parsed.dir = 0;
			break;
		  case 'rtl':
			parsed.dir = 1;
			parsed.connect = [0,2,1,3][parsed.connect];
			break;
		  default:
			throw new Error("noUiSlider: 'direction' option was not recognized.");
		}
	}

	function testBehaviour ( parsed, entry ) {

		// Make sure the input is a string.
		if ( typeof entry !== 'string' ) {
			throw new Error("noUiSlider: 'behaviour' must be a string containing options.");
		}

		// Check if the string contains any keywords.
		// None are required.
		var tap = entry.indexOf('tap') >= 0,
			drag = entry.indexOf('drag') >= 0,
			fixed = entry.indexOf('fixed') >= 0,
			snap = entry.indexOf('snap') >= 0;

		// Fix #472
		if ( drag && !parsed.connect ) {
			throw new Error("noUiSlider: 'drag' behaviour must be used with 'connect': true.");
		}

		parsed.events = {
			tap: tap || snap,
			drag: drag,
			fixed: fixed,
			snap: snap
		};
	}

	function testTooltips ( parsed, entry ) {

		if ( entry === true ) {
			parsed.tooltips = true;
		}

		if ( entry && entry.format ) {

			if ( typeof entry.format !== 'function' ) {
				throw new Error("noUiSlider: 'tooltips.format' must be an object.");
			}

			parsed.tooltips = {
				format: entry.format
			};
		}
	}

	function testFormat ( parsed, entry ) {

		parsed.format = entry;

		// Any object with a to and from method is supported.
		if ( typeof entry.to === 'function' && typeof entry.from === 'function' ) {
			return true;
		}

		throw new Error( "noUiSlider: 'format' requires 'to' and 'from' methods.");
	}

	function testCssPrefix ( parsed, entry ) {

		if ( entry !== undefined && typeof entry !== 'string' ) {
			throw new Error( "noUiSlider: 'cssPrefix' must be a string.");
		}

		parsed.cssPrefix = entry;
	}

	// Test all developer settings and parse to assumption-safe values.
	function testOptions ( options ) {

		var parsed = {
			margin: 0,
			limit: 0,
			animate: true,
			format: defaultFormatter
		}, tests;

		// Tests are executed in the order they are presented here.
		tests = {
			'step': { r: false, t: testStep },
			'start': { r: true, t: testStart },
			'connect': { r: true, t: testConnect },
			'direction': { r: true, t: testDirection },
			'snap': { r: false, t: testSnap },
			'animate': { r: false, t: testAnimate },
			'range': { r: true, t: testRange },
			'orientation': { r: false, t: testOrientation },
			'margin': { r: false, t: testMargin },
			'limit': { r: false, t: testLimit },
			'behaviour': { r: true, t: testBehaviour },
			'format': { r: false, t: testFormat },
			'tooltips': { r: false, t: testTooltips },
			'cssPrefix': { r: false, t: testCssPrefix }
		};

		var defaults = {
			'connect': false,
			'direction': 'ltr',
			'behaviour': 'tap',
			'orientation': 'horizontal'
		};

		// Set defaults where applicable.
		Object.keys(defaults).forEach(function ( name ) {
			if ( options[name] === undefined ) {
				options[name] = defaults[name];
			}
		});

		// Run all options through a testing mechanism to ensure correct
		// input. It should be noted that options might get modified to
		// be handled properly. E.g. wrapping integers in arrays.
		Object.keys(tests).forEach(function( name ){

			var test = tests[name];

			// If the option isn't set, but it is required, throw an error.
			if ( options[name] === undefined ) {

				if ( test.r ) {
					throw new Error("noUiSlider: '" + name + "' is required.");
				}

				return true;
			}

			test.t( parsed, options[name] );
		});

		// Forward pips options
		parsed.pips = options.pips;

		// Pre-define the styles.
		parsed.style = parsed.ort ? 'top' : 'left';

		return parsed;
	}


function closure ( target, options ){

	// All variables local to 'closure' are prefixed with 'scope_'
	var scope_Target = target,
		scope_Locations = [-1, -1],
		scope_Base,
		scope_Handles,
		scope_Spectrum = options.spectrum,
		scope_Values = [],
		scope_Events = {};

  var cssClasses = [
    /*  0 */  'target'
    /*  1 */ ,'base'
    /*  2 */ ,'origin'
    /*  3 */ ,'handle'
    /*  4 */ ,'horizontal'
    /*  5 */ ,'vertical'
    /*  6 */ ,'background'
    /*  7 */ ,'connect'
    /*  8 */ ,'ltr'
    /*  9 */ ,'rtl'
    /* 10 */ ,'draggable'
    /* 11 */ ,''
    /* 12 */ ,'state-drag'
    /* 13 */ ,''
    /* 14 */ ,'state-tap'
    /* 15 */ ,'active'
    /* 16 */ ,''
    /* 17 */ ,'stacking'
    /* 18 */ ,'tooltip'
  ].map(addCssPrefix(options.cssPrefix || defaultCssPrefix));


	// Delimit proposed values for handle positions.
	function getPositions ( a, b, delimit ) {

		// Add movement to current position.
		var c = a + b[0], d = a + b[1];

		// Only alter the other position on drag,
		// not on standard sliding.
		if ( delimit ) {
			if ( c < 0 ) {
				d += Math.abs(c);
			}
			if ( d > 100 ) {
				c -= ( d - 100 );
			}

			// Limit values to 0 and 100.
			return [limit(c), limit(d)];
		}

		return [c,d];
	}

	// Provide a clean event with standardized offset values.
	function fixEvent ( e, pageOffset ) {

		// Prevent scrolling and panning on touch events, while
		// attempting to slide. The tap event also depends on this.
		e.preventDefault();

		// Filter the event to register the type, which can be
		// touch, mouse or pointer. Offset changes need to be
		// made on an event specific basis.
		var touch = e.type.indexOf('touch') === 0,
			mouse = e.type.indexOf('mouse') === 0,
			pointer = e.type.indexOf('pointer') === 0,
			x,y, event = e;

		// IE10 implemented pointer events with a prefix;
		if ( e.type.indexOf('MSPointer') === 0 ) {
			pointer = true;
		}

		if ( touch ) {
			// noUiSlider supports one movement at a time,
			// so we can select the first 'changedTouch'.
			x = e.changedTouches[0].pageX;
			y = e.changedTouches[0].pageY;
		}

		pageOffset = pageOffset || getPageOffset();

		if ( mouse || pointer ) {
			x = e.clientX + pageOffset.x;
			y = e.clientY + pageOffset.y;
		}

		event.pageOffset = pageOffset;
		event.points = [x, y];
		event.cursor = mouse || pointer; // Fix #435

		return event;
	}

	// Append a handle to the base.
	function addHandle ( direction, index ) {

		var origin = document.createElement('div'),
			handle = document.createElement('div'),
			additions = [ '-lower', '-upper' ];

		if ( direction ) {
			additions.reverse();
		}

		addClass(handle, cssClasses[3]);
		addClass(handle, cssClasses[3] + additions[index]);

		addClass(origin, cssClasses[2]);
		origin.appendChild(handle);

		return origin;
	}

	// Add the proper connection classes.
	function addConnection ( connect, target, handles ) {

		// Apply the required connection classes to the elements
		// that need them. Some classes are made up for several
		// segments listed in the class list, to allow easy
		// renaming and provide a minor compression benefit.
		switch ( connect ) {
			case 1:	addClass(target, cssClasses[7]);
					addClass(handles[0], cssClasses[6]);
					break;
			case 3: addClass(handles[1], cssClasses[6]);
					/* falls through */
			case 2: addClass(handles[0], cssClasses[7]);
					/* falls through */
			case 0: addClass(target, cssClasses[6]);
					break;
		}
	}

	// Add handles to the slider base.
	function addHandles ( nrHandles, direction, base ) {

		var index, handles = [];

		// Append handles.
		for ( index = 0; index < nrHandles; index += 1 ) {

			// Keep a list of all added handles.
			handles.push( base.appendChild(addHandle( direction, index )) );
		}

		return handles;
	}

	// Initialize a single slider.
	function addSlider ( direction, orientation, target ) {

		// Apply classes and data to the target.
		addClass(target, cssClasses[0]);
		addClass(target, cssClasses[8 + direction]);
		addClass(target, cssClasses[4 + orientation]);

		var div = document.createElement('div');
		addClass(div, cssClasses[1]);
		target.appendChild(div);
		return div;
	}


	function defaultFormatTooltipValue ( formattedValue ) {
		return formattedValue;
	}

	function addTooltip ( handle ) {
		var element = document.createElement('div');
		element.className = cssClasses[18];
		return handle.firstChild.appendChild(element);
	}

	// The tooltips option is a shorthand for using the 'update' event.
	function tooltips ( tooltipsOptions ) {

		var formatTooltipValue = tooltipsOptions.format ? tooltipsOptions.format : defaultFormatTooltipValue,
			tips = scope_Handles.map(addTooltip);

		bindEvent('update', function(formattedValues, handleId, rawValues) {
			tips[handleId].innerHTML = formatTooltipValue(formattedValues[handleId], rawValues[handleId]);
		});
	}


	function getGroup ( mode, values, stepped ) {

		// Use the range.
		if ( mode === 'range' || mode === 'steps' ) {
			return scope_Spectrum.xVal;
		}

		if ( mode === 'count' ) {

			// Divide 0 - 100 in 'count' parts.
			var spread = ( 100 / (values-1) ), v, i = 0;
			values = [];

			// List these parts and have them handled as 'positions'.
			while ((v=i++*spread) <= 100 ) {
				values.push(v);
			}

			mode = 'positions';
		}

		if ( mode === 'positions' ) {

			// Map all percentages to on-range values.
			return values.map(function( value ){
				return scope_Spectrum.fromStepping( stepped ? scope_Spectrum.getStep( value ) : value );
			});
		}

		if ( mode === 'values' ) {

			// If the value must be stepped, it needs to be converted to a percentage first.
			if ( stepped ) {

				return values.map(function( value ){

					// Convert to percentage, apply step, return to value.
					return scope_Spectrum.fromStepping( scope_Spectrum.getStep( scope_Spectrum.toStepping( value ) ) );
				});

			}

			// Otherwise, we can simply use the values.
			return values;
		}
	}

	function generateSpread ( density, mode, group ) {

		function safeIncrement(value, increment) {
			// Avoid floating point variance by dropping the smallest decimal places.
			return (value + increment).toFixed(7) / 1;
		}

		var originalSpectrumDirection = scope_Spectrum.direction,
			indexes = {},
			firstInRange = scope_Spectrum.xVal[0],
			lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length-1],
			ignoreFirst = false,
			ignoreLast = false,
			prevPct = 0;

		// This function loops the spectrum in an ltr linear fashion,
		// while the toStepping method is direction aware. Trick it into
		// believing it is ltr.
		scope_Spectrum.direction = 0;

		// Create a copy of the group, sort it and filter away all duplicates.
		group = unique(group.slice().sort(function(a, b){ return a - b; }));

		// Make sure the range starts with the first element.
		if ( group[0] !== firstInRange ) {
			group.unshift(firstInRange);
			ignoreFirst = true;
		}

		// Likewise for the last one.
		if ( group[group.length - 1] !== lastInRange ) {
			group.push(lastInRange);
			ignoreLast = true;
		}

		group.forEach(function ( current, index ) {

			// Get the current step and the lower + upper positions.
			var step, i, q,
				low = current,
				high = group[index+1],
				newPct, pctDifference, pctPos, type,
				steps, realSteps, stepsize;

			// When using 'steps' mode, use the provided steps.
			// Otherwise, we'll step on to the next subrange.
			if ( mode === 'steps' ) {
				step = scope_Spectrum.xNumSteps[ index ];
			}

			// Default to a 'full' step.
			if ( !step ) {
				step = high-low;
			}

			// Low can be 0, so test for false. If high is undefined,
			// we are at the last subrange. Index 0 is already handled.
			if ( low === false || high === undefined ) {
				return;
			}

			// Find all steps in the subrange.
			for ( i = low; i <= high; i = safeIncrement(i, step) ) {

				// Get the percentage value for the current step,
				// calculate the size for the subrange.
				newPct = scope_Spectrum.toStepping( i );
				pctDifference = newPct - prevPct;

				steps = pctDifference / density;
				realSteps = Math.round(steps);

				// This ratio represents the ammount of percentage-space a point indicates.
				// For a density 1 the points/percentage = 1. For density 2, that percentage needs to be re-devided.
				// Round the percentage offset to an even number, then divide by two
				// to spread the offset on both sides of the range.
				stepsize = pctDifference/realSteps;

				// Divide all points evenly, adding the correct number to this subrange.
				// Run up to <= so that 100% gets a point, event if ignoreLast is set.
				for ( q = 1; q <= realSteps; q += 1 ) {

					// The ratio between the rounded value and the actual size might be ~1% off.
					// Correct the percentage offset by the number of points
					// per subrange. density = 1 will result in 100 points on the
					// full range, 2 for 50, 4 for 25, etc.
					pctPos = prevPct + ( q * stepsize );
					indexes[pctPos.toFixed(5)] = ['x', 0];
				}

				// Determine the point type.
				type = (group.indexOf(i) > -1) ? 1 : ( mode === 'steps' ? 2 : 0 );

				// Enforce the 'ignoreFirst' option by overwriting the type for 0.
				if ( !index && ignoreFirst ) {
					type = 0;
				}

				if ( !(i === high && ignoreLast)) {
					// Mark the 'type' of this point. 0 = plain, 1 = real value, 2 = step value.
					indexes[newPct.toFixed(5)] = [i, type];
				}

				// Update the percentage count.
				prevPct = newPct;
			}
		});

		// Reset the spectrum.
		scope_Spectrum.direction = originalSpectrumDirection;

		return indexes;
	}

	function addMarking ( spread, filterFunc, formatter ) {

		var style = ['horizontal', 'vertical'][options.ort],
			element = document.createElement('div');

		addClass(element, 'noUi-pips');
		addClass(element, 'noUi-pips-' + style);

		function getSize( type ){
			return [ '-normal', '-large', '-sub' ][type];
		}

		function getTags( offset, source, values ) {
			return 'class="' + source + ' ' +
				source + '-' + style + ' ' +
				source + getSize(values[1]) +
				'" style="' + options.style + ': ' + offset + '%"';
		}

		function addSpread ( offset, values ){

			if ( scope_Spectrum.direction ) {
				offset = 100 - offset;
			}

			// Apply the filter function, if it is set.
			values[1] = (values[1] && filterFunc) ? filterFunc(values[0], values[1]) : values[1];

			// Add a marker for every point
			element.innerHTML += '<div ' + getTags(offset, 'noUi-marker', values) + '></div>';

			// Values are only appended for points marked '1' or '2'.
			if ( values[1] ) {
				element.innerHTML += '<div '+getTags(offset, 'noUi-value', values)+'>' + formatter.to(values[0]) + '</div>';
			}
		}

		// Append all points.
		Object.keys(spread).forEach(function(a){
			addSpread(a, spread[a]);
		});

		return element;
	}

	function pips ( grid ) {

	var mode = grid.mode,
		density = grid.density || 1,
		filter = grid.filter || false,
		values = grid.values || false,
		stepped = grid.stepped || false,
		group = getGroup( mode, values, stepped ),
		spread = generateSpread( density, mode, group ),
		format = grid.format || {
			to: Math.round
		};

		return scope_Target.appendChild(addMarking(
			spread,
			filter,
			format
		));
	}


	// Shorthand for base dimensions.
	function baseSize ( ) {
		return scope_Base['offset' + ['Width', 'Height'][options.ort]];
	}

	// External event handling
	function fireEvent ( event, handleNumber ) {

		if ( handleNumber !== undefined && options.handles !== 1 ) {
			handleNumber = Math.abs(handleNumber - options.dir);
		}

		Object.keys(scope_Events).forEach(function( targetEvent ) {

			var eventType = targetEvent.split('.')[0];

			if ( event === eventType ) {
				scope_Events[targetEvent].forEach(function( callback ) {
					// .reverse is in place
					// Return values as array, so arg_1[arg_2] is always valid.
					callback( asArray(valueGet()), handleNumber, inSliderOrder(Array.prototype.slice.call(scope_Values)) );
				});
			}
		});
	}

	// Returns the input array, respecting the slider direction configuration.
	function inSliderOrder ( values ) {

		// If only one handle is used, return a single value.
		if ( values.length === 1 ){
			return values[0];
		}

		if ( options.dir ) {
			return values.reverse();
		}

		return values;
	}


	// Handler for attaching events trough a proxy.
	function attach ( events, element, callback, data ) {

		// This function can be used to 'filter' events to the slider.
		// element is a node, not a nodeList

		var method = function ( e ){

			if ( scope_Target.hasAttribute('disabled') ) {
				return false;
			}

			// Stop if an active 'tap' transition is taking place.
			if ( hasClass(scope_Target, cssClasses[14]) ) {
				return false;
			}

			e = fixEvent(e, data.pageOffset);

			// Ignore right or middle clicks on start #454
			if ( events === actions.start && e.buttons !== undefined && e.buttons > 1 ) {
				return false;
			}

			e.calcPoint = e.points[ options.ort ];

			// Call the event handler with the event [ and additional data ].
			callback ( e, data );

		}, methods = [];

		// Bind a closure on the target for every event type.
		events.split(' ').forEach(function( eventName ){
			element.addEventListener(eventName, method, false);
			methods.push([eventName, method]);
		});

		return methods;
	}

	// Handle movement on document for handle and range drag.
	function move ( event, data ) {

		// Fix #498
		// Check value of .buttons in 'start' to work around a bug in IE10 mobile.
		// https://connect.microsoft.com/IE/feedback/details/927005/mobile-ie10-windows-phone-buttons-property-of-pointermove-event-always-zero
		// IE9 has .buttons zero on mousemove.
		if ( event.buttons === 0 && event.which === 0 && data.buttonsProperty !== 0 ) {
			return end(event, data);
		}

		var handles = data.handles || scope_Handles, positions, state = false,
			proposal = ((event.calcPoint - data.start) * 100) / data.baseSize,
			handleNumber = handles[0] === scope_Handles[0] ? 0 : 1, i;

		// Calculate relative positions for the handles.
		positions = getPositions( proposal, data.positions, handles.length > 1);

		state = setHandle ( handles[0], positions[handleNumber], handles.length === 1 );

		if ( handles.length > 1 ) {

			state = setHandle ( handles[1], positions[handleNumber?0:1], false ) || state;

			if ( state ) {
				// fire for both handles
				for ( i = 0; i < data.handles.length; i++ ) {
					fireEvent('slide', i);
				}
			}
		} else if ( state ) {
			// Fire for a single handle
			fireEvent('slide', handleNumber);
		}
	}

	// Unbind move events on document, call callbacks.
	function end ( event, data ) {

		// The handle is no longer active, so remove the class.
		var active = scope_Base.querySelector( '.' + cssClasses[15] ),
			handleNumber = data.handles[0] === scope_Handles[0] ? 0 : 1;

		if ( active !== null ) {
			removeClass(active, cssClasses[15]);
		}

		// Remove cursor styles and text-selection events bound to the body.
		if ( event.cursor ) {
			document.body.style.cursor = '';
			document.body.removeEventListener('selectstart', document.body.noUiListener);
		}

		var d = document.documentElement;

		// Unbind the move and end events, which are added on 'start'.
		d.noUiListeners.forEach(function( c ) {
			d.removeEventListener(c[0], c[1]);
		});

		// Remove dragging class.
		removeClass(scope_Target, cssClasses[12]);

		// Fire the change and set events.
		fireEvent('set', handleNumber);
		fireEvent('change', handleNumber);
	}

	// Bind move events on document.
	function start ( event, data ) {

		var d = document.documentElement;

		// Mark the handle as 'active' so it can be styled.
		if ( data.handles.length === 1 ) {
			addClass(data.handles[0].children[0], cssClasses[15]);

			// Support 'disabled' handles
			if ( data.handles[0].hasAttribute('disabled') ) {
				return false;
			}
		}

		// A drag should never propagate up to the 'tap' event.
		event.stopPropagation();

		// Attach the move and end events.
		var moveEvent = attach(actions.move, d, move, {
			start: event.calcPoint,
			baseSize: baseSize(),
			pageOffset: event.pageOffset,
			handles: data.handles,
			buttonsProperty: event.buttons,
			positions: [
				scope_Locations[0],
				scope_Locations[scope_Handles.length - 1]
			]
		}), endEvent = attach(actions.end, d, end, {
			handles: data.handles
		});

		d.noUiListeners = moveEvent.concat(endEvent);

		// Text selection isn't an issue on touch devices,
		// so adding cursor styles can be skipped.
		if ( event.cursor ) {

			// Prevent the 'I' cursor and extend the range-drag cursor.
			document.body.style.cursor = getComputedStyle(event.target).cursor;

			// Mark the target with a dragging state.
			if ( scope_Handles.length > 1 ) {
				addClass(scope_Target, cssClasses[12]);
			}

			var f = function(){
				return false;
			};

			document.body.noUiListener = f;

			// Prevent text selection when dragging the handles.
			document.body.addEventListener('selectstart', f, false);
		}
	}

	// Move closest handle to tapped location.
	function tap ( event ) {

		var location = event.calcPoint, total = 0, handleNumber, to;

		// The tap event shouldn't propagate up and cause 'edge' to run.
		event.stopPropagation();

		// Add up the handle offsets.
		scope_Handles.forEach(function(a){
			total += offset(a)[ options.style ];
		});

		// Find the handle closest to the tapped position.
		handleNumber = ( location < total/2 || scope_Handles.length === 1 ) ? 0 : 1;

		location -= offset(scope_Base)[ options.style ];

		// Calculate the new position.
		to = ( location * 100 ) / baseSize();

		if ( !options.events.snap ) {
			// Flag the slider as it is now in a transitional state.
			// Transition takes 300 ms, so re-enable the slider afterwards.
			addClassFor( scope_Target, cssClasses[14], 300 );
		}

		// Support 'disabled' handles
		if ( scope_Handles[handleNumber].hasAttribute('disabled') ) {
			return false;
		}

		// Find the closest handle and calculate the tapped point.
		// The set handle to the new position.
		setHandle( scope_Handles[handleNumber], to );

		fireEvent('slide', handleNumber);
		fireEvent('set', handleNumber);
		fireEvent('change', handleNumber);

		if ( options.events.snap ) {
			start(event, { handles: [scope_Handles[handleNumber]] });
		}
	}

	// Attach events to several slider parts.
	function events ( behaviour ) {

		var i, drag;

		// Attach the standard drag event to the handles.
		if ( !behaviour.fixed ) {

			for ( i = 0; i < scope_Handles.length; i += 1 ) {

				// These events are only bound to the visual handle
				// element, not the 'real' origin element.
				attach ( actions.start, scope_Handles[i].children[0], start, {
					handles: [ scope_Handles[i] ]
				});
			}
		}

		// Attach the tap event to the slider base.
		if ( behaviour.tap ) {

			attach ( actions.start, scope_Base, tap, {
				handles: scope_Handles
			});
		}

		// Make the range draggable.
		if ( behaviour.drag ){

			drag = [scope_Base.querySelector( '.' + cssClasses[7] )];
			addClass(drag[0], cssClasses[10]);

			// When the range is fixed, the entire range can
			// be dragged by the handles. The handle in the first
			// origin will propagate the start event upward,
			// but it needs to be bound manually on the other.
			if ( behaviour.fixed ) {
				drag.push(scope_Handles[(drag[0] === scope_Handles[0] ? 1 : 0)].children[0]);
			}

			drag.forEach(function( element ) {
				attach ( actions.start, element, start, {
					handles: scope_Handles
				});
			});
		}
	}


	// Test suggested values and apply margin, step.
	function setHandle ( handle, to, noLimitOption ) {

		var trigger = handle !== scope_Handles[0] ? 1 : 0,
			lowerMargin = scope_Locations[0] + options.margin,
			upperMargin = scope_Locations[1] - options.margin,
			lowerLimit = scope_Locations[0] + options.limit,
			upperLimit = scope_Locations[1] - options.limit,
			newScopeValue = scope_Spectrum.fromStepping( to );

		// For sliders with multiple handles,
		// limit movement to the other handle.
		// Apply the margin option by adding it to the handle positions.
		if ( scope_Handles.length > 1 ) {
			to = trigger ? Math.max( to, lowerMargin ) : Math.min( to, upperMargin );
		}

		// The limit option has the opposite effect, limiting handles to a
		// maximum distance from another. Limit must be > 0, as otherwise
		// handles would be unmoveable. 'noLimitOption' is set to 'false'
		// for the .val() method, except for pass 4/4.
		if ( noLimitOption !== false && options.limit && scope_Handles.length > 1 ) {
			to = trigger ? Math.min ( to, lowerLimit ) : Math.max( to, upperLimit );
		}

		// Handle the step option.
		to = scope_Spectrum.getStep( to );

		// Limit to 0/100 for .val input, trim anything beyond 7 digits, as
		// JavaScript has some issues in its floating point implementation.
		to = limit(parseFloat(to.toFixed(7)));

		// Return false if handle can't move and ranges were not updated
		if ( to === scope_Locations[trigger] && newScopeValue === scope_Values[trigger]) {
			return false;
		}

		// Set the handle to the new position.
		// Use requestAnimationFrame for efficient painting.
		// No significant effect in Chrome, Edge sees dramatic
		// performace improvements.
		if ( window.requestAnimationFrame ) {
			window.requestAnimationFrame(function(){
				handle.style[options.style] = to + '%';
			});
		} else {
			handle.style[options.style] = to + '%';
		}

		// Force proper handle stacking
		if ( !handle.previousSibling ) {
			removeClass(handle, cssClasses[17]);
			if ( to > 50 ) {
				addClass(handle, cssClasses[17]);
			}
		}

		// Update locations.
		scope_Locations[trigger] = to;

		// Convert the value to the slider stepping/range.
		scope_Values[trigger] = scope_Spectrum.fromStepping( to );

		fireEvent('update', trigger);

		return true;
	}

	// Loop values from value method and apply them.
	function setValues ( count, values ) {

		var i, trigger, to;

		// With the limit option, we'll need another limiting pass.
		if ( options.limit ) {
			count += 1;
		}

		// If there are multiple handles to be set run the setting
		// mechanism twice for the first handle, to make sure it
		// can be bounced of the second one properly.
		for ( i = 0; i < count; i += 1 ) {

			trigger = i%2;

			// Get the current argument from the array.
			to = values[trigger];

			// Setting with null indicates an 'ignore'.
			// Inputting 'false' is invalid.
			if ( to !== null && to !== false ) {

				// If a formatted number was passed, attemt to decode it.
				if ( typeof to === 'number' ) {
					to = String(to);
				}

				to = options.format.from( to );

				// Request an update for all links if the value was invalid.
				// Do so too if setting the handle fails.
				if ( to === false || isNaN(to) || setHandle( scope_Handles[trigger], scope_Spectrum.toStepping( to ), i === (3 - options.dir) ) === false ) {
					fireEvent('update', trigger);
				}
			}
		}
	}

	// Set the slider value.
	function valueSet ( input ) {

		var count, values = asArray( input ), i;

		// The RTL settings is implemented by reversing the front-end,
		// internal mechanisms are the same.
		if ( options.dir && options.handles > 1 ) {
			values.reverse();
		}

		// Animation is optional.
		// Make sure the initial values where set before using animated placement.
		if ( options.animate && scope_Locations[0] !== -1 ) {
			addClassFor( scope_Target, cssClasses[14], 300 );
		}

		// Determine how often to set the handles.
		count = scope_Handles.length > 1 ? 3 : 1;

		if ( values.length === 1 ) {
			count = 1;
		}

		setValues ( count, values );

		// Fire the 'set' event for both handles.
		for ( i = 0; i < scope_Handles.length; i++ ) {
			fireEvent('set', i);
		}
	}

	// Get the slider value.
	function valueGet ( ) {

		var i, retour = [];

		// Get the value from all handles.
		for ( i = 0; i < options.handles; i += 1 ){
			retour[i] = options.format.to( scope_Values[i] );
		}

		return inSliderOrder( retour );
	}

	// Removes classes from the root and empties it.
	function destroy ( ) {
		cssClasses.forEach(function(cls){
			if ( !cls ) { return; } // Ignore empty classes
			removeClass(scope_Target, cls);
		});
		scope_Target.innerHTML = '';
		delete scope_Target.noUiSlider;
	}

	// Get the current step size for the slider.
	function getCurrentStep ( ) {

		// Check all locations, map them to their stepping point.
		// Get the step point, then find it in the input list.
		var retour = scope_Locations.map(function( location, index ){

			var step = scope_Spectrum.getApplicableStep( location ),

				// As per #391, the comparison for the decrement step can have some rounding issues.
				// Round the value to the precision used in the step.
				stepDecimals = countDecimals(String(step[2])),

				// Get the current numeric value
				value = scope_Values[index],

				// To move the slider 'one step up', the current step value needs to be added.
				// Use null if we are at the maximum slider value.
				increment = location === 100 ? null : step[2],

				// Going 'one step down' might put the slider in a different sub-range, so we
				// need to switch between the current or the previous step.
				prev = Number((value - step[2]).toFixed(stepDecimals)),

				// If the value fits the step, return the current step value. Otherwise, use the
				// previous step. Return null if the slider is at its minimum value.
				decrement = location === 0 ? null : (prev >= step[1]) ? step[2] : (step[0] || false);

			return [decrement, increment];
		});

		// Return values in the proper order.
		return inSliderOrder( retour );
	}

	// Attach an event to this slider, possibly including a namespace
	function bindEvent ( namespacedEvent, callback ) {
		scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];
		scope_Events[namespacedEvent].push(callback);

		// If the event bound is 'update,' fire it immediately for all handles.
		if ( namespacedEvent.split('.')[0] === 'update' ) {
			scope_Handles.forEach(function(a, index){
				fireEvent('update', index);
			});
		}
	}

	// Undo attachment of event
	function removeEvent ( namespacedEvent ) {

		var event = namespacedEvent.split('.')[0],
			namespace = namespacedEvent.substring(event.length);

		Object.keys(scope_Events).forEach(function( bind ){

			var tEvent = bind.split('.')[0],
				tNamespace = bind.substring(tEvent.length);

			if ( (!event || event === tEvent) && (!namespace || namespace === tNamespace) ) {
				delete scope_Events[bind];
			}
		});
	}


	// Throw an error if the slider was already initialized.
	if ( scope_Target.noUiSlider ) {
		throw new Error('Slider was already initialized.');
	}


	// Create the base element, initialise HTML and set classes.
	// Add handles and links.
	scope_Base = addSlider( options.dir, options.ort, scope_Target );
	scope_Handles = addHandles( options.handles, options.dir, scope_Base );

	// Set the connect classes.
	addConnection ( options.connect, scope_Target, scope_Handles );

	// Attach user events.
	events( options.events );

	if ( options.pips ) {
		pips(options.pips);
	}

	if ( options.tooltips ) {
		tooltips(options.tooltips);
	}

	// can be updated:
	// margin
	// limit
	// step
	// range
	// animate
	function updateOptions ( optionsToUpdate ) {

		var newOptions = testOptions({
			start: [0, 0],
			margin: optionsToUpdate.margin,
			limit: optionsToUpdate.limit,
			step: optionsToUpdate.step,
			range: optionsToUpdate.range,
			animate: optionsToUpdate.animate
		});

		options.margin = newOptions.margin;
		options.limit = newOptions.limit;
		options.step = newOptions.step;
		options.range = newOptions.range;
		options.animate = newOptions.animate;

		scope_Spectrum = newOptions.spectrum;
	}

	return {
		destroy: destroy,
		steps: getCurrentStep,
		on: bindEvent,
		off: removeEvent,
		get: valueGet,
		set: valueSet,
		updateOptions: updateOptions
	};

}


	// Run the standard initializer
	function initialize ( target, originalOptions ) {

		if ( !target.nodeName ) {
			throw new Error('noUiSlider.create requires a single element.');
		}

		// Test the options and create the slider environment;
		var options = testOptions( originalOptions, target ),
			slider = closure( target, options );

		// Use the public value method to set the start values.
		slider.set(options.start);

		target.noUiSlider = slider;
		return slider;
	}

	// Use an object instead of a function for future expansibility;
	return {
		create: initialize
	};

}));
riot.tag('ti-autocomplete', '  <button onclick="{ compare }" id="compare_btn" class="button btnA" __disabled="{ compareDisabled }">{ compareText }</button> <input name="btnReset" type="button" class="btn-reset" onclick="{onReset}" ></input> <input name="acinput" type="text" class="search-input" onkeyup="{ complete }" placeholder="{placeholder}"> <div show="{ filtered.length }" class="auto-complete"> <ul> <li each="{ c, i in filtered }" onclick="{ parent.selected }" class="{ active: parent.active==i}">{ styleMatches(this, c) }</li> </ul> </div> <input name="btnSearch" type="button" class="btn-search" onclick="{onFilter}" ></input>', 'class="search-parts {resetMode}"', function(opts) {
        this.active = -1;
        this.choices = []; //opts.choices
        this.filtered  = [];
        this.min = 3;
        this.mode = 'contains';  // or 'starts'
        this.placeholder = "Filter by part number";
        this.resetMode = '';
        this.value = '';

        var self = this;
        var langStore = com.TI.rst.langStore;
        self.onSelection = function(selection) {};
        self.onFilterClick = function(filterText) {};
        self.onResetClick = function() {};
        self.selectedRowsCount = 0;

        self.complete = function(e) {
            if(e.target.value.length < self.min) {
                self.filtered = [];
                self.active = -1;
                return;
            } else {
                self.value = self.acinput.value.trim();   // trim is ie9+
                self.resetMode = '';
            }

            self.filtered = self.choices.filter(function(c) {
                return c.match(self.re(e));
            })

            if(e.which == 40 && self.filtered.length) { // down
                self.active = Math.min(self.active+1, self.filtered.length-1);
                return;
            }

            if(e.which == 38 && self.filtered.length) { // up
                self.active = Math.max(self.active-1, 0);
                return;
            }

            if(e.which == 13) { // enter
                var metricsParams = {
                    'action' : 'partFilter',
                    'term' : e.currentTarget.value.trim()
                };
                RiotControl.trigger("rst_metrics", metricsParams);
                self.filtered.length && self.selection(self.filtered[self.active]);
            }

            if(e.which == 27) { // escape
                self.selection('');
            }
            self.update();
        }

        if (RiotControl) {
            RiotControl.on('ac_reset', function(){
                self.filtered = [];
                self.active = -1;
                self.resetMode = '';
                self.acinput.value = '';
                self.value = '';
            });
        }
        RiotControl.on("updateAutoComplete", function(selectedItemsCount){
            self.selectedRowsCount = selectedItemsCount;
            self.update();
        });
        self.on('mount', function() {
            self.choices = this.opts.choices;
            self.compareText = langStore.strings.COMPARE;
            self.compareDisabled = self.selectedRowsCount < 2 ? "disabled": "";
            self.min = this.opts.min || 3;
            if (typeof(this.opts.initval) != 'undefined') {
                self.acinput.value = this.opts.initval;
                self.value = this.opts.initval;
            }
            self.mode = this.opts.mode || 'contains';
            self.placeholder = this.opts.placeholdertext || 'Filter by part number';
            if (this.opts.onselection !== undefined && typeof(this.opts.onselection) == "function") this.onSelection = this.opts.onselection;
            if (this.opts.onfilterclick !== undefined && typeof(this.opts.onfilterclick) == "function") this.onFilterClick = this.opts.onfilterclick;
            if (this.opts.onresetclick !== undefined && typeof(this.opts.onresetclick) == "function") this.onResetClick = this.opts.onresetclick;

            self.update();
        });
        self.compare = function(){
            RiotControl.trigger("rst_compare");
        }
        self.on('update', function() {
            self.compareDisabled = self.selectedRowsCount < 2 ? "disabled": "";
            if (typeof(this.opts.choices) != 'undefined') self.choices = this.opts.choices;

        });

        this.re = function(e) {
            return self.mode=='start' ?  RegExp('^'+e.target.value.trim(),'i') : RegExp(e.target.value.trim(),'i');
        }.bind(this);

        this.selected = function(s) {
            var metricsParams = {
                'action' : 'partFilter',
                'term' : s.item.c
            };
            RiotControl.trigger("rst_metrics", metricsParams);
            self.selection(s.item.c);
        }.bind(this);

        this.selection = function(txt) {
            if (txt) {
                self.acinput.value=txt;
                self.value = txt;
            } else {
                self.value = self.acinput.value.trim(); // trim is ie9+
            }

            self.active = -1;
            self.filtered = [];

            if (self.value) {
                self.resetMode = 'reset';
                self.onSelection(self.value);
            }
        }.bind(this);

        self.onFilter = function() {
            if (self.value != '' && self.value.length >= self.min) {
                var metricsParams = {
                    'action' : 'partFilter',
                    'term' : self.value.trim()
                };
                RiotControl.trigger("rst_metrics", metricsParams);

                self.filtered = [];
                self.active = -1;
                self.resetMode = 'reset';
                self.onFilterClick(self.value);
            }
        }

        self.onReset = function() {
            self.filtered = [];
            self.active = -1;
            self.resetMode = '';
            self.acinput.value = '';
            self.value = '';
            self.onResetClick();
        }

        self.styleMatches = function(target, matchItem) {
            if (matchItem) {
                styleditem = matchItem.replace(self.acinput.value.toUpperCase(), '<span>'+self.acinput.value.toUpperCase()+'</span>');
                target.root.innerHTML = styleditem; //cant pass back html, must mod directly
            }
        }

    
});
riot.tag('ti-button', '<button name="disBtn" class="{ btnOption }" onclick="{ btnClick }">{ val }</button>', function(opts) {
		var self = this,
			btn = self.tags,
			prefix = "ti_button_";

		var options = {};

		self.val = "";
		self.btnOption = "";
		self.disBtn.disabled = false;

		self.onchange = function(e) {
		};

		self.btnClick = function(e) {
			self.onchange(self);
		}

		self.on("mount", function() {
			self.val = opts.label;

			if (opts.callback !== undefined) self.onchange = opts.callback;
			if (opts.option !== undefined) self.btnOption = opts.option;
			if (opts.isdisabled !== undefined) self.disBtn.disabled = opts.isdisabled;
		});
		self.on("update", function() {
			self.val = opts.label;
			if (opts.option !== undefined) self.btnOption = opts.option;
			if (opts.isdisabled !== undefined) self.disBtn.disabled = opts.isdisabled;
		});

		RiotControl.on(prefix + "update_label", function(e){
			self.val = e.buttonText;
			self.update();
		});
	
});

riot.tag('ti-check-box', '<span name="cbxwrap" onclick="{ toggle }"> <span name="cbx" title="{ tooltip }" alt="{ tooltip }" class="checkbox { size } { checked: checked } { disabled }" ></span> <span name="lbl">{ label }<yield ></yield></span> </span>', function(opts) {
		var self = this,
			utils = com.TI.util,
			isFilter = utils.hasClass(self.root, "filterItem");
		self.options = {};
		self.type = "checkbox"
		self.checked = false;
		self.disabled = ""
		self.label = "";
		self.size = "";
		self.tooltip = "";

		var isChecked = function(chkvalue) {
			if (chkvalue == "checked" || chkvalue == "true" || chkvalue == true || (typeof(chkvalue) !== "undefined" && chkvalue !== "false" && chkvalue !== false) ) {
				return true;
			} else {
				return false;
			}
		}

		self.ontoggle = function(e) {
		};

		self.toggle = function(e) {

			if (!e) e = window.event;


			if(e.target.className.indexOf('disabled') < 0) {
				if (!isFilter) self.checked = !self.checked;
				self.ontoggle(self, e);
			}
		}
		self.on("mount", function() {
			if (opts.ontoggle !== undefined && typeof(opts.ontoggle) == "function") self.ontoggle = opts.ontoggle;

			if (opts.value !== undefined) self.value = opts.value;

			if (opts.tooltip !== undefined) self.tooltip = opts.tooltip;

			if (opts.label !== "undefined") self.label = opts.label;
			else self.lbl.remove();

			if (!isFilter && opts.ischecked !== undefined ) {
				self.checked = isChecked(opts.ischecked);
			};

			if (opts.checktype !== undefined) self.size = opts.checktype;

			self.update();
		});
		self.on("update", function(){

			if (opts.value !== undefined) self.value = opts.value;

			if (opts.tooltip !== undefined) self.tooltip = opts.tooltip;


			if (!isFilter && opts.ischecked !== undefined ) {
				self.checked = isChecked(opts.ischecked);
			};

			if (opts.label !== "undefined") self.label = opts.label;
			else self.lbl.remove();

			if (self.parent && isFilter && self.parent.filter !== undefined) {
				self.checked = utils.inArray(self.label, self.parent.filter.prefilter) > -1;
			}
		});
	
});


riot.tag('ti-collapsible', '<div name="collapse_head" onclick="{ toggle }" class="collapse-header"> <ti-check-box checktype="large" tooltip="{ tooltip }" ontoggle="{ checktoggle }" ischecked="{ checked }" name="large" label="{ label }" onclick="{ blockclick }"></ti-check-box> </div> <div name="collapse_content" class="collapse-content"> <yield ></yield> </div>', 'class="collapsible {highlight: highlight}"', function(opts) {

		var self = this,
			utils = com.TI.util,
			prefix = "ti_collapsible";

		self.label = "";


		self.highlight = false;
		self.checked = false;
		self.tooltip = "";
		self.cid = "";

		self.toggle = function(e){
			var ele = self.root,
				collapsed = ele.getAttribute("collapsed") === "true";
			if (collapsed) expand(ele);
			else collapse(ele);
			
			var metricsParams = {
				'action' : 'filterToggle',
				'cid' : self.cid
			}
			RiotControl.trigger("rst_filter_check_collapsed");
			RiotControl.trigger('rst_metrics', metricsParams);
		};

	  self.blockclick = function(e){
		 var analyticsMessage = '';
		 if (!e) e = window.event;
			if (e.stopPropagation) e.stopPropagation();
			else e.cancelBubble = true;
			if(opts.ischecked){
				analyticsMessage = "st_main_add_column_";
			}
			else{
				analyticsMessage = "st_main_remove_column_";
			}
			analyticsMessage = analyticsMessage+opts.cid;
			var metricsParams = {
					clickType: 'column',
					linkId: analyticsMessage,
					trackType: 'selection tool link click'
			}
			RiotControl.trigger("rst_metrics", metricsParams);
		};

		self.checktoggle = function(e) {}

		var collapse = function(ele) {
			ele.setAttribute("collapsed", "true");
			if(self.filter !== undefined) self.filter.collapsed = true;

		};

		var expand = function(ele){
			ele.setAttribute("collapsed", "false");
			if(self.filter !== undefined) self.filter.collapsed = false;			
		};

		self.on("mount", function() {
			if (opts.cid != undefined) self.cid = opts.cid;

			if (opts.label === undefined) self.unmount();
			else self.label = opts.label;

			if (opts.collapsed && opts.collapsed !== false) collapse(self.root);
			else expand(self.root);

			if (opts.tooltip != undefined) self.tooltip = opts.tooltip;

			if (opts.ischecked !== undefined) self.checked = opts.ischecked;

			if (opts.checktoggle !== undefined) self.checktoggle = opts.checktoggle;
			
			self.update();

		});

		self.on("update", function(obj) {
			var chkAddHide = self.tags["large"];	
			if (chkAddHide !== undefined && chkAddHide.isMounted) {
				chkAddHide.checked = (obj === undefined) ? self.filter.checked : obj.filter.checked;
				chkAddHide.update();
			}
			
			if(obj && (self.filter !== undefined)) {
				if(self.filter.collapsed) collapse(self.root);
				else expand(self.root);
				self.highlight = self.filter.applied.length > 0;
			}

			self.cid = opts.cid;
			self.label = opts.label;
			self.checked = opts.ischecked;
			self.checktoggle = opts.checktoggle;
		});
		
	
});
riot.tag('ti-data-table', '<div name="rstSticky" class="rst-sticky"> <div class="head default"> <ti-button style="float:left;" class="flat hidden" name="showfilters" callback="{ btnShowFilters }" label="{ showFiltersLabel }"></ti-button> <ti-button style="float:left;" class="flat hidden" name="resetfilters" callback="{ btnReset }" label="{ resetText }"></ti-button> <span name="showingText"></span> <button type="button" onclick="{ download }">{downloadExcelText}</button> <a class="button" onclick="{ email }" href="{emailLink}">{emailText}</a> </div> <table name="stickyTable" class="selectable"> <colgroup> <col each="{ item in header }" cid="{ item.cid }" class="{ hilighted: item.justAdded }"></col> </colgroup> <thead> <tr> <th each="{ item in header }" cid="{ item.cid }" class="{headerSortAscending: item.sort==\'asc\'} {headerSortDescending: item.sort==\'desc\'} {noSort:\'item.sort==noSort\'} {hilighted: item.justAdded}"> <span onclick="{ headerSort }">{ item.field }</span> <div if="{item.cid == \'o1\'}" id="col01_sticky"></div> </th> </tr> </thead> </table> </div> <div class="head default"> <ti-button style="float:left;" class="flat hidden" name="showfilters" callback="{ btnShowFilters }" label="{ showFiltersLabel }"></ti-button> <ti-button style="float:left;" class="flat hidden" name="resetfilters" callback="{ btnReset }" label="{ resetText }"></ti-button> <span name="showingText"></span> <button type="button" onclick="{ download }">{downloadExcelText}</button> <a class="button" onclick="{ email }" href="{emailLink}">{emailText}</a> </div> <table id="tblResults" class="selectable"> <colgroup> <col each="{ item in header }" cid="{ item.cid }" class="{ hilighted: item.justAdded }"></col> </colgroup> <thead> <tr> <th each="{ item in header }" cid="{ item.cid }" class="{headerSortAscending: item.sort==\'asc\'} {headerSortDescending: item.sort==\'desc\'} {noSort:\'item.sort==noSort\'} {hilighted: item.justAdded}"> <span onclick="{ headerSort }">{ item.field }</span> <div if="{item.cid == \'o1\'}" id="col01" class="search-parts"><input type="text"></div> </th> </tr> </thead> <tbody> <tr each="{ row, i in body }" id="{ row[0].label }" onclick="{onDrawer_toggle}"> <td each="{ item, j in row }"><span class="{icon-dash ti-icon-dash: item == \'\' || item == \' \'}" name="simpleval">{ item }</span> <ti-custom-cell celldata="{ item }"></ti-custom-cell> </td> </tr> </tbody> </table> <div class="load-more { hidden: hideLoadMore }"> <ti-button label="{showMoreText}" callback="{ btnLoadMore }"></ti-button> </div>', function(opts) {
		var self = this,
            utils = com.TI.util,
			itemsPerStagger = 0,
			staggeredItems,
			buffer,	//used to update body slowly (10% at the time)
			itemsPerBufferLoad,
			prefix = "ti_data_table_",
			cleanEvent,
			stuck = false;
		var langStore = com.TI.rst.langStore;

		self.body = [];
		self.header = [];
		self.hideLoadMore = false;
		self.rowsSelected = [];
		self.pfChoices = [];
		self.pfCurrent = '';
		self.downloadExcelText = '';
		self.emailText = '';
		self.emailLink = '';
		self.showMoreText = '';
		self.showFiltersLabel = '';
		self.resetText = '';

		self.on('update', function() {
			var mainURL = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
			var theHash = window.location.hash.replace("#", "%23").replace(/\&/g,'%26').replace(/ /g,'%25%32%30'); //encodeURI doesn't work
			mainURL = mainURL.replace(/\&/g,'%26');
			self.emailLink = "mailto:?subject=TI.com Selection Tool&body=" + mainURL + theHash;
			console.log('update..');
		});

		self.on("mount", function(){
			self.downloadExcelText = langStore.strings.DOWNLOADTOEXCEL;
			self.emailText = langStore.strings.EMAIL;
			self.showMoreText = langStore.strings.SHOWMORE;
			self.showFiltersLabel = langStore.strings.SHOWFILTERS;
			self.resetText = langStore.strings.RESET;
			self.familyId = opts.family;

			var mainURL = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
			var theHash = window.location.hash.replace("#", "%23").replace(/\&/g,'%26').replace(/ /g,'%25%32%30'); //encodeURI doesn't work
			mainURL = mainURL.replace(/\&/g,'%26');
			self.emailLink = "mailto:?subject=TI.com Selection Tool&body=" + mainURL + theHash;
		});

		self.btnShowFilters = function(){
			self.parent.resultstag.style.marginLeft = "19em";
			utils.removeClass(self.parent.filterstag, 'hidden');

			var showBtn = self.showfilters,
				resetBtn = self.resetfilters,
				i = 0,
				c1 = showBtn.length,
				c2 = resetBtn.length;

			for(i=0;i<c1;i++){
				utils.addClass(showBtn[i], 'hidden');
			}
			for(i=0;i<c2;i++){
				utils.addClass(resetBtn[i], 'hidden');
			}

			var metricsParams = {
				clickType: 'toggle',
				errorMsg: 'GA _tiAT link track error',
				linkId: 'st_main_togglefilters_show',
				trackType: 'selection tool link click'
			}
			RiotControl.trigger("rst_metrics", metricsParams);
		}

        self.btnReset = function(){
            sorted = false;
            RiotControl.trigger("rst_filter_change");
            RiotControl.trigger("rst_apply", undefined, undefined, undefined, 'reset');
            RiotControl.trigger("ac_reset");    // part filter / autocomplete reset
			self.btnShowFilters();
        };

		self.itemCount = function() {
			if (staggeredItems) {
				return staggeredItems.length + self.body.length;
			}
		}

		RiotControl.on(prefix + "pass_data", function(pHeader, pBody, pStagger, pSelected){
			if (pHeader && Array.isArray(pHeader)) {
				self.header = [];
				self.header = pHeader;
			}

			if (pStagger) {
				var tmpStagger = parseInt(pStagger);
				if (!isNaN(tmpStagger)) itemsPerStagger = tmpStagger;
			}

			if (pSelected) self.rowsSelected = pSelected;

			if (pBody && Array.isArray(pBody)) {
				self.pfChoices = pBody.map( function(ele) { return ele[0].label } );  //ie9+
				self.body = [];
				buffer = [];
				staggeredItems = [];
				self.update(); //if you don't use this, first cell will never reload
				if (itemsPerStagger > 0) {
					staggeredItems = pBody.slice();
					buffer = staggeredItems.splice(0,itemsPerStagger);
					self.hideLoadMore = (staggeredItems.length === 0);
					itemsPerBufferLoad = Math.ceil(buffer.length/10);
				} else {
					buffer = pBody;
				}

				var ac_opts = {};
				var colOne = self.stickyTable.querySelector("#col01_sticky");

				ac_opts.min = 1;
				ac_opts.choices = self.pfChoices;
				ac_opts.initval = self.pfCurrent;
				ac_opts.placeholdertext = langStore.strings.FILTERBYPART;
				ac_opts.onfilterclick = self.partsFilter_filter;
				ac_opts.onselection = self.partsFilter_filter;
				ac_opts.onresetclick = self.partsFilter_clear;

				riot.mount(colOne, 'ti-autocomplete', ac_opts)
			}

			RiotControl.trigger('closeDrawer', 'all');
			attachData();
			clearTimeout(cleanEvent);
			cleanEvent = setTimeout(cleanJustAdded,6000);
			setTimeout(stick,300);
		});

		RiotControl.on(prefix + "set_parts_selected", function(rowsCurrentlySelected){
			self.rowsSelected = rowsCurrentlySelected;
			RiotControl.trigger('updateAutoComplete', self.rowsSelected.length);
			self.update();
		});

		RiotControl.on("tree_toggle", function(){
			adjustSticky();
		});

		RiotControl.on(prefix + "clear_parts_filtered", function(){
			self.partsFilter_clear();
		});

		function attachData(){
			var tmp;
			if (buffer && buffer.length > 0) {
				self.body = self.body.concat(buffer.splice(0,itemsPerBufferLoad));

				setTimeout(function(){

					attachData();
				},0);
			} else {

				RiotControl.trigger(prefix + "loaded", self);
				if(self.itemCount() < (typeof(results) != "undefined" ? results.length : 0)){
					tmp = langStore.string('SHOWINGXOFYPARTS', {x: self.itemCount().toString(), y: (typeof(results) != "undefined" ? results.length : 0 )});
				}else{
					tmp = langStore.string('SHOWINGXPARTS', {x: (typeof(results) != "undefined" ? results.length : 0 )});
				}
				self.showingText[0].innerHTML = tmp;
				self.showingText[1].innerHTML = tmp;
				self.update();
				adjustSticky();
				if (!stuck) window.addEventListener("resize", adjustSticky);
			}
		}

		function loadMoreParts(){
			RiotControl.trigger('closeDrawer', 'all');
			if (staggeredItems) {
				buffer = staggeredItems.splice(0,itemsPerStagger);
				self.hideLoadMore = (staggeredItems.length === 0);
				attachData();

				var metricsParams = {
					'action' : 'loadMore',
					clickType: 'link',
					linkId: 'load more parts',
					trackType: "selection tool link click"
				}
				RiotControl.trigger("rst_metrics", metricsParams);
			}
		}
				
		function cleanJustAdded(){
			var i,
				len = self.header.length;
			for (i=0; i<len; i++) {
				self.header[i].justAdded = false;
			}
			self.update();
		}

		function adjustSticky(){
			if (!stuck) stuck = false;

			var stickyContainer = self.rstSticky,
				stickyTable = self.stickyTable,
				stickyCols = stickyTable.getElementsByTagName("th");

			var mainTable = self.tblResults,
				tableHeaders = mainTable.getElementsByTagName("th");

			var i, len;
			len = tableHeaders.length;
			for (i=0; i<len; i++) {
				stickyCols[i].width = tableHeaders[i].offsetWidth;
			}

			window.removeEventListener("scroll", stick);
			window.addEventListener("scroll", stick);
		}

		function stick(){
			var stickyContainer = self.rstSticky,
				mainTable = self.tblResults,
				mainEle = self.parent.root,
				quickSearch = self.parent.tags["ti-quick-searches"],
				qsOffset = (typeof(quickSearch) == 'undefined') ? 0 : quickSearch.root.offsetHeight,
				quickHeight = (typeof(quickSearch) !== 'undefined' && !quickSearch.psloaded && !quickSearch.qsloaded) ? 43 : qsOffset + 70,
				mainEleOffset = docOffset(mainEle) + quickHeight,
				cScrollTop = document.body.scrollTop || document.documentElement.scrollTop,
				myScroll = cScrollTop - mainEleOffset;
				stopScrollAt = mainEleOffset + mainTable.offsetHeight;
			if (myScroll >= 0 && myScroll < stopScrollAt) stickyContainer.style.top = myScroll + "px";
			else if (myScroll <  0) stickyContainer.style.top = "0px";
		}

		function docOffset(ele) {
			var top = 0;
			if (ele.offsetParent) {
				do {
					top += ele.offsetTop;
				} while (ele = ele.offsetParent);
			}
			return top;
		}

		self.btnLoadMore = function(){
			loadMoreParts();
		};

		self.headerSort = function(e) {
				var ele = e.target,
				parent = ele.parentElement,
				cid = parent.getAttribute("cid");
				RiotControl.trigger("rst_sort", cid);
			RiotControl.trigger('updateAutoComplete', self.rowsSelected.length);

			var metricsParams = {
				clickType: "sort",
				errorMsg: 'GA _tiAT link track error',
				linkId: 'st_main_sort_' + cid,
				trackType: 'selection tool link click'
			}
			RiotControl.trigger("rst_metrics", metricsParams);
		};

		self.download = function() {
			RiotControl.trigger("rst_download");

			var metricsParams = {
				clickType: "download",
				errorMsg: 'GA _tiAT link track error',
				linkId: 'st_main_download',
				trackType: 'selection tool link click'
			}
			RiotControl.trigger("rst_metrics", metricsParams);
		};

		self.email = function(){
			RiotControl.trigger("rst_email");

			var metricsParams = {
				clickType: "email",
				errorMsg: 'GA _tiAT link track error',
				linkId: 'st_main_email',
				trackType: 'selection tool link click'
			}
			RiotControl.trigger("rst_metrics", metricsParams);

			return true;
		};

		self.partsFilter_filter = function(sel) {
			if (sel) {
				self.pfCurrent = sel;
				RiotControl.trigger("rst_filterParts", sel.toUpperCase());

				var metricsParams = {
					clickType: "filter",
					errorMsg: 'GA _tiAT link track error',
					linkId: 'st_main_acpartfilter',
					trackType: 'selection tool link click'
				}
				RiotControl.trigger("rst_metrics", metricsParams);
			}
		}

		self.partsFilter_clear = function() {
			self.pfCurrent = '';
			RiotControl.trigger("rst_filterParts", '');

		}

		self.onSelection = function(sel) {
			console.log(sel);
		};

		self.onDrawer_toggle = function(e) {
			if(e.target.attributes["name"]){

				if(e.target.attributes["name"].value === "celllink" || e.target.attributes["name"].value === "cbx"){
					return;
				}
			}


			var getClosestByTag = function (elem, selector) {

			    for ( ; elem && elem !== document; elem = elem.parentNode ) {

			        if ( elem.tagName.toLowerCase() === selector ) {
			            return elem;
			        }
			    }
			    return false;
			};

			var tbl = self.tblResults;
			var row = getClosestByTag(e.target, 'tr');
			var opts = {};



			opts.img = row.querySelector("ti-custom-cell").getAttribute('data-filename');
			opts.status = row.querySelector("ti-custom-cell").getAttribute('data-status');
			opts.ods = row.querySelector("ti-custom-cell").getAttribute('data-ods');
			opts.qgpn = row.querySelector("ti-custom-cell").getAttribute('data-qgpn');
			opts.cid = row.id;
			opts.numCol = self.header.length;
			opts.parentRow = row;
			opts.family = self.familyId;
			var rstidChk = document.getElementById("rstid_" + opts.cid)
			if (rstidChk) {
				RiotControl.trigger('closeDrawer', opts.cid)

				var metricsParams = {
					clickType: "toggle",
					errorMsg: 'GA _tiAT link track error',
					linkId: 'st_main_drawertoggle_close_' + opts.cid.toLowerCase(),
					trackType: 'selection tool link click'
				}
				RiotControl.trigger("rst_metrics", metricsParams);

			} else {

				var newRow = tbl.insertRow(row.rowIndex + 1);
				riot.mount(newRow, 'ti-rst-info-drawer', opts);

				var metricsParams = {
					clickType: "toggle",
					errorMsg: 'GA _tiAT link track error',
					linkId: 'st_main_drawertoggle_open_' + opts.cid.toLowerCase(),
					trackType: 'selection tool link click'
				}
				RiotControl.trigger("rst_metrics", metricsParams);
			}




		}
	
});

riot.tag('ti-custom-cell', '', function(opts) {
		var cell = this,
			params;
		cell.val = "";

		cell.on("mount", function(){
			if (typeof opts.celldata === 'object') {
				params = opts.celldata;
				params.family = cell.parent.opts.family;
				var parentEle = cell.root.parentElement;
				parentEle.removeChild(parentEle.firstChild);
				riot.mount(cell.root, params.tag, { params : params });
			} else {
				cell.unmount();
			}

		});

	
});

riot.tag('ti-ddl-multiple', '<div name="collapse_head" onclick="{ toggle }" class="collapse-header"> <div style="height:35px;padding:0;" name="selection_info" class="selected-items"><span style="padding:0;">{listSelected}</span></div> <div name="cbxList" class="collapse-content" onclick="{ blockclick }" > <ti-check-box ontoggle="{ parent.parent.chkFilter }" val="{ j }" label="{ val.v }" each="{ val, j in filter.vals }" style="display:block;margin: 0.6em 1em 1em 1.6em;" ischecked="{checkSelected(val.v, filter.prefilter)}" onclick="{blockclick}"> </ti-check-box> </div> </div>', 'class="collapsible"', function(opts) {
		var self = this;
		var defaultSelect = "Select";

		if (com.TI.rst.langStore.strings) {
			defaultSelect = com.TI.rst.langStore.strings.SELECT;
		}

		if (com.TI.util) utils = com.TI.util;

		self.on("mount", function() {
			self.filter = opts.filter;
			if (opts.filter.prefilter.length > 0) {
				self.listSelected = opts.filter.prefilter.join(', ');
			} else {
				self.listSelected = defaultSelect;
			}
			
			self.update();


			document.addEventListener("click", function(e) {
				if (e.target != self.cbxList && e.target.parentElement != self.cbxList) {
					collapse(self.root);
				};
			});

		});

		checkSelected = function(chk, arr) {
			if (arr == undefined || chk == undefined) return false;
			if (utils.inArray(chk, arr) > -1) {
				return true;
			} else {
				return false;
			}
		};

		blockclick = function(e){
			if (!e) e = window.event;
			if (e.stopPropagation) e.stopPropagation();
			else e.cancelBubble = true;
		}

		self.toggle = function(e){
			if (!e) e = window.event;
			if (e.stopPropagation) e.stopPropagation();
			else e.cancelBubble = true;

			var ele = self.root,
				collapsed = ele.getAttribute("collapsed") === "true";
			if (collapsed) expand(ele);
			else collapse(ele);
		};
		var collapse = function(ele) {
			ele.setAttribute("collapsed", "true");
		};
		var expand = function(ele){
			ele.setAttribute("collapsed", "false");
			var otherDdls = self.parent.tags["ti-ddl-multiple"];
			if(otherDdls != undefined){
				var c = otherDdls.length;
					i = 0;
				for(i=0;i<c;i++){
					var ddl = self.parent.tags["ti-ddl-multiple"][i];
					if(ddl !== self){
						ddl.root.setAttribute("collapsed", "true");
					}
				}
			}
		};
		self.updateListSelected = function(list) {
			if (list.length == 0) { list = defaultSelect}
			self.listSelected = list;
			self.update();
		}
		self.resetDdl = function() {
			self.filter.prefilter = [];
			self.listSelected= defaultSelect;
			self.update();
		}

	
});

riot.tag('ti-filters', '<div class="head"> <ti-button style="float:left;" name="hidefilters" class="flat" callback="{ btnHideFilters }" label="{ hideFiltersLabel }"></ti-button> <ti-button class="flat" callback="{ btnReset }" label="{ resetText }"></ti-button> <ti-button class="flat f_left hidden" callback="{ btnExpandAll }" label="{ expandAllText }"></ti-button> </div> <div class="body"> <div each="{ filter, i in filters }" cid="{ filter.cid }"> <ti-collapsible if="{ filter.type == \'C\' || filter.type == \'CS2\' }" tooltip="{ parent.tooltipText }" collapsed="{ filter.collapsed }" label="{ filter.label }{ filter.attr }{ filter.unit }" ischecked="{filter.checked}" checktoggle="{ parent.toggleColumn }" cid="{ filter.cid }"> <div class="filter-items"> <select name="rstBool" if="{ filter.defType !== \'OFF\' && filter.type == \'C\' }" onchange="{ parent.boolChange }"> <option __selected="{ selected: filter.searchType==\'OR\' }" value="OR">OR</option> <option __selected="{ selected: filter.searchType==\'AND\' }" value="AND">AND</option> <option __selected="{ selected: filter.searchType==\'NOT\' }" value="NOT">NOT</option> </select> <ti-check-box ontoggle="{ parent.parent.chkFilter }" val="{ item.v }" label="{ item.l }" each="{ item, j in filter.vals }" class="filterItem"> </ti-check-box> </div> <div class="filter-button"> <ti-button cid="{filter.cid}" label="{ parent.applyButtonText }" callback="{ parent.btnApply }" option="button btnA" isdisabled="{ parent.prefilterCount == 0 || !parent.isDirty }"></ti-button> </div> </ti-collapsible> <ti-collapsible if="{ filter.type == \'S\'}" tooltip="{ parent.tooltipText }" collapsed="{ filter.collapsed }" label="{ filter.label } { filter.attr }{ filter.unit }" ischecked="{filter.checked}" checktoggle="{ parent.toggleColumn }" cid="{ filter.cid }"> <div class="filter-items"> <ti-slider-nui id="{filter.cid}" units="{ filter.units }" onsliderchange="{ parent.slideFilter }" snap="true" slidertype="{ filter.sliderType }" values="{ filter.options }" start="{ filter.applied }"></ti-slider-nui> </div> <div class="filter-button"> <ti-button cid="{filter.cid}" label="{ parent.applyButtonText }" callback="{ parent.btnApply }" option="button btnA" isdisabled="{ parent.prefilterCount == 0 || !parent.isDirty }"></ti-button> </div> </ti-collapsible> </div> </div>', function(opts) {
        var self = this,
            utils = com.TI.util,
            prefix = "ti_filters_",
            sorted = false;

        var langStore = com.TI.rst.langStore;

        self.totalCount = 0;
        self.matchCount = 0;
        self.prefilterCount = 0;
        self.filters = [];
        self.isDirty = false;
        self.applyButtonText = ''; //btnState.clean;

        self.tooltipText = '';
        self.resetText = '';
        self.expandAllText = '';
        self.parametersTitle = '';
		self.hideFiltersLabel = '';

		self.btnHideFilters = function(){
			self.parent.resultstag.style.marginLeft = 0;
			utils.addClass(self.parent.filterstag, 'hidden');

			var showBtn = self.parent.tags["resultstag"].showfilters,
				resetBtn = self.parent.tags["resultstag"].resetfilters,
				i = 0,
				c1 = showBtn.length,
				c2 = resetBtn.length;

			for(i=0;i<c1;i++){
				utils.removeClass(showBtn[i], 'hidden');
			}
			for(i=0;i<c2;i++){
				utils.removeClass(resetBtn[i], 'hidden');
			}

            var metricsParams = {
                clickType: 'toggle',
                errorMsg: 'GA _tiAT link track error',
                linkId: 'st_main_togglefilters_hide',
                trackType: 'selection tool link click'
            }
            RiotControl.trigger("rst_metrics", metricsParams);
		}

        function rstScrollTop() {
            var mainEle = self.parent.root,
				quickSearch = self.parent.tags["ti-quick-searches"].root,
                quickHeight = (quickSearch) ? quickSearch.offsetHeight + 26 : 0,
                mainEleOffset = docOffset(mainEle) + quickHeight;
            document.body.scrollTop = mainEleOffset;
            document.documentElement.scrollTop = mainEleOffset;
        }

        function docOffset(ele) {
            var top = 0;
            if (ele.offsetParent) {
                do {
                    top += ele.offsetTop;
                } while (ele = ele.offsetParent);
            }
            return top;
        }

        self.btnReset = function(){
                sorted = false;
                RiotControl.trigger("rst_filter_change");
                RiotControl.trigger("rst_apply", undefined, undefined, undefined, 'reset');
                RiotControl.trigger("ac_reset");    // part filter / autocomplete reset
        };

        self.btnExpandAll = function(){
            if (self.expandAllText === langStore.strings.EXPAND_ALL) {
                RiotControl.trigger("rst_filter_expand_all");
                self.expandAllText = langStore.strings.COLLAPSE_ALL;
            } else {
                RiotControl.trigger("rst_filter_collapse_all");
                self.expandAllText = langStore.strings.EXPAND_ALL;
            }
        }

        self.chkFilter = function(e) {
            var val = e.item.v,
                checked = !e.checked,
                cid = e.parent.root.parentElement.getAttribute("cid"),
                dropDown = e.parent.rstBool,
                type = (dropDown === undefined ? "OR" : dropDown.value);
            RiotControl.trigger("rst_filter_change", cid, val, type, checked);
        };

        self.isAppliedCheck = function(item, applied) {
            if (utils.isEmpty(applied)) return false;
            return utils.inArray(item, applied) > -1;
        }

        self.slideFilter = function(slider) {
			var sType;
			if (slider.cid == "p1192") {
				sType = "OPTEMPRANGE";
			}
			else {
				sType = "RANGE";
			}
            sliderVal = [];
            if (slider.val) {
                sliderVal.push(slider.val.min);
                if (slider.val.max) sliderVal.push(slider.val.max);
            }
            RiotControl.trigger("rst_filter_change", slider.cid, sliderVal, sType, true);
        }

        self.btnApply = function(e) {
            var cid = e.root.getAttribute('cid');
            if (self.prefilterCount > 0) {
                RiotControl.trigger("rst_apply", undefined, undefined, undefined, 'apply');
                RiotControl.trigger("ac_reset");  //reset part filter
                rstScrollTop();
            }
        }

        self.toggleColumn = function(ele){
            var cid = ele.parent.root.parentElement.getAttribute("cid"),
                action = (ele.checked) ? "add" : "del";
            RiotControl.trigger("rst_filter_checkbox_change", cid, ele.checked);
        }

        self.boolChange = function(evnt){
            var ele = evnt.target,
                cid = ele.parentElement.parentElement.parentElement.getAttribute("cid"),
                type = ele.value;

            var metricsParams = {
                'action' : 'boolType',
                'cid' : cid,
                'type' : type
            };
            RiotControl.trigger("rst_metrics", metricsParams);
            RiotControl.trigger("rst_filter_change", cid, null, type);
        }

        self.on("mount", function(){

            self.tooltipText = langStore.strings.CLICKCOLUMN;
            self.resetText = langStore.strings.RESET;
            self.parametersTitle = langStore.strings.PARAMETERS;
            self.expandAllText = langStore.strings.EXPAND_ALL;
			self.hideFiltersLabel = langStore.strings.HIDEFILTERS;
        });

        RiotControl.on(prefix + "init", function(filterData) {
            self.filters = filterData;
            self.update();
        });

        RiotControl.on(prefix + "sync_ui", function(filterData) {
            var i, len = self.filters.length;

            for (i=0; i<len; i++) {
                self.filters[i].cid = filterData[i].cid;
                self.filters[i].applied = filterData[i].applied.slice();
                self.filters[i].appliedBool = filterData[i].appliedBool;
                self.filters[i].attr = filterData[i].attr;
                self.filters[i].checked = filterData[i].checked;
                self.filters[i].collapsed = filterData[i].collapsed;
                self.filters[i].defType = filterData[i].defType;
                self.filters[i].fromQuickLink = filterData[i].fromQuickLink;
                self.filters[i].isDirty = filterData[i].isDirty;
                self.filters[i].label = filterData[i].label;
                self.filters[i].options = filterData[i].options.slice();
                self.filters[i].prefilter = filterData[i].prefilter.slice();
                self.filters[i].searchType = filterData[i].searchType;
                self.filters[i].sliderType = filterData[i].sliderType;
                self.filters[i].type = filterData[i].type;
                self.filters[i].unit = filterData[i].unit;
                self.filters[i].units = filterData[i].units;
                self.filters[i].vals = filterData[i].vals.slice();
            }

            self.update();
        });

        RiotControl.on(prefix + "sync_checks", function(filterData) {
            var i, len = self.filters.length;

            for (i=0; i<len; i++) {
                self.filters[i].applied = filterData[i].applied.slice();
                self.filters[i].appliedBool = filterData[i].appliedBool;
                self.filters[i].prefilter = filterData[i].prefilter.slice();
                self.filters[i].searchType = filterData[i].searchType;
                self.filters[i].type = filterData[i].type;
            }

            self.update();
        });

        self.on('update', function() {

        })

        RiotControl.on(prefix + "update_count", function(matchCount, totalCount) {

            if (matchCount !== undefined) self.matchCount = matchCount;
            if (totalCount !== undefined) self.totalCount = totalCount;
            self.update();
        });

        RiotControl.on(prefix + "update_prefilter_count", function(count) {
            if (count !== undefined) self.prefilterCount = count;
            if (count === 0) self.applyButtonText = langStore.string('XPARTSFOUND', {x: '0'}); //btnState.notfound;
            else self.applyButtonText = (self.isDirty) ? langStore.string('VIEWXPARTS', {x: self.prefilterCount.toString()}) : langStore.string('SHOWINGXPARTS', {x: self.prefilterCount.toString()}) //btnState.dirty : btnState.clean;
            self.update();
        });

        RiotControl.on(prefix + "set_sorted", function(){
            sorted = true;
        });

        RiotControl.on(prefix + "set_dirty", function(dirty){
            self.isDirty = dirty;
            self.update();
        });

        RiotControl.on(prefix + "sync_collapsed", function(){
            var allCollapsible = self.root.getElementsByTagName("ti-collapsible"),
                allExpanded = true,
                i,
                len = allCollapsible.length,
                tmpEle,
                isExpanded;
            for (i=0; i<len; i++){
                tmpEle = allCollapsible[i];
                isExpanded = tmpEle.getAttribute("collapsed") !== "true";
                if (!isExpanded) allExpanded = false;
                if (!allExpanded) break;
            }
            if (allExpanded) self.expandAllText = langStore.strings.COLLAPSE_ALL;
            else self.expandAllText = langStore.strings.EXPAND_ALL;
            self.update();
        });

        RiotControl.on(prefix + "go_to_table", function(){
            rstScrollTop();
        })

    
});

riot.tag('ti-param-search', '<div if="{ paramSearches.length > 0 }"> <h2>{ psTitle }</h2> <p>{ psDescription }</p> <div class="row parameters"> <div class="c8"> <ul> <li each="{ search, i in paramSearches }"> <a href="#" onclick="{ quickfilter(search) }" name="{ lidPrefix + search.name }"> { search.name } ({search.count}) </a> </li> </ul> </div> </div> </div>', 'class="ti-param-search"', function(opts) {

		var self = this,
			utils = com.TI.util,
			rstUtil = com.TI.rst,
			familyid,
			indexCols;

		self.psTitle = "One-click Search";
		self.psDescription = "Find parts that match specific requirements";

		self.paramSearches = [];

		self.on("mount", function(){

			prefetchData = opts.prefetch;
			familyid = opts.familyid;
			indexCols = opts.indexCols;
			filter = opts.filter;
			self.standalone = (opts.standalone !== undefined && (opts.standalone === true || opts.standalone === '' || opts.standalone.toString().toLowerCase() === 'true') ? true : false);
			if (typeof(opts.selectiontoolurl) == 'undefined') {
				self.target_selectiontool = '';
			} else {
				self.target_selectiontool = opts.selectiontoolurl;
			};

			self.lidPrefix = "&lid=parametric_selection_oneclick_" + familyid + "_";

			if (familyid) {
				if (prefetchData) {

					buildParamSearches(prefetchData);
				} else {
					fetchParamSearches();
				}
			}

			self.update();
		});

		self.on("update", function() {
			if (com.TI.rst.langStore) {
				if (com.TI.rst.langStore.strings) {
					self.psTitle = com.TI.rst.langStore.strings.QUICKPARAMETERS;
					self.psDescription = com.TI.rst.langStore.strings.QUICKPARAMETERS_INSTRUCTIONS;
				}
			}
		});

		fetchParamSearches = function() {

			var base = com.TI.rst.langStore.URLs.SERVER_BASE;

			if (document.domain.indexOf('.dhcp.ti.com') === 0) {
				base = 'http://www-int.itg.ti.com'; // use int
			}

			var svc = com.TI.rst.langStore.URLs.REST.replace('!!familyId!!', familyid);
			var url = base + svc;

			utils.loadJSON(url, loadParamSearches, errorParamSearches);
		}

		loadParamSearches = function(response) {

			if (!utils.isEmpty(response.data) && !utils.isEmpty(response.data[0].links)) {

				buildParamSearches(response.data[0].links);
				self.update();

			} else {

				console.info('No one-click parameters found for family id ' + familyid);
			}
		}

		errorParamSearches = function(response) {

			if (response.status == 404) {

				console.info('No one-click parameters found for family id ' + familyid);

			} else {

				console.warn('No results for one-click parameters query');
			}

			
		}

		buildParamSearches = function(links) {

			self.paramSearches = links.reduce(function(arr, link, arrIndex) {

				if (link.index === undefined) {

					setLinkIndexFromName(link);
				}

				if (link.index === undefined) {







					link.index = arrIndex;
				}

				var query = rstUtil.generateQuery(link.params, indexCols);
				var parts = filter(query);

				if (!utils.isEmpty(parts)) {

					var search = {
						index: link.index,
						name: link.name,
						params: link.params,
						query: query,
						count: parts.length.toString()
					};

					arr.push(search);
				}

				return arr;

			}, []);

			self.paramSearches.sort(function (a, b) {
				return Number(a.index) - Number(b.index);
			});
		}

		setLinkIndexFromName = function(link) {


			var indexSeparator = '<:>';
			var names = link.name.split(indexSeparator);

			if (names.length > 1 && !isNaN(names[0])) {
				link.index = names[0];

				names.shift();

				link.name = names.join(indexSeparator);
			}
		}

		quickfilter = function(search) {

			return function(e) {

				var searchParams = search.params;
				var q = rstUtil.generateQuery(searchParams, indexCols);
				var params = Object.keys(q);

				if (self.standalone) {

					var params = {
						errorMsg: 'GA _tiAT track error',
						familyId: familyid,
						linkId: 'st_pocs_link',
						searchType: 'pocs',
						trackType: "selection tool search"
					};
					try {
						_tiAnalyticsTrack(params.trackType, params.familyId, params.searchType, params.linkId);
					} catch (e) {

					};

					window.location = self.target_selectiontool + '?pqs=pocs&familyid=' + familyid + '#' + com.TI.rst.q2string(q);
				} else {
					rstUtil.filterQP(q, params, params[0]);
				}
				return false;
			}
		}

	
});
riot.tag('ti-quick-searches', '<div id="quickSearches" class="cnt"> <div name="searchmount"></div> <div if="{oneclick}" name="parammount"></div> </div> <div class="showMore" if="{!standalone}"> <button onclick="{showMore}"> <span id="showMoreLink"> {com.TI.rst.langStore.strings.QUICKSEARCHHIDE} </span> </button> </div>', 'if="{psloaded || qsloaded}"', function(opts) {
    var self = this,
        params = {},
        isCustomQS = false,
        hasParamSearch = true,
        utils = com.TI.util,
        qsDiv = self.searchmount,
        psDiv = self.parammount,
        ssDiv = self.quickSearches,
        topFiltersUrl;

        self.isLess = true;
    		self.selectiontoolurl = '';
    		self.standalone = 'false';
        self.oneclick = true;
        self.psloaded = false;
        self.qsloaded = false;

        self.on("update", function() {
      		self.psloaded = (self.parammount.children.length > 0)
      	});
    self.showMore = function() {
        if (self.isLess){
          self.isLess = false
          self.showMoreLink.textContent = com.TI.rst.langStore.strings.QUICKSEARCHSHOW
          self.quickSearches.className = "cnt lesss"
          _tiAnalyticsTrack("selection tool link click", "toggle", "st_aqs_toggle_close");
        }else{
          self.isLess = true
          self.showMoreLink.textContent = com.TI.rst.langStore.strings.QUICKSEARCHHIDE
          self.quickSearches.className = "cnt"
          _tiAnalyticsTrack("selection tool link click", "toggle", "st_aqs_toggle_open");
        }
    }

  	self.on("mount", function(){
  		topFiltersUrl = this.parent.topFiltersUrl;
  		self.selectiontoolurl = opts.selectiontoolurl;
  		self.standalone = opts.standalone;
      self.update();
  	});

	var loadQS = function(qs, params){

		if (qs !== "NO_QS") {
        	var qsjs = document.createElement('script');
			qsjs.setAttribute('type',"text/javascript");
			qsjs.setAttribute('src', com.TI.rst.langStore.URLs.SERVER_BASE + com.TI.rst.langStore.URLs.QS + qs + '.js');

			document.getElementsByTagName("head")[0].appendChild(qsjs);

			qsjs.onload = function () { riot.mount(qsDiv, 'ti-quick-search-' + qs, params); };

			self.qsloaded = true;
			self.update();
		}
	};

    RiotControl.on("qs_init", function(lang, family, indexCols, _allParts, _colOrder, filter, makeBody){
        params = {
            "lang" : lang,
            "familyid": family,
            "indexCols": indexCols,
            "allParts": _allParts,
            "colOrder": _colOrder,
            "filter": filter,
            "makeBody": makeBody,
			"standalone" : opts.standalone,
			"selectiontoolurl" : opts.selectiontoolurl
        };

		quicksearches = com.TI.rst.langStore.quickSearches;

    var currentDomain = window.location.hostname;

		if(window.location.href.indexOf('/space-high-reliability/') > 0){
			isCustomQS = true;

			if (!opts.standalone) {
				loadQS(quicksearches.space_hirel, params);
			}
		}
		else if (quicksearches[params.familyid]) {
			isCustomQS = true;

			if (!opts.standalone) {
				loadQS(quicksearches[params.familyid], params);
			}
		} else {
			isCustomQS = false;
		}

		RiotControl.on("qs_init2", function(_colData){
			var c = _colData.length,
				i = 0,
				bad = 0,
				filterCount = c;
			if(c > 6){
				for (i = 0; i < c; i++) {
					var cid = _colData[i].cid;
					bad = cid == "o1"? bad + 1: bad;
					bad = cid == "o4"? bad + 1: bad;
					bad = cid == "o7"? bad + 1: bad;
					bad = cid == "p1130"? bad + 1: bad;
				}
				filterCount = c - bad;
			}

			if( !isCustomQS ) {
				if (params.allParts.length <= 9 || filterCount <= 6) {
					self.root.remove();  // remove qs area completely if small result set
				} else {
					var script = document.createElement("script"),
						head = document.getElementsByTagName("head")[0];


					if(head != undefined){
						com.TI.rst.aqsData = function(data){
							if (data.topParameters !== undefined) {
								var topParCount = data.topParameters.length,
									goodParams = [],
									topParCount = data.topParameters.length;
								if (topParCount > 0) {
									for (i = 0; i < topParCount; i++) {
										var param = data.topParameters[i];
										if(param.parameterId !="o7" && param.parameterId !="p1130" && param.parameterId !="o4" && param.parameterId !="o1"){
											goodParams.push(param);
										}
									}
									if(goodParams.length > 0){
										params.topParameters = goodParams;
										loadQS('auto', params);  // load aqs tag
									}
								}
							}
							head.removeChild(script);
						};
						function jsonp(url) {
							script.setAttribute("src", url);
							head.appendChild(script);
						};
						jsonp("//"+ currentDomain + "/assets/js/selectiontool/automatedQS/" + params.familyid + ".json?callback=ti");
					}
				}

			}

			if (params.familyid != 3054) { // no param searches for LED

				var base = com.TI.rst.langStore.URLs.SERVER_BASE;

				if (document.domain.indexOf('.dhcp.ti.com') > -1) {
					base = 'http://www-int.itg.ti.com'; // use int
				}

				var svc = com.TI.rst.langStore.URLs.REST.replace('!!familyId!!', params.familyid);
				var url = base + svc;


				var loadParamSearches = function(response) {

					if (!utils.isEmpty(response.data) && !utils.isEmpty(response.data[0].links)) {

						params.prefetch = response.data[0].links;

						riot.mount(psDiv, "ti-param-search", params);

						self.psloaded = true;
						self.update();

					} else {

					}
				}

				var errorParamSearches = function(response) {

					if (response.status == 404) {
						console.info('No one-click parameters found for family id ' + params.familyid);
					} else {
						console.warn('No results for one-click parameters query');
					}
				}

				utils.loadJSON(url, loadParamSearches, errorParamSearches);

			}
		});
    });


    
});

riot.tag('ti-range-slider', '<div name="slider"></div> <div class="range1"> <input name="min" size="2" type="text" onchange="{ changedVal }" style="width:48px;" > <div class="filterUnit">{ units }</div> </div> <div class="range2" style="margin-top:0px;"> <input name="max" size="2" type="text" onchange="{ changedVal }" style="width:48px;" > <div class="filterUnit">{ units }</div> </div>', 'class="sliderContainer"', function(opts) {
        var self = this,
			filter,
			sliderType,
			sliderValues,
			minVal,
			maxVal,
			utils = com.TI.util;

        self.on('mount', function() {
			if(opts.filter.type !== "S") {
				return;
			}
			filter = opts.filter;
			sliderType = filter.sliderType;
			sliderValues = filter.vals;
			initValues = filter.prefilter;
			minVal = parseFloat(sliderValues[0].v);
			maxVal = parseFloat(sliderValues[sliderValues.length -1].v);
			self.id = filter.cid;
			self.units = filter.units;
			self.min.value = minVal;
			self.max.value = maxVal;

			createSlider();

			if (filter.sliderFn !== undefined) self.onSliderChange = filter.sliderFn;

			self.slider.noUiSlider.on('change', function( values, handle ) {
				if (sliderType === "top") {
					self.max.value = values[0];
				} else if (sliderType === "bot") {
					self.min.value = values[0];
				}
				else {
					self.min.value = values[0];
					if (values.length > 1) {
						self.max.value = values[1];
					}
				}
				self.onSliderChange(self.getSliderData());
			});
		});
        function createSlider() {
			var rangeSlider = self.slider,
				sliderOptions = {},
				sliderConnect,
				sliderRange = {},
				startValue = [],
				decimalPrecision = 0;

			if(sliderType === "bot"){
				startValue = initValues[0] || [minVal];
				self.min.value = initValues[0] || [minVal];
				sliderConnect = "upper";
				self.max.disabled = true;
			}else if(sliderType === "top"){
				startValue = initValues[1] || [maxVal];
				self.max.value = initValues[1] || [maxVal];
				sliderConnect = "lower";
				self.min.disabled = true;
			}
			else{
				startValue = (initValues.length == 2 ? [initValues[0], initValues[1]] : [minVal, maxVal]);
				self.min.value = initValues[0] || [minVal];
				self.max.value = initValues[1] || [maxVal];
				sliderConnect = true;
			}

			decimalPrecision = (decimalPrecision < utils.decimalPlaces(minVal)) ? utils.decimalPlaces(minVal) : decimalPrecision;
			decimalPrecision = (decimalPrecision < utils.decimalPlaces(maxVal)) ? utils.decimalPlaces(maxVal) : decimalPrecision;

			sliderRange['min'] = minVal;
			sliderRange['max'] = maxVal;

			if (sliderValues.length > 2 && filter.snap) {
				var snapDivide = (100/sliderValues.length),
					i;
				for (i=1; i<sliderValues.length - 1; i++) {
					var tmpVal = parseFloat(sliderValues[i].v),
						tmpKey = ((snapDivide*i).toFixed(2)+"%");

						decimalPrecision = (decimalPrecision < utils.decimalPlaces(tmpVal)) ? utils.decimalPlaces(tmpVal) : decimalPrecision;
						sliderRange[tmpKey] = tmpVal;
				}
			}
			sliderOptions.start = startValue;
			sliderOptions.snap = filter.snap;
			sliderOptions.connect = sliderConnect;
			sliderOptions.range = sliderRange;
			sliderOptions.format = {
				to : function(value) {
					return value.toFixed(decimalPrecision);
				},
				from : function(value) {
					return value;
				}
			};
			noUiSlider.create(rangeSlider, sliderOptions);
        }
		self.changedVal = function() {
			var curVals = [];

			if (sliderType == "top") {
				var maxvalue = self.max.value.replace(/[^\-0-9.,]/g, '');
				curVals = [maxvalue];
				self.max.value = maxvalue;
			} else if (sliderType == "bot") {
				var minvalue = self.min.value.replace(/[^\-0-9.,]/g, '');
				curVals = [minvalue];
				self.min.value = minvalue;
			} else {
				if (self.max) {
					var maxvalue = self.max.value.replace(/[^\-0-9.,]/g, '');
					var minvalue = self.min.value.replace(/[^\-0-9.,]/g, '');
					curVals = [minvalue, maxvalue];
					self.max.value = maxvalue;
					self.min.value = minvalue;
				} else {
					var minvalue = self.min.value.replace(/[^\-0-9.,]/g, '');
					curVals = [minvalue];
					self.min.value = minvalue;
				}
			}
			if (self.slider.noUiSlider !== undefined) {
				self.slider.noUiSlider.set(curVals);
				self.onSliderChange(self.getSliderData());
			}
		}
		self.resetSlider = function() {
			self.min.value = minVal;
			self.max.value = maxVal;
			if(self.slider.noUiSlider !== undefined){
				var defaultValues = [];
				if(sliderType == "top"){
					defaultValues = [maxVal];
				}
				else if (sliderType == "bot") {
					defaultValues = [minVal];
				} else{
					defaultValues = [minVal, maxVal];
				}
				self.slider.noUiSlider.set(defaultValues);
			}
		}
		self.getSliderData = function() {
			var sliderVals = {};
			var sliderData = {};

			sliderVals.min = Number(self.min.value);
			if (self.max) {
				sliderVals.max = Number(self.max.value);
			}
			sliderData['cid'] = self.id;
			sliderData['val'] = sliderVals;

			return sliderData;
		}
    
});

riot.tag('ti-rst-cell', '<span name="phchk"></span> <a onclick="{ clickHandler }" href="{ link }" name="phlink">{ linkLabel }</a> <span name="phtext">- { text } </span> <span name="hirel">- <span class="label-red">Hi-Rel</span> </span> <span name="newPart">- <span class="label-red">New</span> </span>', 'data-filename="{ image }" data-ods="{ ods }" data-qgpn="{ qgpn }" data-status="{ pstatus }"', function(opts) {
	var self = this,
		params,
		thisCheck;

	var langStore = com.TI.rst.langStore;

	self.linkLabel = "";
	self.text = "";
	self.link = "#";
	self.image = "";
	self.qgpn = "";
	self.pstatus = "";
	self.ods = "";

	self.clickHandler = function(){
		return true;
	};

	self.on("mount",function(){
		params = opts.params;



		if ( typeof(params.label) != 'undefined' ) {
			thisCheck = riot.mount(self.phchk, "ti-check-box", {
				ontoggle : toggleCheck
			});
			self.linkLabel = params.label;
			self.text = (typeof(params.desc) != 'undefined' ? params.desc : '');
			self.image = params.image;
			self.qgpn = params.qgpn;
			self.pstatus = params.pstatus;
			self.ods = params.ods || '';
			self.link = com.TI.rst.langStore.URLs.SERVER_BASE + langStore.URLs.PRODUCTFOLDER_BASE + "/" + params.qgpn.toLowerCase();

			if (Array.isArray(self.pstatus))  self.pstatus = self.pstatus.join('/');

			self.clickHandler = function(){
				return false;
			};
			if (self.text == '') self.phtext.remove();
			if (params.hirel !== "Y") self.hirel.remove();
			if (params.newPart !== "Y") self.newPart.remove();
		} else {
			self.phchk.remove();
			self.hirel.remove();
			self.newPart.remove();
		}

		self.update();
	});

	function toggleCheck(){
		RiotControl.trigger("rst_part_toggled", self.linkLabel, thisCheck[0].checked);
	}

	
});
riot.tag('ti-rst-info-drawer', '<td colspan="{numCol}"> <div class="push-down-detail-area"><span class="close close-pushdown-btn" for="{cid.toLowerCase()}" onclick="{closeDrawer}"></span> <div class="row same-height"> <div class="c3"> <a href="{ langStore.URLs.SERVER_BASE + langStore.URLs.PRODUCTFOLDER_BASE }/{qgpn.toLowerCase() }" target="_ti-{cid.toLowerCase()}" clicktype="navigate" linktype="chipimage" linkid="{chipLinkTypeId}" class="trackedLink"><img clicktype="navigate" linktype="chipimage" linkid="{chipLinkTypeId}" name="img_chip" if="{imgOK.chip}" riot-src="{ langStore.URLs.TI_BASE }{ langStore.URLs.PARTIMAGES }{qgpn.toUpperCase()}.jpg" alt="{qgpn.toLowerCase()}"><a></a> </div> <div class="c3"> <h4><a href="{ langStore.URLs.SERVER_BASE + langStore.URLs.PRODUCTFOLDER_BASE }/{qgpn.toLowerCase() }" target="_ti-{cid.toLowerCase()}" clicktype="navigate" linktype="title" linkid="{titleLinkTypeId}" class="trackedLink">{cid.toUpperCase()} <span if="{status}" class="status">({status})</span><a></a></h4> <a href="{ langStore.URLs.SERVER_BASE + langStore.URLs.PRODUCTFOLDER_BASE }/{qgpn.toLowerCase()}/samplebuy" class="buy-sample trackedLink" target="_ti-{cid.toLowerCase()}" clicktype="navigate" linktype="buy" linkid="{buyLinkTypeId}">{ langStore.strings.SAMPLEBUY }</a> <ul class="pdf"> <li if="{ods != \'\'}" class="html"><a href="{ langStore.URLs.SERVER_BASE + langStore.URLs.PRODUCTFOLDER_BASE }/{qgpn.toLowerCase()}/datasheet" clicktype="navigate" linktype="ods" target="_ti-{cid.toLowerCase()}" class="trackedLink" linktype="ods" linkid="{odsLinkTypeId}">{ langStore.strings.ONLINEDATASHEET }</a></li> <li><a href="{langStore.URLs.SERVER_BASE + langStore.URLs.DATASHEET}/lit/gpn/{qgpn.toLowerCase()}" target="_ti-{cid.toLowerCase()}" clicktype="download" linktype="download" class="trackedLink" linkid="{downloadLinkTypeId}">{ langStore.strings.DOWNLOADDATASHEET }</a></li> </ul> <ul class="no-icon"> <li><a href="{ langStore.URLs.SERVER_BASE + langStore.URLs.PRODUCTFOLDER_BASE }/{qgpn.toLowerCase()}" target="_ti-{cid.toLowerCase()}" clicktype="navigate" linktype="desc" linkid="{desLinkTypeId}" class="trackedLink">{ langStore.strings.DESCRIPTIONPARAMETRICS }</a></li> <li><a href="{ langStore.URLs.SERVER_BASE + langStore.URLs.PRODUCTFOLDER_BASE }/{qgpn.toLowerCase()}/technicaldocuments" target="_ti-{cid.toLowerCase()}" clicktype="navigate" linktype="docs" linkid="{docsLinkTypeId}" class="trackedLink">{ langStore.strings.TECHNICALDOCUMENTS }</a></li> <li><a href="{ langStore.URLs.SERVER_BASE + langStore.URLs.PRODUCTFOLDER_BASE }/{qgpn.toLowerCase()}/toolssoftware" target="_ti-{cid.toLowerCase()}" clicktype="navigate" linktype="tools" linkid="{toolsLinkTypeId}" class="trackedLink">{ langStore.strings.TOOLSSOFTWARE }</a></li> <li><a href="{ langStore.URLs.SERVER_BASE + langStore.URLs.PRODUCTFOLDER_BASE }/{qgpn.toLowerCase()}/quality" target="_ti-{cid.toLowerCase()}" clicktype="navigate" linktype="qual" linkid="{qualLinkTypeId}" class="trackedLink">{ langStore.strings.QUALITYPACKAGING }</a></li> <li><a href="{ langStore.URLs.SERVER_BASE + langStore.URLs.PRODUCTFOLDER_BASE }/{qgpn.toLowerCase()}/support" target="_ti-{cid.toLowerCase()}" clicktype="navigate" linktype="support" linkid="{supportLinkId}" class="trackedLink">{ langStore.strings.SUPPORTTRAINING }</a></li> </ul> </div> <ti-rst-webench-panel partnumber="{cid}" familyid="{familyid}" class="c3"></ti-rst-webench-panel> <div class="c3 stretch borderLeft"> <div if="{imgOK.fdiag}"> <h5>{ langStore.strings.FUNCTIONALDIAGRAM }</h5> <div class="row"> <div name="diagThumb" class="diagram-zoom" onclick="{fdToggle}" linktype="diag" clicktype="toggle" linkid="{diagramShowLinkTypeId}"><img name="img_fDiag" linktype="diag" clicktype="toggle" linkid="{diagramShowLinkTypeId}"></div> </div> </div> </div> </div> <div if="{showZoom}" name="fdZoom" class="row diagram-box" style="overflow: hidden;"> <span class="close close-diagram-btn" for="{cid.toUpperCase()}" onclick="{fdClose}" clicktype="toggle" linkid="{diagcloseLinkTypeId}"></span> <img name="img_fDiag_zoom" onclick="{openDiag}" linkid="{diagzoomLinkTypeId}" clicktype="zoom" style="cursor: pointer;" title="{langStore.strings.CLICKFULLSIZE}" alt="{langStore.strings.CLICKFULLSIZE}"> <button class="print" onclick="{printDiag}" clicktype="print" linkid="{diagprintLinkTypeId}">{ langStore.strings.PRINT }</button> </div> </div> </td>', 'class="push-down-row" id="rstid_{cid}"', function(opts) {

		langStore = com.TI.rst.langStore;

		var googlePrefix = "parametric_selection_",
			drawerPrefix = "part_rolldown_";

		var self = this, links;

		self.lastQ = {};
		self.cid = '';
		self.img = '';
		self.numCol = '';
		self.status = '';
		self.ods = '';
		self.parentRow = '';
		self.parentClass = 'push-down-opened';
		self.qgpn = '';

		self.showZoom = false;

		self.imgOK = {}
		self.imgOK.chip = false;
		self.imgOK.fdiag = false;
		self.imgOK.fdiag_zoom = false;
		drawerMetrics = function(event) {
			if (event) {
				event.stopPropagation();
				var ele = event.target || event.srcElement,
					linkParams = {
						action: "drawerLink",
						clickType: ele.getAttribute("clicktype"),
						errorMsg: 'GA _tiAT link track error',
						familyId: opts.family,
						linkType: ele.getAttribute("linktype"),
						linkId: ele.getAttribute("linkid"),
						partNumber: self.cid,
						trackType: 'selection tool link click'
					};
				RiotControl.trigger("rst_metrics", linkParams);
			}
		}

		function getImg(ele) {
			var currentEle = ele,
				prevEle = ele.previousSibling,
				c = 0,
				found = true;
			while (prevEle.tagName === undefined || prevEle.tagName !== "IMG") {
				prevEle = prevEle.previousSibling;

				c++;
				if (c === 10) {
					found = false;
					break;
				}
			}
			return prevEle;
		}

		self.on('mount', function(){
			self.cid = (opts.cid ? opts.cid : '');
			self.img = (opts.img ? opts.img : false);
			self.ods = (opts.ods ? opts.ods : '');
			self.qgpn = (opts.qgpn ? opts.qgpn : opts.cid);
			self.status = (opts.status ? opts.status : 0);
			self.numCol = (opts.numCol ? opts.numCol : 0);
			self.parentRow = (opts.parentRow ? opts.parentRow : '');
			self.parentClass = (opts.parentClass ? opts.parentClass : 'push-down-opened');
			self.lastQ = opts.lastQ ? opts.lastQ : '';
			self.familyid = (opts.family ? opts.family : '');

			RiotControl.trigger("rst_webench_panel", {partnumber:self.cid, familyid:self.familyid});

			if (self.img && self.img.toString().trim().length > 1) {
				self.img_fDiag.src = langStore.URLs.TI_BASE + langStore.URLs.FUNCTTHUMBS + self.img;
				self.img_fDiag_zoom.src = langStore.URLs.TI_BASE + langStore.URLs.FUNCTDIAGRAMS + self.img;
			}

			self.img_chip.onload = function() {
				self.imgOK.chip = true;
				self.update();
			}

			self.img_fDiag.onload = function() {
				self.imgOK.fdiag = true;
				self.update();
			}

			self.img_fDiag_zoom.onload = function() {
				self.imgOK.img_fdiag_zoom = true;
				self.update();
			}

			if (self.parentRow != '') {
				com.TI.util.addClass(self.parentRow, self.parentClass);
			}

			var metricsParams = {
				action: "infoDrawer",
				partNumber: self.cid
			};

 			RiotControl.trigger("rst_metrics", metricsParams);
            RiotControl.trigger("rst_webench_panel", self.cid);
 			self.update();
		});

		self.on('update', function(){
			self.buyLinkTypeId = 'st_main_ordernow_' + self.qgpn.toLowerCase();
			self.chipLinkTypeId = 'st_main_chipimage_' + self.qgpn.toLowerCase();
			self.desLinkTypeId = 'st_main_description_' + self.qgpn.toLowerCase();
			self.diagcloseLinkTypeId = 'st_main_diagramclose_' + self.qgpn.toLowerCase();
			self.diagprintLinkTypeId = 'st_main_diagramprint_' + self.qgpn.toLowerCase();
			self.diagramShowLinkTypeId = 'st_main_diagramtoggle_open_' + self.qgpn.toLowerCase();
			self.diagramHideLinkTypeId = 'st_main_diagramtoggle_close_' + self.qgpn.toLowerCase();
			self.diagzoomLinkTypeId = 'st_main_diagramzoom_' + self.qgpn.toLowerCase();
			self.downloadLinkTypeId = 'st_main_datasheet_' + self.qgpn.toLowerCase();
			self.docsLinkTypeId = 'st_main_techdocs_' + self.qgpn.toLowerCase();
			self.odsLinkTypeId = 'st_main_onlinedataheet_' + self.qgpn.toLowerCase();
			self.qualLinkTypeId = 'st_main_qualitypackaging_' + self.qgpn.toLowerCase();
			self.supportLinkId = 'st_main_support_' + self.qgpn.toLowerCase();
			self.titleLinkTypeId = 'st_main_partnumber_' + self.qgpn.toLowerCase();
			self.toolsLinkTypeId = 'st_main_toolsw_' + self.qgpn.toLowerCase();

			links = self.root.getElementsByClassName('trackedLink');
			for(var i=0; i<links.length; i++) {
				links[i].addEventListener("click", drawerMetrics);
			}

		});

		self.printDiag = function(e) {
			var ele = getImg(e.srcElement);
			var img = ele.src;
			var isIE11 = navigator.userAgent.match(/Trident.*rv[ :]*11\./);
			var isIE = navigator.userAgent.match(/MSIE/);
			if (img) {
				var dw = window.open("about:blank", "_new");
				dw.document.open();
				dw.document.write('<html><head><script>setTimeout("window.print()",1000)<\/script><\/head><body><img src="' + img + '"></body></html>');
				if (isIE || isIE11) dw.location.reload(); //ie wont start print dialog on first load
			};
			drawerMetrics(e);
		}

		self.openDiag = function(e) {
			var ele = e.srcElement;
			var img = ele.src;
			var isIE11 = navigator.userAgent.match(/Trident.*rv[ :]*11\./);
			var isIE = navigator.userAgent.match(/MSIE/);
			if (img) {
				var dw = window.open("about:blank", "_new");
				dw.document.open();
				dw.document.write('<html><head><\/head><body><img src="' + img + '"></body></html>');
			};
			drawerMetrics(e);
		}

		self.fdClose = function(e) {
			drawerMetrics(e);
			self.fdToggle();
		}

		self.fdToggle = function(e) {
			if (self.showZoom) {
				self.showZoom = false;
				com.TI.util.removeClass(self.diagThumb, "zoomed");
				drawerMetrics(e);
				self.diagThumb.setAttribute("linkid", self.diagramShowLinkTypeId);
				self.img_fDiag.setAttribute("linkid", self.diagramShowLinkTypeId);
			} else {
				self.showZoom = true;
				com.TI.util.addClass(self.diagThumb, "zoomed");
				drawerMetrics(e);
				self.diagThumb.setAttribute("linkid", self.diagramHideLinkTypeId);
				self.img_fDiag.setAttribute("linkid", self.diagramHideLinkTypeId);
			}
			self.update();
		}

		self.closeDrawer = function(who) {

			if (typeof(who) !== 'string') {	// if the global close is triggered, who will be a string (cid or 'all'), otherwise its the close button mouseevent
				linkParams = {
					action: "closeDrawer",
					clickType: 'toggle',
					errorMsg: 'GA _tiAT link track error',
					familyId: opts.family,
					linkId: 'st_main_drawerclose_' + self.qgpn.toLowerCase(),
					linkType: 'closeDrawer',
					partNumber: self.cid,
					trackType: 'selection tool link click'
				};
				RiotControl.trigger("rst_metrics", linkParams);
			}

			if (self.parentRow != '') {
				com.TI.util.removeClass(self.parentRow, self.parentClass);
			}
			self.root.remove();
		}

		RiotControl.on('closeDrawer', function(who) {
			if (who == self.cid || who == 'all') {
				self.closeDrawer(who);
			}
		})

	
});
riot.tag('ti-rst-simple-cell', '<span each="{item, i in items}" > <span show="{ item.isLink === false}" style="white-space:nowrap" name="itemtext" >{ item.text }<span show="{ i < items.length - 1 }" style="white-space:nowrap">,<br></span></span> <span show="{ item.isLink === true}" style="white-space:nowrap" name="celllink" onclick="{clickHandler}" style="height:100%; width:100%;"> {item.prep} <a name="celllink" href="{linkUrl}" target="_ti-\' + {cid.toLowerCase()} + \'" class="trackedLink" linktype="ods" name="{odsLinkTypeId}">{ item.text }</a> {item.app}<span show="{ i < items.length - 1 }" style="white-space:nowrap">,<br></span> </span> </span>', 'data-filename="{ image }" data-ods="{ ods }" data-qgpn="{ qgpn }" data-status="{ pstatus }"', function(opts) {
	var self = this;

	self.clickHandler = function(e) {
		window.open(self.linkUrl);
	};

	self.on("mount",function(){
		var textItems = opts.params.textValues,
			isLink = false,
			items = [],
			itemCount = textItems.length,
			i = 0;
			params = opts.params;
		self.cid = params.cid;
		self.linkUrl = com.TI.rst.langStore.URLs.DATASHEET + "/lit/gpn/" + params.qgpn.toLowerCase();

		self.odsLinkTypeId = "&lid=parametric_selection_online_datasheet_" + params.family + "_" + params.qgpn;
		for(i = 0; i < itemCount; i++){
		if(textItems[i] !== undefined){
			var item = {},
				text = textItems[i];
			if(text.trim().toLowerCase().indexOf("see datasheet") < 0){
				var grp = self.cid;


			if(grp === "p2954" || "p1811"){
				item.text = text.replace('|', '\xa0' + '|' + '\xa0' );
				}
				else {
					item.text = text;
				}
				item.prep = ""
				item.app = "";
				item.isLink = false;
				items.push(item);
				}else{
					var n = text.trim().toLowerCase().indexOf("see datasheet");
					item.prep = text.substring(0, n);
					item.text = com.TI.rst.langStore.strings.SEEDATASHEET;
					item.app = text.substring(n + 13);
					items.push(item);
					item.isLink = true;
				}
			}
		}
		self.items = items;
		self.update();
	});
	
});

riot.tag('ti-rst-webench-panel', '<div id="webenchControl_{cid.toLowerCase()}"></div>', '.wbsearch-panel-table td { padding-left: 0.25em !important; } .wbsearch-panel-table { border: 0; } .wbsearch-panel-table td:hover, .wbsearch-panel-table tr:hover { background: #FFF; }', function(opts) {
	var self = this;
	self.cid = '';
	self.familyid = '';

	self.on("mount",function(){
		self.cid = (typeof(opts.partnumber) !== 'undefined' ? opts.partnumber : '');
		self.familyid =  (typeof(opts.familyid) !== 'undefined' ? opts.familyid : '');
		if (self.cid !== '') {
			self.trigger("rst_webench_panel", {partnumber:self.cid, familyid:self.familyid});
		}
	});



	self.on("rst_webench_init", function() {
    	if (typeof(com.TI.wbpanel) == 'undefined') {  // try loading wb files on demand
    		var wbcss = document.createElement('link');
    		wbcss.setAttribute('rel', 'stylesheet');
			wbcss.setAttribute('type', 'text/css');
        	wbcss.setAttribute('href', langStore.URLs.WBCSS);

        	var wbjs = document.createElement('script');
			wbjs.setAttribute('type',"text/javascript");
			wbjs.setAttribute('src', langStore.URLs.WBJS);

			if ((document.documentMode || /Edge/.test(navigator.userAgent))) {
				wbjs.setAttribute('crossorigin', 'use-credentials');
			}

			document.getElementsByTagName("head")[0].appendChild(wbcss);
			document.getElementsByTagName("head")[0].appendChild(wbjs);

			wbjs.onload = function () { self.trigger('rst_webench_panel', {partnumber:self.cid, familyid:self.familyid}) };
    	}
	});

    self.on("rst_webench_panel", function(params) {

		if (typeof(com.TI.wbpanel) != 'undefined') {

		    var lastQuery = {},
				vinMin = "0",
		        vinMax = "0",
		        vout = "0",
		        iout = "0",
		        isParams = false;

			_lastQuery = com.TI.rst.partStore.lastQuery();
		    for(cid in _lastQuery) {
		        if(_lastQuery.p238min !== undefined) { vinMin = _lastQuery.p238min.values[1]; isParams = true; }
		        if(_lastQuery.p238max !== undefined) { vinMax = _lastQuery.p238max.values[0]; isParams = true; }
		        if(_lastQuery.p634max !== undefined) { vout = _lastQuery.p634max.values[0]; isParams = true; }
				if (params.familyid === "433" || params.familyid === "752" || params.familyid === "756" || params.familyid === "2137") {
					if(com.TI.rst.user_inputs && com.TI.rst.user_inputs.iout !== undefined) { iout = com.TI.rst.user_inputs.iout; isParams = true; }
				}
				else {
					if(_lastQuery.p451max !== undefined) { iout = _lastQuery.p451max.values[0]; isParams = true; }
				}
		    }
		    if(isParams) {
		        if(vinMax === "0" && vinMin !== "0") { vinMax = vinMin; }
		        com.TI.wbpanel.wbConfigParams(params.partnumber, vinMin, vinMax, vout, iout);
		    } else {
		        com.TI.wbpanel.wbConfig(params.partnumber);
		    }
		} else {
			self.trigger('rst_webench_init');
		}
    });


	
});
riot.tag('ti-selection-tool', ' <ti-quick-searches standalone="{standalone}" selectiontoolurl="{selectiontoolurl}"></ti-quick-searches> <div class="spinner-target rst-overflow-area" if="{!standalone}"> <div name="spinnercontainer" class="spinner-container hidden"><div class="spinner"></div></div> <ti-filters name="filterstag"></ti-filters> <ti-data-table name="resultstag" family="{fId}"></ti-data-table> </div>', 'class="rst"', function(opts) {

		var rst = this,
			utils = com.TI.util,
			metricsMixin = new com.TI.rst.MetricsMixin(),
			globalRoute = true;

		rst.standalone = false;
		rst.selectiontoolurl = '';

		rst.mixin(metricsMixin);
		rst.pushTime(new Date().getTime());

		rst.hideFiltersLabel = "";
		rst.feedBackLabel = "Feedback";

		rst.feedBackLabelBanner = "";
		rst.introText = "";
		rst.introLinkLabel = "";
		rst.lang = "";

		var defaultLang = "en";
		if (window.location.href.indexOf('ti_zh') > -1 || window.location.href.indexOf('.cn/') > -1 || window.location.href.indexOf('-cn-') > -1) defaultLang = "cn";
		else if (window.location.href.indexOf('ti_ja') > -1 || window.location.href.indexOf('.jp/') > -1 || window.location.href.indexOf('-jp-') > -1) defaultLang = "jp";
		else if (window.location.href.indexOf('ti_ko') > -1) defaultLang = "kr";
		else if (window.location.href.indexOf('ti_de') > -1) defaultLang = "de";



		
		var defaults = {
			lang : defaultLang,
			basePath : com.TI.rst.langStore.langURLs[defaultLang.toUpperCase()].SERVER_BASE + com.TI.rst.langStore.langURLs[defaultLang.toUpperCase()].DATA_SERVICE,
			familyid : "72",
			expandedFilters : 3,
			stagger : 25,
			vfilter : ''
		};
		utils.removeClass(rst.spinnercontainer, 'hidden');

		rst.on("mount", function() {
			var urlParams = utils.getParams();
			var	lang = urlParams.lang || opts.lang || defaults.lang;



			com.TI.rst.langStore.setLanguage(lang);

			var	basePath = opts.basePath || defaults.basePath;
			var	familyid = urlParams.familyid || opts.familyid || defaults.familyid;
			var	userLevel = parseInt(urlParams.userlevel) || getUserLevel();
			var	vfilter = urlParams.filter || opts.filter || defaults.vfilter;
			var pqsRef = urlParams.pqs || 'n/a'; // was this referred from a pqs?

    		if (opts.selectiontoolurl) { rst.selectiontoolurl = opts.selectiontoolurl };
			rst.standalone = (opts.standalone !== undefined && (opts.standalone === true || opts.standalone === '' || opts.standalone.toString().toLowerCase() === 'true') ? true : false);

			rst.fId = familyid;

			if(urlParams.unittest) basePath = "./data/unitTests/";

			rst.feedBackLabel = com.TI.rst.langStore.strings.FEEDBACK;
			rst.feedBackLabelBanner = com.TI.rst.langStore.strings.BETA_FEEDBACK;
			rst.introText = com.TI.rst.langStore.strings.INTRO_TEXT;
			rst.introLinkLabel = com.TI.rst.langStore.strings.INTRO_LINK;
			rst.hideFiltersLabel = com.TI.rst.langStore.strings.HIDEFILTERS;
			rst.lang = lang;
			rst.setFam(familyid);

			if((opts.async != "") || (opts.async != undefined) ) {
				async = opts.async;
			}

			var baseUrl, criteriaUrl, resultsUrl,
			topFiltersUrl,
				tmpLang = (lang.toLowerCase() == "kr" || lang.toLowerCase() == "de") ? "en" : lang.toLowerCase();
			if (basePath.indexOf("!!familyId!!") == -1) {
				baseUrl = basePath + tmpLang + '/' + familyid;
				criteriaUrl = baseUrl + '_criteria.js';
				resultsUrl = baseUrl + '_results.js';
				topFiltersUrl = com.TI.rst.langStore.URLs.SERVER_BASE + com.TI.rst.langStore.URLs.AUTOQS + tmpLang + '/' + familyid + '.json';
			} else {
				baseUrl = basePath.replace("!!lang!!",tmpLang).replace("!!familyId!!", familyid);
				criteriaUrl = baseUrl.replace("!!type!!", "criteria");
				resultsUrl = baseUrl.replace("!!type!!", "results");


				if (vfilter != '') {
					resultsUrl += '&filter=' + vfilter;
				}
			}
			rst.topFiltersUrl = topFiltersUrl;



			var rawSettings,
				rawResults;



			var indexColumns, indexParts, initialNumber, initialFilters;

			function errorWebService(xhr){
				console.log(xhr);
			}




			function checkWebServices(data){
				if (data.ParametricControl !== undefined) rawSettings = data.ParametricControl;
				if (data.ParametricResults !== undefined) rawResults = data.ParametricResults;
				if (rawSettings !== undefined && rawResults !== undefined) {
					initSelectionTool(rawResults.length);
				}
			}



			function initSelectionTool(resultCount){
       			
				console.log('Init Sel Tool');
				
				rst.pushTime(new Date().getTime());
				setTimeout(function(){
					utils.addClass(rst.spinnercontainer, 'hidden');
				},1000);

				var extraCols = (userLevel == 1) ? 2 : 1; //2 extra cols (o1/desc and o7/subfam) if sales person, only 1 otherwise

				utils.nsExtend(window,'com.TI.rst');

				results = processResults();

				fix1811();

				indexColumns = generateIndex(rawSettings.controls,'cid');
				if (indexColumns["o4"] !== undefined ) indexColumns["o4"].order = 99999;
				indexParts = generateIndex(results,'o1');
				initialNumber = parseInt(rawSettings.initialNumber) + extraCols;
				initialFilters = {};

				var initialHash = decodeURI(window.location.hash).replace(/\s/g, '%20').replace("#","");


				initialHash = initialHash.replace(new RegExp(' & ', 'g'), '%20%26%20');
				initialFilters = com.TI.rst.generateQuery(initialHash, indexColumns);

				RiotControl.trigger('rst_init', {
					famId : familyid,
					lang : lang,
					colDef : indexColumns,
					partDef : indexParts,
					initialNumber : initialNumber,
					stagger: defaults.stagger,
					userLevel: userLevel,
					expandedFilters : defaults.expandedFilters, //todo : make this configurable by url
					metricsMixin : metricsMixin,
					initialFilters : initialFilters,
					standalone : rst.standalone,
					pqsRef : pqsRef
				});

			}

			riot.route(function(query){
				console.log("routing")
				var q = com.TI.rst.generateQuery(query, indexColumns);
				if (globalRoute && !utils.isEmpty(q)) {
					RiotControl.trigger("rst_qs_col_update", [], q);
	            	RiotControl.trigger("rst_filter", q);
	            	RiotControl.trigger("rst_apply", undefined, undefined, undefined, undefined, "hash");
	            } else {
	            	globalRoute = true;
	            }
			});

			function fix1811(){
				var i,
					len = rawSettings.controls.length,
					fixCid,
					fixType,
					oldVals,
					colIndex;
				for (i=0; i<len; i++) {
					fixCid = rawSettings.controls[i]["cid"];
					fixType = rawSettings.controls[i]["controlType"];
					if (fixCid === "p1811") {
						if (fixType === "S") break;
						colIndex = i;
						oldVals = rawSettings.controls[i].properties.values;
						break;
					}
				}

				if (colIndex === undefined) return;
				len = oldVals.length;
				for (i=0; i<len; i++) oldVals[i] = fixPf(oldVals[i]);
				rawSettings.controls[colIndex].properties.values = oldVals.getUnique();
			}

			function generateIndex(arr,key){
				var indexObj = {},
					i,
					len,
					cKey;

				len = arr.length;
				for (i=0;i<len;i++){
					cKey = arr[i][key];
					if (cKey === "o7" && arr[i].properties.values.length < 2) continue;
					indexObj[cKey] = arr[i];
				}
				return indexObj;
			}

			function processResults(){

				var retResults = [],
					i,
					len = rawResults.length;
				for (i=0;i<len;i++){
					retResults.push(processPart(rawResults[i]));
				}
				return retResults;
			}

			function processPart(partObj){
				var retPart = {},
					cid,
					cVal;

				for (cid in partObj) {
					cVal = partObj[cid];

					if (typeof cVal === 'object' && cVal.multipair1 !== undefined) cVal = processMultiPair(cVal, cid);
					else if (cVal.indexOf('^') > -1) cVal = processCarrot(cVal, cid);
					else if (cid == "p1811") cVal = [fixPf(cVal)];
					else if (cid.indexOf('o') !== 0 || cid === "o4" || cid === "o7") cVal = [cVal];

					retPart[cid] = cVal;
				}
				return retPart;
			}

			function processCarrot(val, cid){
				var valArr = val.split('^');
				if (cid !== "p1811") return valArr;
				var i, len = valArr.length;
				for (i=0; i<len; i++) {
					valArr[i] = fixPf(valArr[i]);
				}
				return valArr;
			}

			function processMultiPair(val, cid){
				var retArr = [],
					multipair,
					cVal;
				for (multipair in val) {


					cVal = val[multipair];
					if (cid !== undefined && cid === 'p1811') {
						cVal.l = fixPf(cVal.l);
					}
					retArr.push(cVal)
				}
				return retArr;
			}

			function fixPf(val) {
				if (typeof val !== "string") return val;

				else if (val.indexOf("See") > -1) return val;
				var tmpIndex,
					tmpVal;
				tmpIndex = val.indexOf("[/pf]");
				tmpVal = val.substr(tmpIndex + 7).split(",")[0];
				return tmpVal;
			}

			function getRole(cookieInfo){
				var ret = "",
					rStart,
					rEnd;
				rStart = cookieInfo.indexOf("role=");
				if (rStart > -1) {
					rEnd = cookieInfo.indexOf("|", rStart);
					if (rEnd === -1) rEnd = cookieInfo.length;
					ret = cookieInfo.substring(rStart+5, rEnd);
				}
				return ret;
			}

			function getUserLevel(){
				var userLevel = 0,
					tiCookie = utils.getCookie("TIPASSID"),
					role = "";
				if (!utils.isEmpty(tiCookie)) role = getRole(tiCookie).toLowerCase();
				if (role === "field sales")	userLevel = 1;
				return userLevel;
			}

			rst.update();

			utils.loadJSON(criteriaUrl,checkWebServices,errorWebService);
			utils.loadJSON(resultsUrl,checkWebServices,errorWebService);

		});

		function q2string(q) {
			var ret = "",
				cid,
				qItem;

			for (cid in q) {
				qItem = q[cid];
				if (qItem.type === "AND") ret += "~";
				else if (qItem.type === "NOT") ret += "!";
				ret += cid;
				ret += "=";
				ret += qItem.values.join(";");
				ret += "&";
			}
			ret = ret.substr(0, ret.length-1);
			return ret;
		}
		RiotControl.on("rst_loading", function(isLoading){
			if (typeof isLoading == "boolean" && isLoading) {
				utils.removeClass(rst.spinnercontainer, 'hidden');
			} else {
				utils.addClass(rst.spinnercontainer, 'hidden');
			}

		});

		RiotControl.on("rst_update_hash", function(q){
			globalRoute = false;
			window.location.hash = q2string(q);
		});

	
});

riot.tag('ti-slider-nui', '<div name="slider"></div> <div class="range1"> <input name="min" size="2" type="text" onchange="{ changedVal }" > <div class="filterUnit">{units}</div> </div> <div class="range2"> <input name="max" size="2" type="text" onchange="{ changedVal }" > <div class="filterUnit">{units}</div> </div>', 'class="sliderContainer"', function(opts) {

		var self = this,
			sliderOptions = {},	// slider config options object
			utils = com.TI.util,
			tmpInput = [];

		self.id = 'slider';
		self.decimals = 0;
		self.rangeMin = null;
		self.rangeMax = null;
		self.sliderType = '';
		self.units = '';

		var stringIsValidNumber = function(numberString){
			var floatNum = parseFloat(numberString);
			return !isNaN(floatNum);
		}

		self.onSliderChange = function(e) {
		};

		self.on("update", function(){
			self.id = (opts.id ? opts.id : 'slider');

			if (self.filter !== undefined && self.filter.applied !== undefined) {

				if(opts.slidertype !== "") self.initSliderControl('update');

				if (self.filter.applied.length > 0 && self.filter.applied.join() === self.filter.prefilter.join()) {
					self.min.value = self.filter.applied[0];
					self.max.value = self.filter.applied[1];
				} else if (self.filter.prefilter.length === 0 && self.filter.applied.length === 0){
					self.min.value = self.rangeMin;
					self.max.value = self.rangeMax;
				}

				self.changedVal(true);
			}
		});

		self.on("mount", function() {

			self.id = (opts.id ? opts.id : 'slider');

			if(opts.slidertype !== "") self.initSliderControl('create');

			self.slider.noUiSlider.on('update', function( values, handle ) {

				if (sliderOptions.sliderType == "top") {
					self.max.value = (tmpInput.length === 1 && stringIsValidNumber(tmpInput[0])) ? tmpInput[0] : values[0];
				} else if (sliderOptions.sliderType == "bot") {
					self.min.value = (tmpInput.length === 1 && stringIsValidNumber(tmpInput[0])) ? tmpInput[0] : values[0];
				} else {
					if (values.length === 2) {
						if (tmpInput[0] !== undefined && tmpInput[0] !== "" && tmpInput[0] !== values[0]) self.min.value = tmpInput[0];
						if (tmpInput[1] !== undefined && tmpInput[1] !== "" && tmpInput[1] !== values[1]) self.max.value = tmpInput[1];

						if (self.min.value === "") self.min.value = values[0];
						if (self.max.value === "") self.max.value = values[1];
					}
				}

				tmpInput = [];
			});

			self.slider.noUiSlider.on('change', function( values, handle ) {
				if (sliderOptions.sliderType == "top") {
					self.max.value = values[0];
				} else if (sliderOptions.sliderType == "bot") {
					self.min.value = values[0];
				} else {
					self.min.value = values[0];
					if (values.length > 1) {
						self.max.value = values[1];
					}
				}
				self.onSliderChange(self.getSliderData());
			});

		});

		self.initSliderControl = function(action) {
			if (opts.step !== undefined) sliderOptions.step = Number(opts.step);
			if (opts.snap !== undefined) sliderOptions.snap = opts.snap === "true";
			if (opts.direction !== undefined) sliderOptions.direction = opts.direction;
			if (opts.tooltip !== undefined) sliderOptions.tooltip = opts.tooltip;
			if (opts.onsliderchange !== undefined && typeof(opts.onsliderchange) == "function") self.onSliderChange = opts.onsliderchange;
			if (opts.slidertype !== undefined) {
				sliderOptions.sliderType = opts.slidertype; //top, bot, dual
				self.sliderType = opts.slidertype;
			}

			sliderOptions.range = {};
			var vals = opts.values;
			if (vals !== undefined && vals.length > 0) {
				var i,
					len = vals.length,
					isObj = vals[0].v !== undefined,
					minVal,
					maxVal,
					snapDivide,
					tmpVal,
					decimalPrecision = 0;

				if (isObj) {
					minVal = parseFloat(vals[0].v);
					maxVal = parseFloat(vals[len-1].v);
				} else {
					minVal = parseFloat(vals[0]);
					maxVal = parseFloat(vals[len-1]);
				}

				decimalPrecision = (decimalPrecision < utils.decimalPlaces(minVal)) ? utils.decimalPlaces(minVal) : decimalPrecision;
				decimalPrecision = (decimalPrecision < utils.decimalPlaces(maxVal)) ? utils.decimalPlaces(maxVal) : decimalPrecision;

				sliderOptions.range.min = minVal;
				sliderOptions.range.max = maxVal;

				self.rangeMin = minVal;
				self.rangeMax = maxVal;

				if (len > 2 && sliderOptions.snap) {
					snapDivide = 100/len;
					len--;
					for (i=1; i<len; i++) {
						if (isObj) tmpVal = vals[i].v;
						else tmpVal = vals[i];
						tmpVal = parseFloat(tmpVal);
						decimalPrecision = (decimalPrecision < utils.decimalPlaces(tmpVal)) ? utils.decimalPlaces(tmpVal) : decimalPrecision;
						sliderOptions.range[snapDivide*i+"%"] = tmpVal;
					}
				}

				if(action === 'create') self.update();
			} else {


				return;
			}
			if(self.rangeMin >= 0) {
				sliderOptions.format = {
					to : function(value) {
						return value.toFixed(decimalPrecision);
					},
					from : function(value) {
						return value;
					}
				};
			}
			var tmpStartLower = sliderOptions.range.min,
				tmpStartUpper = sliderOptions.range.max;

			if (!utils.isEmpty(opts.start)) {
				tmpStartLower = parseFloat(opts.start[0]);
				tmpStartUpper = parseFloat(opts.start[1]);

			}
			if (sliderOptions.sliderType == "top") {
				sliderOptions.start = [tmpStartUpper];
				sliderOptions.connect = 'lower';
				self.min.disabled = true;
				self.min.value = sliderOptions.range.min;
			} else if (sliderOptions.sliderType == "bot") {
				sliderOptions.start = [tmpStartLower];
				sliderOptions.connect = 'upper';
				self.max.disabled = true;
				self.max.value = sliderOptions.range.max;
			} else {
				sliderOptions.start = [tmpStartLower, tmpStartUpper];
				sliderOptions.connect = true;
			}
			if(action === 'create') {
				noUiSlider.create(self.slider, sliderOptions);
			}
			else {
				if(self.slider.noUiSlider !== undefined && opts.slidertype !== "" && !Number.isNaN(self.rangeMin) && !Number.isNaN(self.rangeMax)) {
					self.slider.noUiSlider.updateOptions(sliderOptions);
				}
			}
		}

		self.getSliderData = function() {
			var sliderVals = {};
			var whichFilter = self.id;
			var sliderData = {};

			sliderVals.min = Number(self.min.value);
			if (self.max) {
				sliderVals.max = Number(self.max.value);
			}

			sliderData['cid'] = whichFilter;

				sliderData['val'] = sliderVals;


			return sliderData;
		}

		self.changedVal = function(skipFilter) {


			if (typeof skipFilter !== "boolean") skipFilter = false;
			var curVals = [];

			if (sliderOptions.sliderType == "top") {
				curVals = [self.max.value];
			} else if (sliderOptions.sliderType == "bot") {
				curVals = [self.min.value];
			} else {
				if (self.max) {
					curVals = [self.min.value, self.max.value];
				} else {
					curVals = [self.min.value]
				}
			}

			tmpInput = curVals;
			if (self.slider.noUiSlider !== undefined) {
				self.slider.noUiSlider.set(curVals);
				if (!skipFilter) self.onSliderChange(self.getSliderData());
			}
		}

	
});

$(function() {


	/*
	if (window.location.href.indexOf('ti_zh') > -1 || window.location.href.indexOf('/cn/') > -1) lang = "cn";
	else if (window.location.href.indexOf('ti_ja') > -1 || window.location.href.indexOf('/jp/') > -1) lang = "jp";
	else if (window.location.href.indexOf('ti_ko') > -1) lang = "kr";
	else if (window.location.href.indexOf('ti_de') > -1) lang = "de";
	*/	
	
	
	//animating tree
	$("#ls-canvas").addClass("collapsed-animated");
	setTimeout(function(){
		$("#ls-canvas").addClass("collapsed").removeClass("collapsed-animated");
		RiotControl.trigger("tree_toggle");
	}, 2200);

	com.TI.rst.partStore = new com.TI.rst.storeDef.PartStore();
	com.TI.rst.filterStore = new com.TI.rst.storeDef.FilterStore();
	com.TI.rst.langStore = new com.TI.rst.storeDef.LanguageStore();

	RiotControl.addStore(com.TI.rst.partStore);
	RiotControl.addStore(com.TI.rst.filterStore);
	RiotControl.addStore(com.TI.rst.langStore);
	
	riot.mount('ti-selection-tool');

});